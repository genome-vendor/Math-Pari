

=head1 NAME

libPARI - Functions and Operations available in PARI and GP

=head1 DESCRIPTION



The functions and operators available in PARI and in the GP/PARI calculator
are numerous and everexpanding. Here is a description of the ones available
in version 1.39.3. It should be noted that many of these functions accept
quite different types as arguments, but others are more restricted. The list
of acceptable types will be given for each function or class of functions.
Except when stated otherwise, it is understood that a function or operation
which should make natural sense is legal.
In this chapter, we will describe the functions according to a rough
classification. For the functions in alphabetical order, see the general 
index.

When not mentioned otherwise, the result of a function is assumed implicitly
to be a C<GEN>. Most other functions return an object of type 
C<long integer> in C.



=head1 Standard monadic or dyadic operators.





=head2 C<F<+->>

The expressions C<+x> and C<-x> refer to monadic operators
(C<+x> does nothing and C<-x> negates C<x>).

The library syntax is C<gneg(x)> for C<-x>.



=head2 C<+>, C<->

The expression C<x+y> is the X<sum>sum and C<x-y> is the X<difference>difference of
C<x> and C<y>.
Among the prominent impossibilities are addition/subtraction between a scalar
type and a vector or a matrix, between vector/matrices of incompatible sizes
and between an integermod and a real number.

The library syntax is C<gadd(x,y)> for C<x+y>, C<gsub(x,y)>
for C<x-y>.



=head2 C<*>

The expression C<x*y> is the X<product>product of C<x> and C<y>. Among the
prominent impossibilities are multiplication between vector/matrices of
incompatible sizes, between an integermod and a real number. Note
that because of vector and matrix operations, C<*> is not necessarily
commutative. Note also that since multiplication between two column or two
row
vectors is not allowed, to obtain the X<scalar product>scalar product of two vectors of the
same
length, you must multiply a line vector by a column vector, if necessary by
transposing one of the vectors (using C<~> or C<transC<( )>>, see section 8).

The library syntax is C<gmul(x,y)> for C<x*y>.



=head2 C</>

The expression C<x/y> is the X<quotient>quotient of C<x> and C<y>. In addition to the
impossibilities for multiplication, note that if the divisor is a matrix, it
must be an invertible square matrix, and in that case the result is C<x*y^{-1}>.
Furthermore note that the result is as
exact as possible: in particular, division of two integers always gives a
rational number (which may be an integer if the quotient is exact) and I<not> the Euclidean quotient (see C<x\y> for that), and similarly the
quotient of two polynomials is a rational function in general. To obtain the
approximate real value of the quotient of two integers, add C<0.> to the
result; to obtain the approximate C<p>-adic value of the quotient of two
integers, add C<O(p^k)> to the result; finally,
to obtain the X<taylor series>taylor series expansion of the quotient of two polynomials,
add C<O(X^k)> to the result or use the C<taylor> function (see section 7).

The library syntax is C<gdiv(x,y)> for C<x/y>.



=head2 C<\>

The expression C<x\y> is the X<Euclidean quotient>Euclidean quotient of C<x> and C<y>.
The types must be either
both integer or both polynomials. The result is the Euclidean quotient.
In the case of integer division, the quotient is such that the corresponding
remainder is non-negative.

The library syntax is C<gdivent(x,y)> for C<x\y>.



=head2 C<\/>

The expression C<x\/y> is the Euclidean quotient of C<x> and 
C<y>. 
The types must be either both integer or both polynomials. The result is the
rounded Euclidean quotient. In the case of integer division, the quotient is 
such that the corresponding remainder is smallest in absolute value and in
case of a tie the quotient closest to C<+\infty> is chosen.

The library syntax is C<gdivround(x,y)> for C<x\/y>.



=head2 C<%>

The expression C<x%y> is the X<Euclidean remainder>Euclidean remainder of C<x> and C<y>. The 
modulus C<y> must be of type integer or polynomial.
The result is the remainder, always non-negative
in the case of integers. Allowed dividend types are scalar exact types when
the modulus is an integer, and polynomials, polymods and rational functions
when the modulus is a polynomial.

The library syntax is C<gmod(x,y)> for C<x%y>.



=head2 X<divres>divresC<(x,y)>

creates a column vector with two components,
the first being the Euclidean quotient, the second the Euclidean remainder,
of the division of C<x> by C<y>. This avoids the need to do two divisions if
one needs both the quotient and the remainder. The arguments must be both
integers or both polynomials, and in the case of integers the remainder
is of the sign of the dividend.

The library syntax is C<gdiventres(x,y)>.



=head2 C<^>

The expression C<x^y> is X<powering>powering. If the exponent is an integer,
then exact
operations are performed using binary powering techniques. In particular, in
this case
the first argument cannot be a vector or matrix unless it is a square matrix
(and moreover invertible if the exponent is negative). If the exponent is
not of type integer, this is treated as a transcendental function (see section 3),
and in particular has the effect of componentwise powering on vector or
matrices.

The library syntax is C<gpui(x,y,prec)> for C<x^y>
where the precision parameter C<prec> must be given only if C<y> is not
integral but C<x> is an exact (real or complex) type.

In addition, there are two shift functions (i.e. multiplication and division
by powers of 2) which are faster than the general multiplication or division
routines:



=head2 X<shift>shiftC<(x,n)>

shift C<x> componentwise left by C<n> bits if C<nE<gt>=0> and 
right by C<-n> bits if C<n<0>. A left shift by C<n> corresponds to multiplication
by C<2^n>. A right shift by C<-n> corresponds to a Euclidean division of
C<x> by C<2^{-n}> with a remainder of the same sign as C<x>, hence is not the
same (in general) as C<x\2^n>.

The library syntax is C<gshift(x,n)> where C<n> is a C-long integer.



=head2 X<shiftmul>shiftmulC<(x,n)>

multiply C<x> by C<2^n>. The difference with
C<shift> is that when C<n<0>, the ordinary division takes place, hence for
example if C<x> is an integer the result may be a fraction, while for 
C<shift> Euclidean division takes place when C<n<0> hence if C<x> is an
integer the result is still an integer.

The library syntax is C<gmul2n(x,n)> where C<n> is a C-long integer.



=head2 comparison and X<boolean operators>boolean operators.

The six standard X<comparison operators>comparison operators
C<<=>, C<<>, C<E<gt>=>, C<E<gt>>, C<==>, C<!=> are available in GP, and in library mode 
under the names B<X<gle>gle, X<glt>glt, X<gge>gge, X<ggt>ggt, X<geq>geq,
X<gne>gne> respectively. The 
library syntax is C<B<co>(x,y)>, where co is the comparison 
operator. The result is 1 (as a GEN) if the comparison is true, 0 (as a GEN)
if it is false.

The standard boolean functions C<| |> (X<inclusive or>inclusive or) and C<&&> (X<and>and) X<or>are
also available, and the library syntax is C<gor(x,y)> and
C<gand(x,y)> respectively. Note that to avoid confusion with the
factorial function, there is no C<!> (X<not>not) operator, but this can easily be circumvented.

In library mode, it is in fact usually preferable to use the two basic 
functions which are C<gcmp(x,y)> which gives
the sign (1, 0, or -1) of C<x-y>, where C<x> and C<y> must be in C<B<I<R>>>,
and C<gegal(x,y)> which can be applied to any two PARI objects
C<x> and C<y> and gives 1 (i.e. true) if they are equal (but not necessarily
identical), 0 (i.e. false) otherwise. Particular cases of gegal which
should be used are C<gcmp0(x)> (C<x=0> ?), C<gcmp1(x)>
(C<x=1> ?), and X<gcmp_1> B<gcmp_1> C<(x)> (C<x=-1> ?).

Note that C<gcmp0(x)> tests whether C<x> is equal to zero, even if
C<x> is not an exact object. To test whether C<x> is an exact object which
is equal to zero, one must use C<isexactzero>.

Also note that the C<gcmpx> and C<gegal> functions return a C-integer,
and I<not> a GEN like C<gle> etc.



GP accepts the following synonyms for some of the above functions:
since there is no bitwise C<and> or bitwise C<or>, C<|> and C<&> are accepted asX<bitwise and> X<bitwise or>
synonyms of C<| |> and C<&&> respectively. Also, C<<E<gt>> is accepted as a
synonym for C<!=>. On the other hand, C<=> is definitely I<not> a
synonym for C<==> since it is the assignment statement.



=head2 X<lex>lexC<(x,y)>

gives the result of a lexicographic comparison between C<x> and C<y>.
This is to be interpreted in quite a wide sense. For example,  the vector C<[1,3]>
will be considered smaller than the longer vector C<[1,3,-1]> (but of course larger
than C<[1,2,5]>), i.e. C<lex([1,3],[1,3,-1])> will give -1 as a result.

The library syntax is C<lexcmp(x,y)>.



=head2 X<sign>signC<(x)>

X<sign>sign of C<x>, which must be of type
integer, real or fraction. The result (0, 1 or -1) is a C-long integer.

The library syntax is C<gsigne(x)>.



=head2 X<max>maxC<(x,y)> and B<X<min>min>C<(x,y)>

create the
maximum and minimum of C<x> and C<y> when they can be compared.

The library syntax is C<gmax(x,y)> and C<gmin(x,y)>.



=head2 Important remark.

In all the above library syntaxes, we have
given only the basic names of the functions. For example C<C<gadd>(x,y
)>
assumes that C<x> and C<y> are PARI objects (the GEN type) and I<creates>
the result C<x+y> on the PARI stack. From most of these basic names, the names
and
effects of other functions can be obtained in the following way. We give
the example for gadd, but the same is true for all the other functions
above, and a few more that we have not given:

C<gaddgs(x,y)>: here C<x> is a GEN, C<y> is an ordinary C-long integer.

C<gaddsg(x,y)>: here C<x> is an ordinary C-long integer, C<y> is a
GEN.

C<gaddz(x,y,z), gaddgsz(x,y,z), gaddsgz(x,y,z)>: here C<z> is a
preexisting GEN and the result of the corresponding operation is put in C<z>.
The size of the PARI stack does not change.

As simplification to programming, for many functions beginning with a B<g>, such
as gadd, one can replace the B<g> by an B<l> to obtain a B<long>
result instead
of a GEN (i.e. pointer to long) result. For instance C<ladd(x,y)> is
identical with C<(C<(long)gadd>(x,y))>. These macros are written in
the files listed in C<X<gencom.h>gencom.h>. Note that C<ldiv> is an
ANSI C function name which is used to mean C<(long)gdiv> in PARI.



=head1 Conversions and similar elementary functions or commands



Many of the conversion functions are rounding or truncating operations.
In this case, if the argument is a rational function, the result is the
Euclidean quotient of the numerator by the denominator, and if the argument
is a vector or a matrix, the operation is done componentwise. This will not
be restated for every function.



=head2 X<allocatemem>allocatememC<(x)>

this is a very special operation which
allows the user to change the stack size I<after> initialization.
C<x> must be a non-negative integer. If C<xE<gt>2>, a new stack of size
C<16*\lceil x/16\rceil> bytes will be allocated, all the PARI data on the
old stack will be moved to the new one, and the old stack will be freed
and discarded. If C<x=0>, C<1> or C<2>, the size of the new stack will be
double that of the old one. Finally, in case C<x=0>, after doubling the stack,
a warning message will be printed.

Although it is a function, this must be the I<only> instruction in a GP
line. The technical reason is that this program terminates by a longjmp
and not by a return.

The library syntax is C<allocatemoremem(x)>, where C<x> is an unsigned 
long, and the return type is void. GP uses a variant which ends by a longjmp.



=head2 X<binary>binaryC<(x)>

outputs the vector of the binary digits of C<|x|>.
Here C<x> can be an integer, a real number (in which case the result has two
components, one for the integer part, one for the fractional part) or a
vector/matrix.

The library syntax is C<binaire(x)>.



=head2 X<bittest>bittestC<(x,n)>

outputs the C<n^{th}> bit of C<|x|> starting
from the right (i.e. the coefficient of C<2^n> in the binary expansion of C<x>.
The result is 0 or 1.

The library syntax is C<bittest(x,n)>, where C<n> as well as the result
are C-long integers.



=head2 X<bytesize>bytesizeC<(x)>

outputs the total number of bytes occupied by the
tree representing the PARI object C<x>.

The library syntax is C<taille2(x)> which returns a C-long integer. The
function C<taille> returns the number of I<words> instead.



=head2 X<ceil>ceilC<(x)>

ceiling of C<x>. When C<x> is in C<B<I<R>>>,
the result is the smallest integer greater than or equal to C<x>.

The library syntax is C<gceil(x)>.



=head2 X<centerlift>centerliftC<(x)>

lifts an element C<x=a  mod  n> of C<B<I<Z>>/nB<I<Z>>> to
C<a> in C<B<I<Z>>>, and similarly lifts a polymod to a polynomial. This is the same
as C<lift> except that in the particular case of elements of C<B<I<Z>>/nB<I<Z>>>, the
lift C<y> is such that C<-n/2<yE<lt>= n/2>. If C<x> is
of type fraction, complex, quadratic, polynomial, power series, rational
function, vector or matrix, the lift is done for each coefficient.
Forbidden types for C<x> are reals and C<p>-adics. Note that the main variable
of the lift of a polymod will be variable number 0 (i.e. 'X') if the rules
concerning the creation of polymods explained in Chapter 2 are observed.

The library syntax is C<centerlift(x)>.



=head2 X<changevar>changevarC<(x,y)>

create a copy of the object C<x> where its
variables are modified according to the permutation specified by the vector C<y>.
For example, assume that the variables have been introduced in the
order C<x>, C<a>, C<b>, C<c>. Then,
if C<y> is the vector C<[x,c,a,b]>, the variable C<a> will be
replaced by C<c>, C<b> by C<a>, and C<c> by C<b>, C<x>
being unchanged. Note that the permutation must be completely
specified, e.g. C<[c,a,b]> would not work, since this would replace
C<x> by C<c>, and leave C<a> and C<b> unchanged (as well as
C<c> which is the fourth variable of the initial list). In particular, the
new variable names must be distinct.

The library syntax is C<changevar(x,y)>.



=head2 X<components>components of a PARI object

There are essentially three ways to extract the components from a PARI object.

The first and most general, is the function C<compo(x,n)> which extracts
the C<n^{th}>-component of C<x>. This is to be understood
as follows: every PARI type has one or two initial X<code words>code words. The components
are counted,
starting at 1, after these code words. In particular if C<x> is a vector, this
is indeed
the C<n^{th}>-component of C<x>, if C<x> is a matrix, the C<n^{th}>
column,
if C<x> is a polynomial, the C<n^{th}> coefficient (i.e. of degree
C<n-1>),
and for power series, the C<n^{th}> significant coefficient. The use
of the function C<compo> implies the knowledge of the structure of the
different PARI types, which can be recalled by typing C<\>t under GP.

The library syntax is C<compo(x,n)>, where C<n> is a C-long integer.

The two other methods are more natural but more restricted. First, the
function C<coeff(x,n)> gives the coefficient of degree C<n> of the
polynomial or power series C<x>, with respect to the main variable of C<x>
(to see the order of the variables or to change it, use the function 
C<reorder>, see section 11). In particular if C<n> is less than the valuation of C<x> or
in the case of a polynomial, greater than the degree, the result is zero
(contrary to C<compo> which would send an error message). If C<x> is a power
series and C<n> is greater than the largest significant degree, then an error
message is issued.

For greater flexibility, vector or matrix types are also accepted for C<x>, and
the meaning is then identical with that of C<compo>.

Finally note that a scalar type is considered by C<coeff> as a polynomial
of degree zero.

The library syntax is C<truecoeff(x,n)>.

The third method is specific to vectors or matrices under GP. If C<x> is a
(row or column) vector, then C<X<x[n]>x[n]> represents the C<n^{th}>
component of C<x>, i.e. C<compo(x,n)>. It is more natural and shorter to
write. If C<x> is a matrix, C<X<x[m,n]>x[m,n]> represents the coefficient of
row C<m> and column C<n> of the matrix, C<X<x[m,]>x[m,]> represents
the C<m^{th}> I<row> of C<x>, and C<X<x[,n]>x[,n]> represents
the C<n^{th}> I<column> of C<x>.

Finally note that in library mode, the macro C<coeff(x,m,n)> exists with
exactly the meaning of C<x[m,n]> under GP when C<x> is a matrix. This macro
should not be confused with the two-variable macro C<coeff> used primarily
for polynomials and power series under GP.X<coeff (in library mode)>

In addition the library mode macro C<coeff> does not create a copy of the
coefficient (contrary to all the GP functions) and can be put on the left
side of an assignment statement, and has value a C<long integer>. The macro
C<gcoeff> can be used as a synonym for C<(GEN)coeff> hence cannot be
put on the left side of an assignment.



=head2 X<conj>conjC<(x)> or C<x_>

conjugate of C<x>. The meaning of this
is clear, except that for real quadratic numbers, it means conjugation in the
real quadratic field. This function has no effect on integers, reals,
integermods, fractions or C<p>-adics. The only forbidden type is polymod
(see C<conjvec> for this).

The library syntax is C<gconj(x)>.



=head2 X<conjvec>conjvecC<(x)>

conjugate vector representation of C<x>. If C<x> is
a polymod C<mod(a,q)>, this gives a vector of length C<degree(q)>
containing
the complex embeddings of the polymod if C<q> has integral or rational
coefficients, and the conjugates of the polymod if C<q> has some integermod
coefficients. The order is the same as that of the C<roots> functions.
If C<x> is a integer or a rational number, the result is C<x>.
If C<x> is a (row or column) vector, the result is a matrix whose columns are
the conjugate vectors of the individual elements of C<x>.

The library syntax is C<conjvec(x,prec)>, where C<prec> is a C-long 
integer.



=head2 X<cvtoi>cvtoiC<(x)>

If C<x> is in C<B<I<R>>>, truncates C<x> to an
integer.
If the result is not significant because the exponent of C<x> is too large
compared to its precision, no error occurs, but the number of lost
significant
bits is put at the address specified in a second argument. This is transparent
under GP, but this second argument must be given in library mode. If no
digits
are lost, this second argument contains the negative of the number of
significant bits of the fractional part.

The library syntax is C<gcvtoi(x,& e)>, where C<e> is a C-long integer.



=head2 X<denom>denomC<(x)>

lowest denominator of C<x>. The meaning of
this is clear when C<x> is a rational number or function.
When C<x> is an integer or a polynomial, the result is equal to 1. When C<x> is 
a vector or a matrix, the lowest common denominator of the components of C<x>
is computed. All other types are forbidden.

The library syntax is C<denom(x)>.



=head2 X<floor>floorC<(x)>

floor of C<x>. When C<x> is in C<B<I<R>>>,
the result is the largest integer smaller than or equal to C<x>.

The library syntax is C<gfloor(x)>.



=head2 X<frac>fracC<(x)>

fractional part of C<x>. Identical to
C<x-floor(x)>. If C<x> is real, the result is in C<[0,1[>.

The library syntax is C<gfrac(x)>.



=head2 X<getheap>getheapC<()>

returns a two-component row vector giving the
number of objects on the heap and the amount of memory they occupy in long
words. Useful mainly for debugging purposes.

The library syntax is C<getheap()>.



=head2 X<getrand>getrandC<()>

returns the current value of the random number 
seed. Useful mainly for debugging purposes.

The library syntax is C<getrand()>. The value returned is a GEN.



=head2 X<getstack>getstackC<()>

returns the current value of C<topC<->avma>,
i.e. the number of bytes used up to now on the stack. Useful mainly for
debugging purposes.

The library syntax is C<getstack()>. The value returned is a GEN.



=head2 X<gettime>gettimeC<()>

returns the time (in milliseconds) elapsed since 
either the last call to C<gettime>, or to the beginning of the containing 
GP instruction (if inside GP), whichever came last.

The library syntax is C<gettime()>. The value returned is a GEN.



=head2 X<imag>imagC<(x)>

imaginary part of C<x>. When
C<x> is a quadratic number, this is the coefficient of C<F<omega>> in
the ``canonical'' integral basis C<(1, F<omega>)>.

The library syntax is C<gimag(x)>.



=head2 X<length>lengthC<(x)>

number of non-code words in C<x> really used
(i.e. the effective length minus 2 for integers and polynomials). In particular,
the degree of a polynomial is equal to its length minus 1.

The library syntax is C<glength(x)>.



=head2 X<lift>liftC<(x)>

lifts an element C<x=a  mod  n> of C<B<I<Z>>/nB<I<Z>>> to
C<a> in C<B<I<Z>>>, and similarly lifts a polymod to a polynomial. If C<x> is
of type fraction, complex, quadratic, polynomial, power series, rational
function, vector or matrix, the lift is done for each coefficient.
Forbidden types for C<x> are reals and C<p>-adics. Note that the main variable
of the lift of a polymod will be variable number 0 (i.e. 'X') if the rules
concerning the creation of polymods explained in Chapter 2 are observed.

The library syntax is C<lift(x)>.



=head2 X<mod>modC<(x,y)>

creates the PARI object C<(x  F<mod>  y)>,
i.e. an integermod or a polymod. C<y> must be an integer or
a polynomial. If C<y> is an integer, C<x> must be an integer. If C<y> is a
polynomial, C<x> must be a scalar or a polynomial. The result is put on
the PARI stack.

This function is not the same as C<x% y>, the result of which is an
integer or a polynomial.

The library syntax is C<gmodulcp(x,y)>. 



=head2 X<modp>modpC<(x,y)>

same effect as C<mod>, except that the created
result is put on the heap and not on the stack, and hence becomes a permanent
copy which cannot be erased later by garbage collecting (see 4.2.4). In 
particular, care should be taken to avoid creating too many such objects,
since the heap is very small (typically a few thousand objects at most).

The library syntax is C<gmodulo(x,y)>.



=head2 X<norm>normC<(x)>

algebraic norm of C<x>, i.e. the product of C<x>
with its conjugate (no square roots are taken), or conjugates for polymods.
For vectors and matrices, the norm is taken componentwise and hence is
not the C<L^2>-norm (see C<norml2> below). Note that the norm of an element of
C<B<I<R>>> is its square, so as to be compatible with the complex norm.

The library syntax is C<gnorm(x)>.



=head2 X<norml2>norml2C<(x)>

square of the C<L^2>-norm of C<x>. C<x> must
be a (row or column) vector.

The library syntax is C<gnorml2(x)>.



=head2 X<numer>numerC<(x)>

numerator of C<x>. When C<x> is a rational number
or function, the meaning is clear. When C<x> is an integer or a polynomial, the
result is C<x> itself. When C<x> is a vector or a matrix, then C<numer(x)> is
defined to be C<denom(x)*x>. All other types are forbidden.

The library syntax is C<numer(x)>.



=head2 X<padicprec>padicprecC<(x,p)>

absolute C<p>-adic precision of the object C<x>.
This is the minimum precision of the components of C<x>. The result is
C<VERYBIGINT> (C<2^{31}-1> for 32-bit machines or C<2^{63}-1> for 64-bit
machines) if C<x> is an exact object.

The library syntax is C<padicprec(x,p)> and the result is a C-long
integer.



=head2 X<permutation>permutationC<(n,k)>

generates the C<k>-th permutation (as a 
row vector of length C<n>) of the numbers C<1> to C<n>. The number C<k> is taken 
modulo C<n! >.

The library syntax is C<permute(n,k)>, where C<n> is a C-long integer.



=head2 X<permutation2num>permutation2numC<(x)>

given a permutation C<x> on C<n> elements,
gives the number C<k> such that C<x=>permutationC<(n,k)>, i.e. inverse
function of C<permutation>.

The library syntax is C<permuteInv(x)>.



=head2 X<polvar>polvarC<(x)>

gives the main variable of the object C<x>, and
C<p> if C<x> is a C<p>-adic number. Gives an error if C<x> has no variable
associated to it. Note that this function is useful only in GP, since
in library mode the function C<gvar> is more useful.

The library syntax is C<gpolvar(x)>. However, in library mode,
this function should not be used. Instead, test whether C<x> is a C<p>-adic
(type 7), in which case C<p> is in C<x[2]>, or call the function 
C<gvar(x)> which returns the variable I<number> of C<x> if it 
exists, BIGINT otherwise.



=head2 X<poly>polyC<(x,v)>

transform the object C<x> into a polynomial with main
variable C<v>. If C<x> is a scalar, this gives a constant polynomial. If C<x> is
a power series, the effect is identical to C<trunc> (see below), i.e. it
chops off the C<O(X^k)>. If C<x> is a vector, this function creates the polynomial
whose coefficients are given in C<x>, with C<x[1]> being the leading coefficient
(which can be zero).

Warning: this is I<not> a substitution function. It is intended to be quick and
dirty. So if you try C<poly(a,y)> on the polynomial C<a=x+y>, you will get
C<y+y>, which is not a valid PARI/GP object.

The library syntax is C<gtopoly(x,v)>, where C<v> is a variable number.



=head2 X<polyrev>polyrevC<(x,v)>

transform the object C<x> into a polynomial with main
variable C<v>. If C<x> is a scalar, this gives a constant polynomial. If C<x> is
a power series, the effect is identical to C<trunc> (see below), i.e. it
chops off the C<O(X^k)>. If C<x> is a vector, this function creates the polynomial
whose coefficients are given in C<x>, with C<x[1]> being the constant term. Note that
this is the reverse of C<poly> if C<x> is a vector, otherwise it is identical to
C<poly>.

The library syntax is C<gtopolyrev(x,v)>, where C<v> is a variable number.



=head2 X<prec>precC<(x,n)>

C<x> being a PARI object and C<n> a C-long integer, 
creates a new object equal to C<x> but with a new precision C<n>.
This is to be understood as follows:

For exact types, no change. For C<x> a vector or a matrix, the operation
is done componentwise.

For real C<x>, C<n> is the number of desired significant I<decimal> digits.
If C<n> is smaller than the precision of C<x>, C<x> is truncated, otherwise
C<x> is extended with zeros.

For C<x> a C<p>-adic or a power series, C<n> is the desired number of
significant C<p>-adic or C<X>-adic digits, where C<X> is the main variable of C<x>.

Note that the function C<prec> never changes the type of the result. In
particular
it is not possible to use C<prec> to obtain a polynomial from a power series.
For that, see C<trunc> (see below).

The library syntax is C<gprec(x,n)>, where C<n> is a C-long integer.



=head2 X<quadgen>quadgenC<(x)>

creates the quadratic number X<omega>
C<F<omega>=(a+ F<sqrt> x)/2> where C<a=0> if C<x ~ 0 F<mod> 4>, 
C<a=1> if C<x ~ 1 F<mod> 4>, so that C<(1,F<omega>)> is an integral basis for
the quadratic order of discriminant C<x>. C<x> must be an integer congruent to 
0 or 1 modulo 4.

The library syntax is C<quadgen(x)>.



=head2 X<quadpoly>quadpolyC<(x)>

creates the ``canonical'' quadratic
polynomial corresponding to the discriminant C<x>, i.e. the minimal polynomial
of C<quadgen(x)>. C<x> must be an integer congruent to 0 or 1 modulo 4.

The library syntax is C<quadpoly(x)>.



=head2 X<random>randomC<()>

gives a random integer between 0 and C<2^{31}-1>
(in the case of 64-bit machines this can be changed at compilation time to
between 0 and C<2^{63}-1>). This is an internal PARI function and does not
depend on the system's random number generator.

The library syntax is C<genrand()> and the result is a C-long integer.



=head2 X<real>realC<(x)>

real part of C<x>. In the case where
C<x> is a quadratic number, this is the coefficient of C<1> in
the ``canonical'' integral basis C<(1, F<omega>)>.

The library syntax is C<greal(x)>.



=head2 X<rndtoi>rndtoiC<(x)>

same as C<cvtoi> (see above) except
that truncation is replaced by rounding (see C<round> below).

If the result is not significant because the exponent of C<x> is too large
compared to its precision, no error occurs, but the number of lost
significant
bits is put at the address specified in a second argument. This is transparent
under GP, but this second argument must be given in library mode. If no
digits
are lost, this second argument contains the negative of the number of
significant bits of the fractional part.

The library syntax is C<grndtoi(x,& e)>, where C<e> is a C-long integer.



=head2 X<round>roundC<(x)>

If C<x> is in C<B<I<R>>>, rounds C<x>
to the nearest integer. If the exponent of C<x> is too large compared
to its precision, the result is undefined and an error message occurs.
Use C<rndtoi> above to suppress this error handling.

Important remark: note that, contrary to the other truncation functions
(except C<rndtoi> which is essentially the same), this function operates
on every coefficient at every level of a PARI object. For example
C<trunc(\dfrac{2.4*X^2-1.7}{X})=2.4*X,> whereas
C<round(\dfrac{2.4*X^2-1.7}{X})=\dfrac{2*X^2-2}{X}.>
An important use of C<round> is to get exact results after a long
approximate computation, when theory tells you that the coefficients
must be integers.

The library syntax is C<ground(x)>.



=head2 X<rounderror>rounderrorC<(x)>

maximum error in decimal digits observed when
rounding C<x>. This functions allows the user to easily check the precision of
the rounding of a result whose components are supposed to be integers.

The library syntax is C<rounderror(x)> and the result is a C-long integer.



=head2 X<series>seriesC<(x,v)>

transform the object C<x> into a power series with
main variable C<v>. If C<x> is a scalar, this gives a constant power series
with precision given by the global variable C<precdl> (transparent under GP).
If C<x> is a polynomial, the precision is the greatest of C<precdl> and the
degree of the polynomial. If C<x> is a vector, the precision is similarly given,
and the coefficients of the vector are understood to be the coefficients of
the power series starting from the constant term (i.e. the reverse of the
function C<poly>, see above).

The warning given for C<poly> applies here: this is not a substitution
function.

The library syntax is C<gtoser(x,v)>, where C<v> is a variable number.



=head2 X<setprecision>setprecisionC<(n)>

sets the current default precision equal to C<n>
decimal digits if C<nE<gt>0>. In any case, it returns the value of the
default precision before the change. Apart from the fact that it returns a value, this is
identical to the C<\>precision=C<n> command, with the difference that
it can be used inside any GP expression or program.

The library syntax is C<setprecr(n)>, where C<n> is a C-long integer, as
is the returned value.



=head2 X<setrand>setrandC<(n)>

reseeds the random number generator to the value
C<n>. The initial seed (in UNIX systems at least) is C<n=1>.

The library syntax is C<setrand(n)>, where C<n> is a C-long integer. 
The value returned is C<n> once again, but as a GEN.



=head2 X<setserieslength>setserieslengthC<(n)>

sets the current default series length equal
to C<n> if C<nE<gt>0>. In any case, it returns the value of the default
length before the change. Apart from the fact that it returns a value, this is
identical to the C<\>serieslength=C<n> command, with the difference that
it can be used inside any GP expression or program.

The library syntax is C<setserieslength(n)>, where C<n> is a C-long integer, as
is the returned value.



=head2 X<settype>settypeC<(x,t)>

makes a copy of C<x> and sets its type equal to
type number C<t>. This function must be used with extreme caution, otherwise
disasters may occur, but one instance where it is extremely useful is
C<settyp(x,14)> when C<x> is a rational function (type 13). In this case,
the created object, as well as the objects created from it, will not be
reduced automatically, making the operations much faster. In fact this function
is the I<only> way to create reducible rationals (type 5) or rational
functions (type 14) in GP.

The library syntax is C<gsettype(x,t)>, where C<t> is a long, but need
not be used since the internal function C<settyp> is available. Note that
C<settyp> does I<not> create a copy of C<x>, while C<gsettype> does.
Note also the different spellings of the internal function C<settyp> and
of the GP function C<settype>.



=head2 X<simplify>simplifyC<(x)>

this function tries to simplify the object C<x> as
much as it can. The simplifications do not concern rational functions (which
PARI automatically tries to simplify), but type changes. Specifically, a 
complex or quadratic number whose imaginary part is exactly equal to 0 (i.e. 
not a real zero) is converted to its real part, and a polynomial of degree zero
is converted to its constant term. For all types, this of course occurs
recursively. This function is useful in any case, but in particular before
the use of arithmetic functions which expect integer arguments, and not for
example a complex number of 0 imaginary part and integer real part (which is
however printed as an integer).

The library syntax is C<simplify(x)>.



=head2 X<size>sizeC<(x)>

gives an upper bound for the maximal number of decimal
digits of the absolute value of the components of C<x>, off by at most 1.

The library syntax is C<gsize(x)>, and the result is a C-long integer.



=head2 X<trunc>truncC<(x)>

truncation of C<x>. When C<x> is in C<B<I<R>>>,
this means that the part after the decimal point is chopped away. If the
result is not significant because the exponent is too large compared
to the precision, an error occurs. Use C<cvtoi> (see above) to suppress this error
handling.

Note a very special use of C<trunc>: when applied to a power series, it
transforms it into a polynomial or a rational function with denominator
a power of C<X>, by chopping away the C<O(X^k)>. Similarly, when applied to
a C<p>-adic number, it transforms it into an integer or a rational number
by chopping away the C<O(p^k)>.

The library syntax is C<gtrunc(x)>.



=head2 X<type>typeC<(x)>

internal type number (from 1 to 19) of the PARI object
C<x>. This is useful only under GP. See also the function C<settype>.

The library syntax is C<gtype(x)>, but need not be used since the
internal function C<typ> is available. Note that C<gtype> gives a
GEN while C<typ> gives a C-long integer. Note also the different spellings
of the internal function C<typ> and of the GP function C<type>.



=head2 X<valuation>valuationC<(x,p)>

Computes the highest exponent of C<p>
dividing C<x>. If C<p> is of type integer, C<x> must be an integer,
an integermod whose modulus is divisible by C<p>, a fraction, a
C<q>-adic number with C<q=p>, or a polynomial or power series 
in which case the valuation is the minimum of the valuation of the coefficients.

If C<p> is of type polynomial, C<x> must
be of type polynomial or rational function, and also a power series
if C<x> is a monomial. If C<x=0>, an error is issued except in case of
C<p>-adic numbers and power series, in which case the result is the
exponent of the zero. Finally, the valuation of a vector,
complex or quadratic number is the minimum of the component
valuations. Any other type combinations gives an error.

The library syntax is C<ggval(x)>, and the result is a C-long integer.



=head2 X<vec>vecC<(x)>

transform the object C<x> into a row vector. The vector will
be with one component only, except when C<x> is a vector/matrix or a quadratic
form (in which case the resulting vector is simply the initial object considered
as a row vector), but more importantly when C<x> is a polynomial or a power
series. In the case of a polynomial, the coefficients of the vector starts
with the leading coefficient of the polynomial, while for power series only
the significant coefficients are taken into account, but this time by
increasing order of degree.

The library syntax is C<gtovec(x)>.



=head2 X<vecmax>vecmaxC<(x)>

if C<x> is a vector or a matrix, returns the maximum
of the elements of C<x>, otherwise returns a copy of C<x>. Returns C<-\infty>
in the form of C<-(2^{31}-1)> (or C<-(2^{63}-1)> for 64-bit machines) if C<x> is
empty.

The library syntax is C<vecmax(x)>.



=head2 X<vecmin>vecminC<(x)>

if C<x> is a vector or a matrix, returns the minimum
of the elements of C<x>, otherwise returns a copy of C<x>. Returns C<+\infty>
in the form of C<2^{31}-1> (or C<2^{63}-1> for 64-bit machines) if C<x> is empty.

The library syntax is C<vecmin(x)>.



=head1 Transcendental functions.



As a general rule, which of course in some cases may have exceptions,
transcendental functions operate in the following way:

     If the argument is either an integer, a real, a rational, a complex
or a quadratic number, it is, if necessary, first converted to a real
(or complex) number using the current X<precision>precision held in the variable
B<prec>. Note that only exact arguments are converted, while inexact
arguments such as reals are not.

Under GP this is transparent to the user, but when programming
in library mode, care must be taken to supply the parameter C<prec> as 
the last argument of the function if the first argument is an exact object
(see 1.2.5.), otherwise disaster will occur.

 Note that in library mode
the precision argument C<prec> is a word count including codewords,
i.e. represents the length in words of a real number, while under GP
the precision (which is changed by the command C<C<\>precision>)
is the number of significant decimal digits.

Also note that for the same value of C<prec> you will obtain
different results on 32-bit and 64-bit machines. For example if the
value of C<prec> is 5, the corresponding accuracy for 32-bit machines
is C<(5-2)* F<log> (2^{32})/ F<log> (10) ~  28> decimal digits, while
for 64-bit machines it is C<(5-2)* F<log> (2^{64})/ F<log> (10) ~  57>
decimal digits. If you want your programs to run identically on 32-bit
and 64-bit machines, you must take care to change the C<prec>
parameter that you give according to the bit size, which is determined
using the compilation option C<-DLONG_IS_32BIT> or 
C<-DLONG_IS_64BIT>. For example, if you want the current value of
C<prec> to correspond to an accuracy of 38 decimal digits whatever
the word size, you could write

{\obeylines\tt
\#ifdef LONG_IS_32BIT
  prec = 6;
\#else
  prec = 4;
\#endif
}

Note that some accuracies attainable on 32-bit machines cannot be attained
on 64-bit machines for parity reasons. For example the default GP
accuracy is 28 decimal digits on 32-bit machines, corresponding to
C<prec> having the value 5, but this cannot be attained on 64-bit
machines.



After possible conversion, the function is computed. Note that even if 
the argument is real, the result may be complex (e.g. C<acos(2.0)>
or C<acosh(0.0)>).
Note also that the principal branch is always chosen.

     If the argument is an integermod or a C<p>-adic, at present only a
few functions like C<sqrt> (square root), C<sqr> (square), C<log>,
C<exp>, powering, C<teich> (Teichm\"uller character) and C<agm>
(arithmetic-geometric mean) are implemented.
Note that in the case of a C<2>-adic number,
C<C<sqr>(x)> is not identical to C<x*x>: for example if
C<x = 1+O(2^5)> then C<x*x = 1+O(2^5)> while C<C<sqr>(x) = 1+O(2^6)>.
(Remark: note that if we wanted to be strictly consistent with the
PARI philosophy, we should have C<x*y= (4  F<mod>  8)> when both C<x> and C<y> are
congruent to C<2> modulo C<4>, or C<C<sqr>(x)=(4 F<mod>  32)> when C<x> is
congruent to C<2> modulo C<4>. However, since an integermod is an exact object,
PARI assumes that the modulus must not change, and the result is hence
C<0  F<mod>  4> in both cases. On the other hand, C<p>-adics are not exact objects,
hence are treated differently.)

     If the argument is a polynomial, power series or rational function,
it is, if necessary, first converted to a power series using the current
precision held in the variable B<X<precdl>precdl>. Under GP this again is
transparent to the user. When programming in library mode, however, the
global variable C<precdl> must be set before calling the function
if the argument has an exact type (i.e. not a power series). Here C<precdl> is
not an argument of the function, but a global variable.

Then the Taylor series expansion of the function around C<X=0> (where C<X> is
the main variable) is computed
to a number of terms depending on the number of terms of the argument
and the function being computed.

     If the argument is a vector or a matrix, the result is componentwise
evaluation of the function. In particular, transcendental functions on
square matrices, which are not implemented in the present version 1.39.3{}
(see Appendix C however),
will have a slightly different name if they are implemented some day.



=head2 C<^>

If C<y> is not of type integer, C<x^y> has the
same effect as C< F<exp> (y* F<ln> (x))>. It can be applied to C<p>-adic numbers as
well as to the more usual types.X<powering>

The library syntax is C<gpui(x,y,prec)>.



=head2 X<abs>absC<(x)>

absolute value of C<x> (modulus if C<x> is complex).
Polynomials, power series and rational functions are not allowed. 
Contrary to most transcendental functions, an integer is I<not>
converted to a real number before applying C<abs>.

The library syntax is C<gabs(x,prec)>, where the second argument
C<prec> is necessary only in the complex or imaginary quadratic case.



=head2 X<acos>acosC<(x)>

principal branch of C<cos^{-1}(x)>,
i.e. such that C<Re(acos(x))\in [0,F<pi>]>. If
C<x\in B<I<R>>> and C<|x|E<gt>1>, then C<acos(x)> is complex.

The library syntax is C<gacos(x,prec)>.



=head2 X<acosh>acoshC<(x)>

principal branch of C<cosh^{-1}(x)>,
i.e. such that C<Im(acosh(x))\in [0,F<pi>]>. If
C<x\in B<I<R>>> and C<x<1>, then C<acosh(x)> is complex.

The library syntax is C<gach(x,prec)>.



=head2 X<agm>agmC<(x,y)>

arithmetic-geometric mean of C<x> and C<y>. In the
case of complex or negative numbers, the principal square root is always
chosen. C<p>-adic or power series arguments are also allowed. Note that
a C<p>-adic agm exists only if C<x/y> is congruent to 1 modulo C<p> (modulo
16 for C<p=2>). C<x> and C<y> cannot both be vectors or matrices.

The library syntax is C<agm(x,y,prec)>.



=head2 X<arg>argC<(x)>

argument of the complex number C<x>, such that
C<-F<pi><arg(x)E<lt>=F<pi>>.

The library syntax is C<garg(x,prec)>.



=head2 X<asin>asinC<(x)>

principal branch of C<sin^{-1}(x)>,
i.e. such that C<Re(asin(x))\in [-F<pi>/2,F<pi>/2]>. If
C<x\in B<I<R>>> and C<|x|E<gt>1> then C<asin(x)> is complex.

The library syntax is C<gasin(x,prec)>.



=head2 X<asinh>asinhC<(x)>

principal branch of C<sinh^{-1}(x)>,
i.e. such that C<Im(asinh)(x)\in [-F<pi>/2,F<pi>/2]>.

The library syntax is C<gash(x,prec)>.



=head2 X<atan>atanC<(x)>

principal branch of C<tan^{-1}(x)>,
i.e. such that C<Re(atan(x))\in ]-F<pi>/2,F<pi>/2[>.

The library syntax is C<gatan(x,prec)>.



=head2 X<atanh>atanhC<(x)>

principal branch of C<tanh^{-1}(x)>.
i.e. such that C<Im(atanh(x))\in ]-F<pi>/2,F<pi>/2]>. If
C<x\in B<I<R>>> and C<|x|E<gt>1> then C<atanh(x)> is complex.

The library syntax is C<gath(x,prec)>.



=head2 X<bernreal>bernrealC<(x)>

Bernoulli number C<B_x>, where C<B_0=1>, C<B_1=-1/2>,
C<B_2=1/6>,..., expressed as a real number with the current precision.
The argument C<x> should be of type integer.

The library syntax is C<bernreal(x,prec)>.



=head2 X<bernvec>bernvecC<(x)>

creates a vector containing, as rational numbers, the
Bernoulli numbers C<B_0>, C<B_2>,..., C<B_{2x}>. These Bernoulli numbers can
then be used as follows. Assume that this vector has been put into a variable,
say b. Then we define under GP:

C<bern(x)=if(x==1,-1/2,if((x<0)||(x%2),0,b[x/2+1]))>

and then C<bern(k)> gives the Bernoulli number of index C<k> as a rational
number, exactly as C<bernreal(k)> gives it as a real number.

The library syntax is C<bernvec(x)>.



=head2 X<cos>cosC<(x)>

cosine of C<x>.

The library syntax is C<gcos(x,prec)>.



=head2 X<cosh>coshC<(x)>

hyperbolic cosine of C<x>.

The library syntax is C<gch(x,prec)>.



=head2 X<dilog>dilogC<(x)>

principal branch of the dilogarithm of C<x>, i.e.
analytic continuation of the power series C< F<log> _2(x)=\sum_{nE<gt>=1}x^n/n^2>.

The library syntax is C<dilog(x,prec)>.



=head2 X<eint1>eint1C<(x)>

exponential integral 
C<\int_x^\infty \dfrac{e^{-t}}{t} dt>.

The library syntax is C<eint1(x,prec)>.



=head2 X<erfc>erfcC<(x)>

complementary error function
C<(2/ F<sqrt> F<pi>)\int_x^\infty e^{-t^2} dt>.

The library syntax is C<erfc(x,prec)>.



=head2 X<eta>etaC<(x)>

Dedekind's C<F<eta>> function, without the
C<q^{1/24}>. The meaning is this. If C<x> is a complex number with
positive imaginary part, the result is C<\prod_{n=1}^\infty(1-q^n)>,
where C<q=e^{2iF<pi> x}>. If C<x> is a power series (or can be converted
to a power series) with positive valuation, the result is C<\prod_{n=1}^\infty(1-x^n)>.

The library syntax is C<eta(x,prec)>.



=head2 euler

Euler's constant C<0.57721...>.

Note that C<euler> is one of the few special reserved names which cannot
be used for variables.

The library syntax is C<mpeuler(prec)> where C<prec> I<must> be
given.
Note that this creates C<F<gamma>> on the PARI stack. If one does not want to
create it on that stack but be able to use it later under the global
name B<X<geuler>geuler> (with no parentheses) use instead C<consteuler(prec
)>.



=head2 X<exp>expC<(x)>

exponential of C<x>.
C<p>-adic arguments with positive valuation are accepted.

The library syntax is C<gexp(x,prec)>.



=head2 X<gamh>gamhC<(x)>

gamma function evaluated at the argument
C<x+1/2>. When C<x> is an integer, this is much faster than using
C<gamma>C<(x+1/2)>.

The library syntax is C<ggamd(x,prec)>.



=head2 X<gamma>gammaC<(x)>

gamma function of C<x>. In the present version
1.39.3{} the C<p>-adic gamma function is not implemented.

The library syntax is C<ggamma(x,prec)>.



=head2 X<hyperu>hyperuC<(a,b,x)>

U-confluent hypergeometric function with
parameters C<a> and C<b>.

The library syntax is C<hyperu(a,b,x,prec)>.



=head2 X<incgam>incgamC<(x,y)>

incomplete gamma function.

The arguments C<x> and C<y> must be positive. The result returned is
C<\int_y^\infty e^{-t}t^{x-1} dt>.

The library syntax is C<incgam(x,y,prec)>.

Note: in addition, there exist also the functions
C<X<incgam1>incgam1 and X<incgam2>incgam2> which are used for internal purposes.



=head2 X<incgam3>incgam3C<(x,y)>

complementary incomplete gamma function.

The arguments C<x> and C<y> must be positive. The result returned is
C<\int_0^y e^{-t}t^{x-1} dt>, when C<y> is not too large.

The library syntax is C<incgam3(x,y,prec)>.



=head2 X<incgam4>incgam4C<(x,y,z)>

incomplete gamma function with given gamma value.
This function assumes (of course without checking) that C<z=F<Gamma>(x)>.
The arguments C<x> and C<y> must be positive. The result returned is
C<\int_y^\infty e^{-t}t^{x-1} dt>, as in the ordinary C<incgam> function,
but the computation will be much faster when C<y> is small.

The library syntax is C<incgam4(x,y, z,prec)>.



=head2 X<jbesselh>jbesselhC<(n,x)>

C<J>-Bessel function of half integral index.
More precisely, C<jbesselh(n,x)> computes C<J_{n+1/2}(x)> where C<n>
must be of type integer, and C<x> is any element of C<B<I<C>>>. In the
present version 1.39.3, this function is not very accurate when C<x> is
small.

The library syntax is C<jbesselh(n,x,prec)>.



=head2 X<jell>jellC<(x)>

elliptic C<j>-invariant. C<x> must be a complex
number with positive imaginary part, or convertible into a power series or
a C<p>-adic number with positive valuation.

The library syntax is C<jell(x,prec)>.



=head2 X<kbessel>kbesselC<(nu,x)>

K-Bessel function of index C<nu>
(which can be complex) and argument C<x>. Only real and positive arguments
C<x> are allowed in the present version 1.39.3.

The library syntax is C<kbessel(nu, x,prec)>.

Note: in addition, another implementation of this function which is often
faster than kbessel is the function B<X<kbessel2>kbessel2>.



=head2 X<ln>lnC<(x)> or B<log>C<(x)>

X<log> principal branch of the
natural logarithm of C<x>, i.e. such that C<Im(ln(x))\in ]-F<pi>,F<pi>]>.
The result is complex (with imaginary part equal to C<F<pi>>) if 
C<x\in B<I<R>>> and C<x<0>.

C<p>-adic arguments are also accepted for C<x>, with the convention that
C< F<ln> (p)=0>. Hence in particular C< F<exp> ( F<ln> (x))/x> will not in general be
equal to 1 but to a C<p-1>-th root of unity (or C<F<+->1> if C<p=2>)
times a power of C<p>.

The library syntax is C<glog(x,prec)>.



=head2 X<lngamma>lngammaC<(x)>

principal branch of the logarithm of the gamma
function of C<x>. Can have much larger arguments than C<gamma> itself.
In the present version 1.39.3{} the C<p>-adic lngamma function is not 
implemented.

The library syntax is C<glngamma(x,prec)>.



=head2 X<logagm>logagmC<(x)>

principal branch of the natural logarithm of C<x>,
computed using an agm formula suggested by Mestre, when C<x> is real, otherwise
identical to C<log>.

The library syntax is C<glogagm(x,prec)>.



=head2 pi

the constant pi (C<3.14159...>).

The library syntax is C<mppi(prec)> where C<prec> I<must> be given.
Note that this creates C<F<pi>> on the PARI stack. If one does not want to
create it on that stack but be able to use it later under the global
name B<X<gpi>gpi> (with no parentheses) use instead C<constpi(prec)>.



=head2 X<polylog>polylogC<(m,x)>

C<m^th> polylogarithm of C<x>, i.e. analytic
continuation of the power series C< F<log> _m(x)=\sum_{nE<gt>=1}x^n/n^m>. The program
uses the power series when C<|x|^2E<lt>=1/2>, and the power series expansion in
C< F<log> (x)> otherwise. It is valid in a large domain (at least C<|x|<230>), but should
not be used too far away from the unit circle since it is then better to use
the functional equation linking the value at C<x> to the value at C<1/x>, which
takes a trivial form for the C<polylogd> and C<polylogp> functions
below. Power series, polynomial, rational and vector/matrix arguments are
allowed.

The library syntax is C<gpolylog(m,x,prec)>.



=head2 X<polylogd>polylogdC<(m,x)>

modified C<m^th> polylogarithm of C<x>,
called C<~ D_m(x)> in Zagier, defined for C<|x|E<lt>=1> by
C<\Re_m(\sum_{k=0}^{m-1}\dfrac{(- F<log> |x|)^k}{k!} F<log> _{m-k}(x)
+\dfrac{(- F<log> |x|)^{m-1}}{m!} F<log> |1-x|)>
and such that C<D_m(1/x)=(-1)^{m-1}D_m(x)>, where C<\Re_m> denotes C<\Re>
or C<\Im> depending whether C<m> is odd or even.

The library syntax is C<polylogd(m,x,prec)>.



=head2 X<polylogdold>polylogdoldC<(m,x)>

modified C<m^th> polylogarithm of C<x>,
called C<D_m(x)> in Zagier, defined for C<|x|E<lt>=1> by
C<\Re_m(\sum_{k=0}^{m-1}\dfrac{(- F<log> |x|)^k}{k!} F<log> _{m-k}(x)
-\dfrac{1}{2}\dfrac{(- F<log> |x|)^m}{m!})>
and such that C<D_m(1/x)=(-1)^{m-1}D_m(x)>, where C<\Re_m> denotes C<\Re>
or C<\Im> depending whether C<m> is odd or even.

The library syntax is C<polylogdold(m,x,prec)>.



=head2 X<polylogp>polylogpC<(m,x)>

another modified C<m^th> polylogarithm
of C<x>, called C<P_m(x)> in Zagier, defined for C<|x|E<lt>=1> by
C<\Re_m(\sum_{k=0}^{m-1}\dfrac{2^kB_k}{k!}( F<log> |x|)^k F<log> _{m-k}(x)
-\dfrac{2^{m-1}B_m}{m!}( F<log> |x|)^m)>
and such that C<P_m(1/x)=(-1)^{m-1}P_m(x)>, where C<\Re_m> denotes C<\Re>
or C<\Im> depending whether C<m> is odd or even.

The library syntax is C<polylogp(m,x,prec)>.



=head2 X<psi>psiC<(x)>

the C<F<psi>>-function of C<x>, i.e. the
logarithmic derivative C<F<Gamma>'(x)/F<Gamma>(x)>.

The library syntax is C<gpsi(x,prec)>.



=head2 X<sin>sinC<(x)>

sine of C<x>.

The library syntax is C<gsin(x,prec)>.



=head2 X<sinh>sinhC<(x)>

hyperbolic sine of C<x>.

The library syntax is C<gsh(x,prec)>.



=head2 X<sqr>sqrC<(x)>

square of C<x>. Not identical to C<x*x> in
the case of C<2>-adics (see above), and acts componentwise
on vectors and matrices. In particular, if C<x> is a square matrix, sqr(C<x>)
is not the square of C<x> (use instead C<x*x> or C<x^2>).

The library syntax is C<gsqr(x)>.



=head2 X<sqrt>sqrtC<(x)>

principal branch of the square root of C<x>,
i.e. such that C<Arg(sqrt(x))\in ]-F<pi>/2,F<pi>/2]>, or in other words
such that C<Re(sqrt(x))E<gt>0> or C<Re(sqrt(x))=0> and
C<Im(sqrt(x))E<gt>=0>.
If C<x\in B<I<R>>> and C<x<0>, then the result is complex with positive 
imaginary part.

Integermod a prime and C<p>-adics are allowed as arguments. In that case,
the square root (if it exists) which is returned is the one whose 
first C<p>-adic digit (or its unique C<p>-adic digit in the case of
integermods) is in the interval C<[0,p/2]>.

The library syntax is C<gsqrt(x,prec)>.



=head2 X<tan>tanC<(x)>

tangent of C<x>.

The library syntax is C<gtan(x,prec)>.



=head2 X<tanh>tanhC<(x)>

hyperbolic tangent of C<x>.

The library syntax is C<gth(x,prec)>.



=head2 X<teich>teichC<(x)>

Teichmuller character of the C<p>-adic number
C<x>.

The library syntax is C<teich(x)>.



=head2 X<wf>wfC<(x)>

Weber's C<f> function, i.e. such that
C<j(x)=(f^{24}(x)-16)^3/f^{24}(x)>, where C<j> is the elliptic C<j>-invariant
(see the function C<jell> above).

The library syntax is C<wf(x,prec)>.



=head2 X<wf2>wf2C<(x)>

Weber's C<f_2> function, i.e. such that
C<j=(f_2^{24}+16)^3/f_2^{24}>.

The library syntax is C<wf2(x,prec)>.



=head2 X<zeta>zetaC<(s)>

Riemann's zeta function C<F<zeta>(s)=\sum_{nE<gt>=1}n^{-s}>,
computed using the Euler-Maclaurin summation formula, except when C<s> is of type
integer, in which case it is computed using Bernoulli numbers for C<sE<lt>=0> or
C<sE<gt>0> and even, and using modular forms for C<sE<gt>0> and odd.

The library syntax is C<gzeta(s,prec)>.



=head1 Arithmetic functions.



These functions are by definition functions whose natural domain
of definition is either C<B<I<Z>>> (or C<B<I<Z>>_{E<gt>0}>), or sometimes polynomials
over a base ring. Functions which concern polynomials exclusively will be
explained in the next section.
The way these functions are used is completely different from
transcendental functions: in general only the types integer and
polynomial are accepted as arguments.

In the present version 1.39.3{} a primitive but useful version of the X<ECM>ECM
method has been implemented. Also, numbers found to be pseudo-primes after
10 successful trials of the X<Rabin-Miller>Rabin-Miller test are declared primes.





=head2 X<addprimes>addprimesC<(x)>

add additional primes to the
table computed by C<init>, and return a row vector whose
first entries contain all primes added by the user and whose
last entries contain a 1. In total the returned row vector has 
20 components. C<x> must be a row or column vector with primes to be 
appended to that list. Whenever C<factor> or C<smallfact> 
is subsequently called, first the primes in the table computed
by C<init> will be checked, and then the additional primes
in this table.

The entries in C<x> are not checked for primality.
They should be positive integers not divisible by any
of the pre-computed primes.

The present PARI version 1.39.3{} allows up to 20 user-specified
primes to be appended to the table.  This limit may be changed
by altering C<NUMPRTBELT> in file C<init.c>.

The library syntax is C<addprimestotable(x)>.



=head2 X<bestappr>bestapprC<(x,k)>

if C<x\inB<I<R>>>, finds the best rational
approximation to C<x> with denominator at most equal to C<k> using continued
fractions. If C<x> is a generic type, C<bestappr> is used on each coefficient
independently.

The library syntax is C<bestappr(x,k)>.



=head2 X<bezout>bezoutC<(x,y)>

finds C<u> and C<v> minimal in a
natural sense such that C<x*u+y*v=gcd(x,y)>. The arguments
must be both integers or both polynomials, and the result is a
row vector with three components C<u>, C<v>, and C<gcd(x,y)>.

The library syntax is either C<vecbezout(x,y)> to get the
vector, or C<gbezout(x,y, & u, & v)> which gives as result the
address of the created gcd, and puts in C<u> and C<v> the addresses of the
corresponding created objects.



=head2 X<bigomega>bigomegaC<(x)>

number of prime
divisors of C<x> counted with multiplicity. C<x> must be an integer,
and the result is a C-long integer.

The library syntax is C<bigomega(x)>.



=head2 X<bin>binC<(x,y)>

X<binomial coefficient>binomial coefficient C<\binom x y>.
Here C<y> must be an integer, but C<x> can be any PARI object.

The library syntax is C<binome(x,y)>, where C<y> must be a C-long integer.



=head2 X<boundcf>boundcfC<(x,lmax)>

creates the row vector whose components are
the partial quotients of the X<continued fraction>continued fraction expansion of C<x>, the
number of partial quotients being limited to C<lmax>.
If C<x> is a real number, the expansion stops at the last significant partial
quotient or after lmax terms, whichever is smallest. C<x> can also be a rational
function or a power series.

The library syntax is C<gboundcf(x,lmax)>, where C<lmax> is a C integer.



=head2 X<boundfact>boundfactC<(x,p)>

For integer C<x>, finds only the prime factors
up to C<p> or to the default bound of the prime table created upon 
initialization of GP, whichever is lowest (except when C<pE<lt>=1> where the
effect is identical to C<smallfact>). The remaining part is hence not
necessarily prime. 

The library syntax is C<boundfact(x,p)>.



=head2 X<buchcertify>buchcertifyC<(bnf)>

C<bnf> being a big number field as output by
C<buchinit> or C<buchinitfu>, checks whether the result is correct,
i.e. whether it is possible to remove the assumption of the Generalized
Riemann Hypothesis. If it is correct, the answer is 1. If not, the program
may output some error message, but more probably will loop indefinitely.
In I<no> occasion can the program give a wrong answer: if the program
answers 1, barring bugs of course the answer is certified.

The library syntax is C<certifybuchall(bnf)>, and the result is
a C long.



=head2 X<buchfu>buchfuC<(bnf)>

C<bnf> being a big number field as output by
C<buchinit> or C<buchinitfu>, outputs a two component row vector giving
in the first component the vector of fundamental units of the number field,
and in the second component the number of bit of accuracy which remained in
the computation (which is always correct, otherwise an error message is
printed). This function is mainly for people who forgot to use C<buchinitfu>
instead of C<buchinit> after a long C<buchinit> computation.

The library syntax is C<buchfu(bnf)>.



=head2 X<buchimag>buchimagC<(D,c,c2)>

McCurley's sub-exponential algorithm for
computing the class group of an imaginary quadratic field of discriminant C<D>.
Should be used instead of C<classno> for C<|D|E<gt>10^{25}> or when the 
I<structure> is wanted. The numbers C<c> and C<c2> are positive real numbers
which control the execution time and the stack size. To get maximum speed,
set C<c2=c>. To get a rigorous result (under GRH) you must take C<c2=6>.
Reasonable values for C<c> are between C<0.1> and C<2>. 

The result of this function is a vector with 4 components. The first is the
class number, the second is a vector giving the structure of the class group
as a product of cyclic groups, and the third is a vector giving as binary
quadratic forms generators of those cyclic groups. The 
last component is a measure of the correctness of the result. If it is close
to 1, the result is correct (under GRH). If it is close to a larger integer,
this shows that the class number is off by a factor equal to this integer,
and you must start again with a larger value for C<c> or a different
random seed. In this case, a warning message is printed.

Note: some installations may have this function disabled.

The library syntax is C<buchimag(D,c,c2)>.



=head2 X<buchreal>buchrealC<(D,n,c,c2)>

Buchmann's sub-exponential algorithm for
computing the class group and the regulator of a real quadratic field of
discriminant C<D>. Should be used instead of C<classno> and C<regula> for
C<DE<gt>10^{10}> or when the I<structure> is wanted. If the integer C<n> is equal
to 0 the function computes the ordinary (or wide) class group and regulator,
while if C<n> is non-zero it computes the narrow class group and regulator
(this case is not yet implemented in version 1.39.3).
The numbers C<c> and C<c2> are positive real numbers which control the execution
time and the stack size. To get maximum speed,
set C<c2=c>. To get a rigorous result (under GRH) you must take C<c2=6>.
Reasonable values for C<c> are between C<0.1> and C<2>.

The result of this function is a vector with 5 components. The first is the 
class number, the second is a vector giving the structure of the class 
group as a product of cyclic groups, and the third is a vector giving as binary
quadratic forms generators of those cyclic groups. The fourth component is
the regulator, computed to an accuracy which is the maximum of an internal 
accuracy determined by the program and the current default (note that once the
regulator is known to a small accuracy it is 
trivial to compute it to very high accuracy. I leave this as an exercise to
the reader, or see the tutorial). The last component is a measure of
the correctness of the result. If it is close to 1, the results are correct 
(under GRH). If it is close to a larger integer, this shows that the product
of the class number by the regulator is off by a factor equal to this integer,
and you must start again with a larger value for C<c> or a different
random seed. In this case, a warning message is printed.

Note: some installations may have this function disabled.

The library syntax is C<buchreal(D,n,c,c2)>.



=head2 X<cf>cfC<(x)>

creates the row vector whose components are
the partial quotients of the X<continued fraction>continued fraction expansion of C<x>.
If C<x> is a real number, the expansion stops at the last significant partial
quotient. C<x> can also be a rational function.

The library syntax is C<gcf(x)>.



=head2 X<cf2>cf2C<(b,x)>

creates the row vector whose components are
the partial quotients of the continued fraction expansion of C<x>, the
numerators being equal to the coefficients of the vector C<b>. The length
of the result is equal to the length of C<b> unless a partial remainder is
encountered which is equal to zero, in which case the expansion stops.
In the case of real numbers, the stopping criterion in thus different
from that of C<cf> since if C<b> is too long, some partial quotients may
not be significant. C<x> can also be a rational function or a power series.

The library syntax is C<gcf2(b,x)>.



=head2 X<chinese>chineseC<(x,y)>

If C<x> and C<y> are both integermods or both
polymods, creates (with the same type) a C<z> in the same residue class
as C<x> and in the same residue class as C<y>, if it is possible.

This function also allows vector and matrix arguments,
in which case the operation is recursively applied to
each component of the vector or matrix.
For polynomial arguments, it is applied to each coefficient.
Finally C<chinese>C<(x,x) = x> regardless of the type of C<x>;
this allows vector inputs to contain other data types,
if this data is identical in both vectors.

The library syntax is C<chinois(x,y)>.



=head2 X<classno>classnoC<(x)>

class number of the quadratic field of discriminant
C<x>. In the present version 1.39.3, a simple algorithm is used for C<xE<gt>0>, so
C<x> should not be too large (say C<x<10^7>) for the time to be reasonable. On
the other hand, for C<x<0> one can reasonably compute classno(C<x>) for 
C<|x|<10^{25}>, since the method used is Shanks' method which is in
C<O(|x|^{1/4})>. For larger values of C<|D|>, see C<buchimag> for C<D < 0> and
C<buchreal> for C<DE<gt>0>.

The library syntax is C<classno(x)>.

There also exists the function C<X<classno2>classno2>, which computes the class
number using the functional equation. However, it is in C<O(|x|^{1/2})>. 
Finally, in library mode only there exists the function C<X<classno3>classno3> 
which computes the class number of an imaginary quadratic field by counting 
reduced forms, a C<O(|x|)> algorithm. See also C<hclassno> below.



=head2 X<compimag>compimagC<(x,y)>

composition of the binary quadratic forms
C<x> and C<y>. This is of course a special case of C<gmul(x,y)>. See also
C<nucomp> and C<nudupl>.

The library syntax is C<compimag(x,y)>.



=head2 X<comprealraw>comprealrawC<(x,y)>

composition of the binary quadratic
forms C<x> and C<y> with positive discriminant, without reduction of the
result. This is useful e.g. to compute a generating element of an
ideal.

The library syntax is C<comprealraw(x,y)>.



=head2 X<content>contentC<(x)>

computes the gcd of all the coefficients of C<x>,
when this gcd makes sense. If C<x> is a scalar, this simply gives C<x>. If
C<x> is a polynomial (and by extension a power series), it gives the usual
content of C<x>. If C<x> is a rational function, it gives the ratio of the
contents of the numerator and the denominator. Finally, if C<x> is a
vector or a matrix, it gives the gcd of all the entries.

The library syntax is C<content(x)>.



=head2 X<dirdiv>dirdivC<(x,y)>

C<x> and C<y> being vectors of perhaps different lengths
but with C<y[1]!= 0> considered as Dirichlet series, computes the quotient of C<x>
by C<y>, again as a vector.

The library syntax is C<dirdiv(x,y)>.



=head2 X<dirmul>dirmulC<(x,y)>

C<x> and C<y> being vectors of perhaps different lengths
considered as Dirichlet series, computes the product of C<x> by C<y>, again as a vector.

The library syntax is C<dirmul(x,y)>.



=head2 X<divisors>divisorsC<(x)>

creates a row vector whose components are the
positive divisors of the integer C<x> in increasing order.

The library syntax is C<divisors(x)>.



=head2 X<fact>factC<(x)> or C<x!>

factorial of C<x>. The expression C<x!>
gives a result which is an integer, while C<fact>C<(x)> gives a real
number.

The library syntax is C<mpfact(x)> for C<x!> and C<mpfactr(x,prec)>
for C<fact>C<(x)>. C<x> must be a C-long integer and not a PARI integer.



=head2 X<factcantor>factcantorC<(x,p)>

factorization mod C<p> of the polynomial
C<x> using distinct degree plus Cantor-Zassenhaus. The coefficients of C<x> 
must be operation-compatible with
C<B<I<Z>>/pB<I<Z>>>. The result is a two-column matrix, the first column being
the irreducible polynomials dividing C<x>, and the second the exponents. 
If you want only the I<degrees> of the irreducible polynomials 
(for example for computing an C<L>-function), use the function 
C<simplefactmod>. Note that the C<factmod> algorithm is usually faster
than C<factcantor>.

The library syntax is C<factcantor(x,p)>.



=head2 X<factfq>factfqC<(x,p,a)>

factorization in the field C<B<I<F>>_q> defined by
the irreducible polynomial C<a> over C<B<I<F>>_p> of the polynomial
C<x>. The coefficients of C<x> must be operation-compatible with C<B<I<Z>>/pB<I<Z>>>. The result is a two-column matrix, the first column being the irreducible
polynomials dividing C<x>, and the second the exponents. It is advised to use
for the variable of C<a> (which will be used as variable of a polymod), a
name distinct from the other variables used, so that a C<lift()> of the
result will be legible.

The library syntax is C<factmod9(x,p,a)>.



=head2 X<factmod>factmodC<(x,p)>

factorization mod C<p> of the polynomial
C<x> using Berlekamp. The coefficients of C<x> must
be operation-compatible with C<B<I<Z>>/pB<I<Z>>>. The result is a two-column 
matrix, the first column being the irreducible
polynomials dividing C<x>, and the second the exponents. If you want only the
I<degrees> of the irreducible polynomials (for example, for computing an
C<L>-function), use the function C<simplefactmod>. A different algorithm
for computing the mod C<p> factorization is C<factcantor> which is 
sometimes faster.

The library syntax is C<factmod(x,p)>.



=head2 X<factor>factorC<(x)>

general factorization function. If C<x> is
of type integer, rational, polynomial or rational function,
the result is a two-column matrix, the first column being the irreducibles
dividing C<x> (prime numbers or polynomials), and the second the exponents.
If C<x> is a vector or a matrix, the factoring is done componentwise (hence
the result is a vector or matrix of two-column matrices).

The polynomials or rational functions to be factored must have scalar
coefficients. In particular PARI does I<not> yet know how to factor
multivariate polynomials.

The library syntax is C<factor(x)>. See also C<X<factpol>factpol>,
C<X<factpol2>factpol2> and C<X<factornf>factornf>.



=head2 X<fibo>fiboC<(x)>

C<x^{th}> Fibonacci number.

The library syntax is C<fibo(x)>. C<x> must be a
C-long integer and not a PARI integer.



=head2 X<gcd>gcdC<(x,y)>

creates the greatest common divisor of C<x>
and C<y>. C<x> and C<y> can be of quite general types; for instance both
rational numbers. Vector/matrix types are also accepted, in which case
the GCD is taken recursively on each component. Note that for these
types, C<gcd> is not commutative.

The library syntax is C<ggcd(x,y)>.



=head2 X<hclassno>hclassnoC<(x)>

X<Hurwitz class number>Hurwitz class number of C<x>, where C<x> is
non-negative and congruent to 0 or 3 modulo 4. See also C<classno> above.

The library syntax is C<hclassno(x)>.



=head2 X<hilb>hilbC<(x,y,p)> or B<hilbp>C<(x,y)>

X<Hilbert symbol>Hilbert symbol of
C<x> and C<y>. If C<x> and C<y> are of type integer or fraction, the function
C<hilb> must be used with an explicit third parameter C<p>, C<p=0> meaning the place
at infinity. Otherwise, C<p> need not be given, and C<x> and C<y> can be of 
compatible types integer, fraction, real, integermod or C<p>-adic.

The library syntax is in both cases C<hil(x,y,p)> or
C<hil(x,y)>.



=head2 X<isfund>isfundC<(x)>

true (1) if C<x> is equal to 1 or to the
discriminant of a quadratic field, false (0) otherwise. Vector/matrix
arguments are also allowed in which case the function is applied to
each component.

The library syntax is C<gisfundamental(x)>, but the
simpler function C<isfundamental(x)> which returns a C-long
should be used if C<x> is known to be of type integer.



=head2 X<isprime>isprimeC<(x)>

true (1) if C<x> is a strong pseudo-prime
for 10 randomly chosen bases, false (0) otherwise. Vector/matrix
arguments are also allowed in which case the function is applied to
each component.

The library syntax is C<gisprime(x)>, but the
simpler function C<isprime(x)> which returns a C-long
should be used if C<x> is known to be of type integer.



=head2 X<ispsp>ispspC<(x)>

true (1) if C<x> is a strong 
pseudo-prime for a randomly chosen base, false (0) otherwise. Vector/matrix
arguments are also allowed in which case the function is applied to
each component.

The library syntax is C<gispsp(x)>, but the
simpler function C<ispsp(x)> which returns a C-long
should be used if C<x> is known to be of type integer.



=head2 X<isqrt>isqrtC<(x)>

integer square root of C<x>, which must be of PARI
type integer. The result is non-negative and rounded towards zero.
A negative C<x> is allowed, and the result in that case
is C<i*isqrt(-x)>. 

The library syntax is C<racine(x)>.



=head2 X<issqfree>issqfreeC<(x)>

true (1) if C<x> is squarefree, false if not.
Here C<x> can be an integer or a polynomial. Vector/matrix
arguments are also allowed in which case the function is applied to
each component.

The library syntax is C<gissquarefree(x)>, but the
simpler function C<issquarefree(x)> which returns a C-long
should be used if C<x> is known to be of type integer.



=head2 X<issquare>issquareC<(x)>

true (1) if C<x> is square, false if not. C<x>
can be of any type. For vector/matrix arguments the function is applied to
each component.

The library syntax is C<gcarreparfait(x)>. In the case where C<x> is
known to be of type integer, the function C<carrecomplet(x,&r)>
which returns a C-long should be used, since not only does it give the
answer (true or false), but in the case where C<x> is indeed a square, puts
the integer square root in C<r>.



=head2 X<kro>kroC<(x,y)>

Kronecker X<Legendre symbol>
(i.e. generalized Legendre) symbol C<(\dfrac{x}{y})>. C<x> and C<y>
must be of type integer and the result (C<0> or C<F<+-> 1>) is a C-long integer.

The library syntax is C<kronecker(x,y)>.



=head2 X<lcm>lcmC<(x,y)>

least common multiple of C<x> and C<y>, i.e.
such that C<lcm(x,y)*gcd(x,y)=abs(x*y)>.

The library syntax is C<glcm(x,y)>.



=head2 X<mu>muC<(x)>

M\"obius C<F<mu>>-function of C<x>. C<x> must be of
type integer and the result (C<0> or C<F<+-> 1>) is a C-long integer.

The library syntax is C<mu(x)>.



=head2 X<nextprime>nextprimeC<(x)>

finds the smallest prime greater than or
equal to C<x>. C<x> must be of type integer.

The library syntax is C<bigprem(x)>.



=head2 X<nucomp>nucompC<(x,y,l)>

composition of the primitive positive definite
binary quadratic forms C<x> and C<y> using the NUCOMP and NUDUPL algorithms
of Shanks (\`a la Atkin). C<l> is any positive constant, but for optimal
speed, one should take C<l=|D|^{1/4}>, where C<D> is the common 
discriminant of C<x> and C<y>.

The library syntax is C<nucomp(x,y,l)>. The auxiliary function
C<nudupl(x,l)> should be used instead for speed when C<x=y>.



=head2 X<numdiv>numdivC<(x)>

number of divisors of C<x>. C<x> must be of type
integer, and the result is a C-long integer.

The library syntax is C<numbdiv(x)>.



=head2 X<nupow>nupowC<(x,n)>

C<n>-th power of the primitive positive definite
binary quadratic form C<x> using the NUCOMP and NUDUPL algorithms (see
C<nucomp> above).

The library syntax is C<nupow(x,n)>.



=head2 X<omega>omegaC<(x)>

number of distinct prime
divisors of C<x>. C<x> must be of type integer, and the result is a C-long 
integer.

The library syntax is C<omega(x)>.



=head2 X<order>orderC<(x)>

C<x> must be an integer mod C<n>, and the result
is the order of C<x> in the multiplicative group C<(B<I<Z>>/nB<I<Z>>)^*>. Error if
C<x> is not invertible.

The library syntax is C<order(x)>.



=head2 X<pf>pfC<(x,p)>

prime binary quadratic form of discriminant C<x>
whose first coefficient is the prime number C<p>. Error if C<x> is not a
quadratic residue mod C<p>. In the case where C<xE<gt>0>, the ``distance''
component of the form is set equal to zero according to the current precision.

The library syntax is C<primeform(x,p,prec)>, where the third
variable C<prec> is a C-long integer, but is necessary only when C<xE<gt>0>.



=head2 X<phi>phiC<(x)>

Euler's C<F<phi>>-function of C<x>. C<x> must be of
type integer.

The library syntax is C<phi(x)>.



=head2 X<pnqn>pnqnC<(x)>

When C<x> is a vector or a one-row matrix, C<x> is 
considered as the list of partial quotients C<[a_0,a_1,...,a_n]> of a rational
number, and the result is the 2 by 2 matrix C<[p_n,p_{n-1};q_n,q_{n-1}]> in the
standard notation of continued fractions, so
C<p_n/q_n=a_0+1/(a_1+...+1/a_n)...)>. If C<x> is a matrix with two rows
C<[b_0,b_1,...,b_n]> and C<[a_0,a_1,...,a_n]>,
this is then considered as a generalized continued fraction and we have
similarly C<p_n/q_n=1/b_0(a_0+b_1/(a_1+...+b_n/a_n)...)>. Note that in this
case one usually has C<b_0=1>.

The library syntax is C<pnqn(x)>.



=head2 X<powrealraw>powrealrawC<(x,n)>

C<n>-th power of the binary quadratic
form C<x> of positive discriminant, computed without doing any
reduction (i.e. using C<comprealraw> above). Here C<n> must be non-negative
and C<n<2^{31}>.

The library syntax is C<powrealraw(x,n)> where C<n> must be a C-long integer.



=head2 X<prime>primeC<(x)>

the C<x^{th}> prime number. 

The library syntax is C<prime(x)>. C<x> must be a C-long integer.



=head2 X<primes>primesC<(x)>

creates a row vector whose components
are the first C<x> prime numbers. 

The library syntax is C<primes(x)>. C<x> must be a C-long integer.



=head2 X<primroot>primrootC<(x)>

returns a primitive root of C<x>, where C<x>
is a prime power.

The library syntax is C<gener(x)>.



=head2 X<qfi>qfiC<(a,b,c)>

creates the binary quadratic form C<ax^2+bxy+cy^2>
with C<b^2-4ac<0>.

The library syntax is C<qfi(a,b,c)>.
X<Binary quadratic form>



=head2 X<qfr>qfrC<(a,b,c,d)>

creates the binary quadratic form C<ax^2+bxy+cy^2>
with C<b^2-4acE<gt>0> and distance function C<d>.

The library syntax is C<qfr(a,b,c,d)>.



=head2 X<quaddisc>quaddiscC<(x)>

discriminant of the quadratic field 
C<B<I<Q>>( F<sqrt> x)>, where C<x\inB<I<Q>>>. Up to trivial 2-factors, this function
can also be used to compute the squarefree part of C<x>.

The library syntax is C<quaddisc(x)>.



=head2 X<redimag>redimagC<(x)>

reduce the binary quadratic form C<x> with negative
discriminant.

The library syntax is C<redimag(x)>.



=head2 X<redreal>redrealC<(x)>

reduce the binary quadratic form C<x> with positive
discriminant.

The library syntax is C<redreal(x)>.



=head2 X<redrealnod>redrealnodC<(x,sq)>

reduce the binary quadratic form C<x> with
positive discriminant C<D> without computing the distance function, where
C<sq> is the integer square root of C<D> (no checking is done of this fact).

The library syntax is C<redrealnod(x,sq)>.



=head2 X<regula>regulaC<(x)>

regulator of the quadratic field of positive 
discriminant C<x>. Error if C<x> is not a discriminant (fundamental or not) or
if C<x> is a square. See also C<buchreal> if C<x> is large.

The library syntax is C<regula(x,prec)>.



=head2 X<rhoreal>rhorealC<(x)>

perform one reduction step on the binary quadratic
form C<x> with positive discriminant.

The library syntax is C<rhoreal(x)>.



=head2 X<rhorealnod>rhorealnodC<(x,sq)>

perform one reduction step on the binary
quadratic form C<x> with positive discriminant C<D> without computing the
distance function, where C<sq> is the integer square root of C<D> (no checking
is done of this fact).

The library syntax is C<rhorealnod(x,sq)>.



=head2 X<sigma>sigmaC<(x)>

sum of the positive divisors of C<x>. C<x> must
be of type integer.

The library syntax is C<sumdiv(x)>.



=head2 X<sigmak>sigmakC<(k,x)>

sum of the C<k^{th}> powers of the
positive divisors of C<x>. C<x> must be of type integer, but (in library mode)
C<k> must be a C-long integer.

The library syntax is C<sumdivk(k,x)>.



=head2 X<simplefactmod>simplefactmodC<(x,p)>

factorization mod C<p> of the polynomial
C<x>. The coefficients of C<x> must be operation-compatible with C<B<I<Z>>/pB<I<Z>>>. The result is a two-column matrix, the first column being the degrees of
the irreducible polynomials dividing C<x>, and the second the exponents. If 
you want the irreducible polynomials themselves, use the function
C<factmod>.

The library syntax is C<simplefactmod(x,p)>.



=head2 X<smallfact>smallfactC<(x)>

For integer C<x>, finds only the prime factors
up to the default table created when GP was started (usually C<500000>). The 
remaining part is hence not necessarily prime. This never takes more than a few
seconds, and is particularly advantageous with respect to C<factor> when
one needs only the small prime divisors and not the complete factorization.

The library syntax is C<smallfact(x)>.



=head2 X<unit>unitC<(x)>

X<fundamental unit>fundamental unit of the real quadratic field
C<B<I<Q>>( F<sqrt>  x)> where  C<x> is the positive discriminant of the field.
If C<x> is not a fundamental discriminant, this
probably gives the fundamental unit of the corresponding order.
C<x> must be of type integer, and the result is a quadratic number.

The library syntax is C<fundunit(x)>.



=head2 X<znstar>znstarC<(n)>

gives the structure of the multiplicative group 
C<(B<I<Z>>/nB<I<Z>>)^*> as a 3-component row vector C<v>, where C<v[1]=F<phi>(n)> is the
order of that group, C<v[2]> is a C<k>-component row-vector C<d> of integers
C<d[i]> such that C<d[i]E<gt>1> and C<d[i] |  d[i-1]> for C<iE<gt>=2> and
C<(B<I<Z>>/nB<I<Z>>)^* ~ \prod_{i=1}^k(B<I<Z>>/d[i]B<I<Z>>)>, and C<v[3]> is a C<k>-component
row vector giving generators of the image of the cyclic groups 
C<B<I<Z>>/d[i]B<I<Z>>>.

The library syntax is C<znstar(n)>.



=head1 Functions related to elliptic curves.



We have implemented a number of functions which are useful for number
theorists working on elliptic curves. We always use Tate's notations.

The functions assume that the curve is given by a general Weierstrass model

C<y^2+a_1xy+a_3y=x^3+a_2x^2+a_4x+a_6,>

where a priori the C<a_i> can be of any scalar type. This curve can be 
considered as a five component vector C<e=[a1,a2,a3,a4,a6]>, but
for most functions it is useful to have at one's disposal more
information. This is given either by the function C<initell> (see below),
which gives a 19 component vector (which we will call a long vector in this
section), or by the faster function C<smallinitell>
which gives a 13 component vector (which we will call a medium vector), all 
these vectors starting in the same way.
Consequently, in functions which do not use the extra information given
by C<initell>, the curve can be given either as a five component
vector, or by one of the longer vectors computed by C<initell> or
C<smallinitell>.

Other functions, in particular those relative to height computations
(see C<hell> below) require also that the curve be in minimal
Weierstrass form. This is achieved by the function C<globalred>
below.

Points on elliptic curves are represented as two-component vectors
C<[x,y]>, except for the point at infinity, i.e. the identity element
of the group law, represented by the one-component vector C<[0]>.



=head2 X<addell>addellC<(e,z1,z2)>

sum of the points C<z1> and C<z2> on the
elliptic curve corresponding to the vector C<e>.

The library syntax is C<addell(e,z1,z2)>.



=head2 X<akell>akellC<(e,n)>

compute the coefficient C<a_n> of the C<L>-function
of the elliptic curve C<e>, i.e. in principle coefficients of
a newform of weight 2 assuming Taniyama-Weil. C<e> must be a medium or long
vector of the type given by C<smallinitell> or C<initell>. For this
function to work for every C<n> and not just those prime to the conductor,
C<e> must be a minimal Weierstrass equation. If this is not the case,
use the function C<globalred> first before using C<akell>.

The library syntax is C<akell(e,n)>.



=head2 X<anell>anellC<(e,n)>

compute the vector of the first C<n> C<a_k>
corresponding to the elliptic curve C<e>, i.e. in principle coefficients of
a newform of weight 2 assuming Taniyama-Weil. C<e> must be a medium or long
vector of the type given by C<smallinitell> or C<initell>. For this
function to work for every C<n> and not just those prime to the conductor,
C<e> must be a minimal Weierstrass equation. If this is not the case,
use the function C<globalred> first before using C<anell>.

The library syntax is C<anell(e,n)>, where C<n> is a C integer.



=head2 X<apell>apellC<(e,p)>

compute the C<a_p> corresponding to the
elliptic curve C<e> and the prime number C<p>, using the baby-step giant-step
method and a trick due to Mestre. No checking is done that
C<p> is indeed prime. The number of points of C<e> over C<B<I<F>>_p> is
C<p+1-a_p>. C<e> must be a medium or long vector of the type given by 
C<smallinitell> or C<initell>.

The library syntax is C<apell(e,p)>.



=head2 X<apell2>apell2C<(e,p)>

compute the C<a_p> corresponding to the
elliptic curve C<e> and the prime number C<p> as a sum of Legendre symbols.
This is slower than C<apell> as soon as C<p> is greater than 100, say.
C<e> must be a medium or long vector of the type given by C<smallinitell>
or C<initell>.

The library syntax is C<apell2(e,p)>.



=head2 X<bilhell>bilhellC<(e,z1,z2)>

If C<z1> and C<z2> are points on the elliptic
curve C<e>, this function computes the value of the canonical bilinear form
on C<z1>, C<z2>, i.e. C<hell(e,z1C<+>z2)-hell(e,z1)-hell(e,z2)>, where C<+>
denotes of course addition on C<e>. In addition, C<z1> or C<z2> (but not both)
can be vectors or matrices.

The library syntax is C<bilhell(e,z1,z2,prec)>.



=head2 X<chell>chellC<(e,v)>

change the data for the elliptic curve C<e>
by changing the coordinates using the vector C<v=[u,r,s,t]>, i.e.
if C<x'> and C<y'> are the new coordinates, then C<x=u^2x'+r>, 
C<y=u^3y'+su^2x'+t>. The vector C<e> must be a medium or long vector of the type
given by C<smallinitell> or C<initell>.

The library syntax is C<coordch(e,v)>.



=head2 X<chptell>chptellC<(x,v)>

change the coordinates of the point or vector of
points C<x> using the vector C<v=[u,r,s,t]>, i.e.
if C<x'> and C<y'> are the new coordinates, then C<x=u^2x'+r>, 
C<y=u^3y'+su^2x'+t> (see also C<chell> above).

The library syntax is C<pointch(x,v)>.



=head2 X<globalred>globalredC<(e)>

calculate the arithmetic conductor, the global
minimal model of C<e> and the global Tamagawa number C<c>. Here C<e> is an 
elliptic curve given by a medium or long vector of the type given by 
C<smallinitell> or C<initell>, and is supposed to have all its
coefficients C<a_i> in C<B<I<Q>>>. The result is a 3 component vector C<[N,v,c]>.
C<N> is the arithmetic conductor of the curve, C<v> is itself a vector 
C<[u,r,s,t]> with rational components. It gives a coordinate change for C<e> 
over C<B<I<Q>>> such that the resulting model has integral coefficients, is 
everywhere minimal, C<a_1> is 0 or 1, C<a_2> is 0, 1 or C<-1> and C<a_3> is 0 
or 1. Such a model is unique, and the vector C<v> is unique if we specify that
C<u> is positive. To get the new model, simply type C<chell(e,v)>.
Finally C<c> is the product of the local Tamagawa numbers C<c_p>, which is a
quantity which enters in the Birch and Swinnerton-Dyer conjecture.

The library syntax is  C<globalreduction(e)>.



=head2 X<hell>hellC<(e,z)>

global X<N\'eron-Tate height>N\'eron-Tate height of the
point C<z> on the elliptic curve C<e>. The vector C<e> must be a long vector
of the type given by C<initell>. This computation is done using sigma and 
theta-functions and a trick due to J. Silverman.

The library syntax is C<ghell(e,z,prec)>. The archimedean contribution
alone is given by the library function C<hell(e,z,prec)>. 



=head2 X<hell2>hell2C<(e,z)>

same as C<hell>, except that the algorithm used
is Tate's C<4^n> algorithm, and is much slower. 

The library syntax is C<ghell2(e,z,prec)>.



=head2 X<initell>initellC<(e)>

compute some fixed data concerning the elliptic
curve given by the five component vector C<e>, which will be essential for
most further computations on the curve. The result is a 19-component
vector E (called a long vector in this section), containing the following
information:

The first 13 components contain

C<a_1,a_2,a_3,a_4,a_6,b_2,b_4,b_6,b_8,c_4,c_6,F<Delta>,j.>

In particular, the discriminant is C<E[12]>, and the C<j>-invariant is
C<E[13]>. 

For the other six components, their content depends on whether the curve
is defined over C<B<I<R>>> or not.



When C<e> is defined over C<B<I<R>>>, C<E[14]> is a vector with three
components containing the roots of the associated Weierstrass equation.
If the roots are all real, then they are ordered by decreasing value.
If only one is real, it is the first component of C<E[14]>.

C<E[15]> is the real period of C<E> (integral of C<dx/(2y+a_1x+a_3)> over the
connected component of the identity element of the real points of the
curve), and C<E[16]> is a complex period. In other words, C<F<omega>_1=E[15]>
and C<F<omega>_2=E[16]> form a basis of the complex lattice defining C<e>,
with C<F<tau>=\dfrac{F<omega>_2}{F<omega>_1}> having positive imaginary part.

C<E[17]> and C<E[18]> are the corresponding values C<F<eta>_1> and C<F<eta>_2>
such that C<F<eta>_1F<omega>_2-F<eta>_2F<omega>_1=iF<pi>>.

Finally, C<E[19]> is the volume of the complex lattice defining C<e>.



When C<e> is defined over C<B<I<Q>>_p>, the C<p>-adic valuation of C<j> must
be negative. Then C<E[14]> is the vector with a single
component equal to the C<p>-adic root of the associated Weierstrass
equation corresponding to C<-1> under the Tate parametrization.

C<E[15]> is equal to the square of the C<u>-value, in the notation of Tate.

C<E[16]> is the C<u>-value itself, if it belongs to C<B<I<Q>>_p>, otherwise zero.

C<E[17]> is the value of Tate's C<q> for the curve C<e>.

C<E[18]> is the value of Mestre's C<w> (this is technical), and
C<E[19]> is arbitrarily set equal to zero.



For all other base fields or rings, the last six components are
arbitrarily set equal to zero.

Note: temporarily, an older version of C<initell> called 
C<initell2> is installed, but will disappear in the near future.

The library syntax is C<initell(e,prec)>.



=head2 X<isoncurve>isoncurveC<(e,z)>

gives 1 (i.e. true) if the point C<z> is on the
elliptic curve C<e>, 0 otherwise. Here C<e> can be a five-component vector or
a long vector.

The library syntax is C<oncurve(e,z)>, and the result is a
C-long integer.



=head2 X<localred>localredC<(e,p)>

calculate the Kodaira type of the local
fiber of the elliptic curve C<e> at the prime C<p>. C<e> must be given by a
medium or long vector of the type given by C<smallinitell> or
C<initell>, and is assumed to have all its coefficients C<a_i> in 
C<B<I<Z>>>. The result is a 4-component vector C<[f,kod,v,c]>. Here C<f> is
the exponent of C<p> in the arithmetic conductor of C<e>, C<kod> is the 
Kodaira type which is coded as follows:

1 means good reduction (type IC<_0>), 2, 3 and 4 mean types II, III and IV 
respectively, C<4+F<nu>> with C<F<nu>E<gt>0> means type IC<_F<nu>>;
finally the opposite values C<-1>, C<-2>, etc. refer to the starred types 
IC<_0^*>, IIC<^*>, etc. The third component C<v> is itself a vector C<[u,r,s,t]>
giving the coordinate changes done during the local reduction. Normally, this
has no use if C<u> is 1, that is, if the given equation was already minimal.
Finally, the last component C<c> is the local Tamagawa number C<c_p>.

The library syntax is C<localreduction(e,p)>.



=head2 X<lseriesell>lseriesellC<(e,s,N,A)>

C<e> being a medium or long vector given by
C<smallinitell> or C<initell>, this computes the value of the L-series
of C<e> at C<s>. It is assumed that C<e> is a minimal model over C<B<I<Z>>>,
C<N> is equal to plus or minus the conductor depending on the sign of the
functional equation, that the curve is a Weil curve, and C<A> is a cutoff point
for the integral, which must be chosen close to 1 for best speed. The result
being independent of C<A>, this function can be used to compute the sign
of the functional equation, and even C<N> if one wants, although it is always
much faster to apply the function C<globalred>. 

Note that in the present version 1.39.3, this function is accessible externally
in GP, but in future versions it may only be accessible in library mode
since it will be superseded.

Note also that if the conductor of the curve is large, say greater than 
C<10^{12}>, this function will take an unreasonable amount of time since it uses
a C<O(N^{1/2})> algoorithm.

The library syntax is C<lseriesell(e,s,N,A,prec)> where C<prec> is a
C-long integer.



=head2 X<mathell>mathellC<(e,x)>

C<x> being a vector of points, this
function outputs the Gram matrix of C<x> with respect to the N\'eron-Tate
height, in other words, the C<(i,j)> component of the matrix is
equal to C<hell(e,x[i]+x[j])-hell(e,x[i])-hell(e,x[j])>, where
C<x[i]+x[j]> denotes of course the sum of the points on the curve C<e>.
The rank of this matrix, at least in some approximate sense, gives the
rank of the set of points, and if C<x> is a basis of the Mordell-Weil
group of C<e>, its determinant is equal to the regulator of C<e>.

The library syntax is C<mathell(e,x,prec)>.



=head2 X<ordell>ordellC<(e,x)>

gives a 0, 1 or 2-component vector containing
the C<y>-coordinates of the points of the curve C<e> having C<x> as 
C<x>-coordinate.

The library syntax is C<ordell(e,x)>.



=head2 X<orderell>orderellC<(e,z)>

gives the order of the point C<z> on the elliptic
curve C<e> if it is a torsion point, zero otherwise. In the present 
version 1.39.3{}, this is implemented only for elliptic curves defined over
C<B<I<Q>>>.

The library syntax is C<orderell(e,z)>, and the result is a GEN.



=head2 X<pointell>pointellC<(e,z)>

C<e> being a long vector, computes the coordinates
C<[x,y]> on the curve C<e> corresponding to the complex number C<z>. Hence this is
the inverse function of C<zell>. In other words, if the curve is put in 
Weierstrass form, C<[x,y]> represent the Weierstrass C<\wp>-function and its
derivative. If C<z> is in the lattice defining C<e> over C<B<I<C>>>, the result is
the point at infinity C<[0]>.

The library syntax is C<pointell(e,z,prec)>.



=head2 X<powell>powellC<(e,z,n)>

computes C<n> times the point C<z> for the
group law on the elliptic curve C<e>. Here C<n> is in C<B<I<Z>>>.

The library syntax is C<powell(e,z,n)>.



=head2 X<smallinitell>smallinitellC<(e)>

compute some fixed data concerning the elliptic
curve given by the five component vector C<e>, which may be useful for
further computations on the curve. The result is a 13-component
vector E (called a medium vector in this section), containing the first 13
components of the vector given by C<initell>, in other words the vector

C<[a_1,a_2,a_3,a_4,a_6,b_2,b_4,b_6,b_8,c_4,c_6,F<Delta>,j].>

In particular, the discriminant is C<E[12]>, and the C<j>-invariant is
C<E[13]>. 

The library syntax is C<smallinitell(e)>.



=head2 X<subell>subellC<(e,z1,z2)>

difference of the points C<z1> and C<z2> on the
elliptic curve corresponding to the vector C<e>.

The library syntax is C<subell(e,z1,z2)>.



=head2 X<taniyama>taniyamaC<(e)>

computes the modular parametrization of the elliptic
curve C<e> (where C<e> is given in the format output by C<initell> or
C<smallinitell>), in the form of a two-component vector C<[u,v]> of power 
series, given to the current default series precision. This vector is
characterized by the following two properties. First the point C<(x,y)=(u,v)>
satisfies the equation of the elliptic curve. Second, the differential
C<du/(2v+a_1u+a_3)> is equal to C<f(z)dz>, a differential form on C<H/F<Gamma>_0(N)>
where C<N> is the conductor of the curve. The variable used in the power series
for C<u> and C<v> is C<x>, which is implicitly understood to be equal to
C< F<exp> (2iF<pi> z)>. It is assumed that the curve is a I<strong> Weil curve,
and the Manin constant is equal to 1. The equation of the curve C<e> must be 
minimal (use C<globalred> to get a minimal equation).

The library syntax is C<taniyama(e)>, and the precision of the result
is determined by the global variable C<precdl>.



=head2 X<torsell>torsellC<(e)>

If C<e> is an elliptic curve defined over C<B<I<Q>>>,
this outputs the torsion subgroup of C<e> as a 3-component vector 
C<[t,v1,v2]> with the following meaning. C<t> is the order of the
torsion group. C<v1> is a 0, 1 or 2-component vector giving the structure
of the torsion group as a product of cyclic groups, with C<v1[2]=2> if it
exists. Finally C<v2>, which is a vector of the same length as C<v1>,
gives generators for these cyclic groups. C<e> must be a vector as output by
C<initell> or C<smallinitell>.

The library syntax is C<torsell(e)>.



=head2 X<zell>zellC<(e,z)>

If C<e> is an elliptic curve with coefficients in
C<B<I<R>>>, this computes a complex number C<t> (modulo the lattice defining C<e>)
corresponding to the point C<z>, i.e. such that, in the standard Weierstrass
model, C<\wp(t)=z[1],\wp'(t)=z[2]>. In other words, this is the inverse function
of C<pointell>.

If C<e> has coefficients in C<B<I<Q>>_p>, then either Tate's C<u> is in C<B<I<Q>>_p>,
in which case the output is a C<p>-adic number C<t> corresponding to the point
C<z> under the Tate parametrization, or only its square is, in which case
the output is C<t+1/t>. C<e> must be a long vector of the type given by
C<initell>.

The library syntax is C<zell(e,z,prec)>.



=head1 Functions related to general number fields.



In this section can be found functions which are used almost exclusively
for working in general number fields. Other less specific functions can be
found in the next section on polynomials. Functions related to quadratic 
number fields can be found in section 3.4 above.

In this section, C<nf> will always denote a number field, i.e. a 9-component
vector in the format output by C<initalg> or C<initalgred>. An
I<ideal> (usually C<x> or C<y>) will mean the following:

C<x> can be a C<B<I<Z>>>-basis, in Hermite Normal Form (HNF) or not. In this case
C<x> is a square matrix.

C<x> can be an I<idele>, i.e. a 2-component vector, the first being an
ideal given as a C<B<I<Z>>>-basis, the second being a C<r_1+r_2>-component row vector
giving the complex logarithmic archimedean information.

C<x> can be a C<B<I<Z>>_K>-generating system for an ideal.

C<x> can be a C<column> vector expressing an element of the number
field on the integral basis, in which case C<x> is treated as being
the principal idele (or ideal) generated by C<x>.

C<x> can be a prime ideal, i.e. a 5-component vector in the format output
by C<primedec>.

C<x> can be a polymod, i.e. an algebraic integer, in which case C<x> is treated
as being the principal idele generated by C<x>.

Finally, C<x> can be an integer or a rational number, also treated as a
principal idele.

B<Warnings.>

1) An element in C<nf> can be expressed either as a
polymod or as a vector of components on the integral basis C<nf[7]>. It
is absolutely essential that all such vectors be I<column> vectors.

2) When giving an ideal by a C<B<I<Z>>_K> generating system to a function 
expecting an ideal, it must be ensured that the function understands 
that it is a C<B<I<Z>>_K>-generating system and not a C<B<I<Z>>>-generating system.
When the number of generators is strictly less than the degree of the
field, there is no ambiguity and the program assumes that one is
giving a C<B<I<Z>>_K>-generating set. When the number of generators is greater
than or equal to the degree of the field, however, the program assumes
on the contrary that you are giving a C<B<I<Z>>>-generating set. If this is
not the case, you I<must> absolutely change it into a C<B<I<Z>>>-generating
set, the simplest manner being to use C<idealmul(nf,x,idmat(N))>
where C<N> is the degree of the field.

B<Remark.> Starting with version 1.38.9, we include a number of 
programs for working in I<relative> extensions of number fields. To
our knowlege, this is the first existing implementation of such 
functions, and is being written up for publication. This has two 
consequences. First, the functions are provided for help in research,
but their results must be considered with caution. Second, as an
elementary courtesy to us, we ask you not to publish anything which
uses these functions in an essential way, without sending us e-mail
about it. Of course, when our paper(s) are published the above will
become irrelevant.

Concerning relative extensions, some definitions are necessary. 
A I<relative matrix> will be a matrix whose entries are elements
of a (given) number field C<nf>, always expressed as column vectors on
the integral basis C<nf[7]>. Hence it is a matrix of vectors.

An I<ideal list> will be a row vector of (fractional) ideals of the
number field C<nf>.

A I<pseudo-matrix> will be a pair C<(A,I)> where C<A> is a relative
matrix and C<I> an ideal list whose length is the same as the number of
columns of C<A>. This pair will be represented by a 2-component row vector.

The I<module> generated by a pseudo-matrix C<(A,I)> is the sum
C<\sum_i\a_jA_j> where the C<\a_j> are the ideals of C<I> and C<A_j> is the
C<j>-th column of C<A>.

A pseudo-matrix C<(A,I)> is a I<pseudo-basis> of the module it
generates if C<A> is a square matrix with non-zero determinant and all
the ideals of C<I> are non-zero. We say that it is in Hermite Normal
Form (HNF) if it is upper triangular and all the elements of the
diagonal are equal to 1.

The I<determinant> of a pseudo-basis C<(A,I)> is the ideal
equal to the product of the determinant of C<A> by all the ideals of C<I>.
The determinant of a pseudo-matrix is the determinant of any pseudo-basis
of the module it generates.

Finally, when defining a relative extension, the base field should be
defined by a variable having a lower priority (i.e. a higher number)
than the variable defining the extension. For example, under GP you can
use the variable name C<y> (or C<t>) to define the base field, and the
variable name C<x> to define the relative extension.

All the functions which are specific to relative extensions (name 
beginning with C<rnf>) take as first argument either a number field
as output by C<initalg> or C<initalgred>, or a big number field
as output by C<buchinit> or C<buchinitfu>. Although not specified
in the descriptions of the functions below, it is permissible, if the
function expects a number field, to use a big number field instead.
The program will make the effort of converting to what it needs. On the
other hand, if the program requires a big number field, the program
will I<not> launch C<buchinit> for you, which can be a costly
operation, but give you a specific error message telling you that
you should use C<buchinit>.





=head2 X<algtobasis>algtobasisC<(nf,x)>

this is the inverse function of
C<basistoalg>. Given an object C<x> whose entries are expressed
as algebraic numbers in the number field C<nf>, transforms it so
that the entries are expressed on the integral basis C<nf[7]>.

The library syntax is C<algtobasis(nf,x)>.



=head2 X<basis>basisC<(x)>

X<integral basis>integral basis of the number field defined by
the monic irreducible polynomial C<x>, using the round 4 algorithm.
For small degrees and coefficient size, C<basis2> is sometimes
a little faster. For larger degrees, C<basis> is much faster.

This program is the translation in C by Pascal Letard of a program written 
by David Ford in Maple. If only a local integral basis is desired, use 
C<factoredbasis>.

The library syntax is C<base(x,&d)>, where C<d> will receive the
discriminant of the number field (I<not> of the polynomial C<x>).



=head2 X<basis2>basis2C<(x)>

integral basis of the number field defined by
the monic irreducible polynomial C<x>, using the round 2 algorithm.
This program is the translation in C of a program written 
by David Ford in Algeb. 

The library syntax is C<base2(x,&d)>, where C<d> will receive the
discriminant of the number field (I<not> of the polynomial C<x>).



=head2 X<basistoalg>basistoalgC<(nf,x)>

this is the inverse function of 
C<algtobasis>. Given an object C<x> whose entries
are expressed on the integral basis C<nf[7]>, transforms it into
an object whose entries are algebraic numbers (i.e. polymods).

The library syntax is C<basistoalg(nf,x)>.



The following functions starting with ``C<buch>'' are implementations
of the sub-exponential algorithms for finding class and unit groups
under the GRH, due to Hafner-McCurley, Buchmann and Cohen-Diaz-Olivier.

B<Note that this is a completely experimental program which is constantly
being improved>.

The general library call to the functions concerning general number fields
(i.e. excluding C<buchimag> and C<buchreal>) is

C<buchall(P,c,c2,nrel,borne,nrpid,minsfb,flun,prec)>

where the parameters are to be understood as follows. 

C<P> is the defining polynomial for the number field, which must be in C<B<I<Z>>[X]>,
irreducible and monic.

The numbers C<c> and C<c2> are positive real numbers which control
the execution time and the stack size. To get maximum 
speed, set C<c2=c>. To get a rigorous result (under the GRH) you must take
C<c2=12> (or C<c2=6> in the quadratic case, but then you should use the much 
faster functions C<buchimag> and C<buchreal> below).
Reasonable values for C<c> are between C<0.1> and C<2>. 
(Default values C<c=c2=0.3>).

C<nrel> is the number of initial extra relations requested in computing the
relation matrix. Reasonable values are between 5 and 20. (Default value is 5).

C<borne> is a multiplicative coefficient of the Minkowski bound which
controls the search for small norm relations. If this parameter is set 
equal to 0, the program does not search for small norm relations. Otherwise
reasonable values are between C<0.5> and C<2.0>. (Default value is 0).

C<nrpid> is the maximal number of small norm relations associated to each
ideal in the factor base. Irrelevant when C<borne=0>. Otherwise, reasonable
values are between 4 and 20. (Default value is 4).

C<minsfb> is the minimal number of elements in the ``sub-factorbase''.
If the program does not seem to succeed in finding a full rank matrix
(which you can see in GP by typing C<\bs g 2>), increase this number.
Reasonable values are between 2 and 5. (Default value is 3).

C<flun> corresponds to the requested function (see below) and is a C long:
C<-3> for C<buchinitforcefu>, C<-2> for C<buchinitfu>, C<-1> for 
C<buchinit>, C<0> for C<buchgen>, C<2> for C<buchgenfu>, C<3> for
C<buchgenforcefu>.

Finally, as usual, C<prec> is the default precision, as a C long.
Note that the internal precision as well as the output precision may well
be much higher than C<prec>.

B<Remark.>

Under GP, apart from the polynomial C<P>, only part of the parameters can be
given. However, they I<must> be given in the requested order. For example,
if you want to specify a given value of C<nrel>, you must give some values
for C<c> and C<c2>. 



=head2 X<buchgen>buchgenC<(P,...)>

identical to C<buchgenfu> (see below)
except that the fundamental units and roots of unity are not computed.
Hence the result has only 7 components. See the remark preceding the
description of C<buchgen> for the other parameters.

The library syntax is either C<buchgen(P,c,c2,prec)> or
C<buchall(P,c,c2,nrel,borne,nbpid,minsfb,0,prec)> (see above).



=head2 X<buchgenforcefu>buchgenforcefuC<(P,...)>

identical to C<buchgenfu> (see
below), except that when the precision is insufficient for obtaining
the fundamental units exactly, the internal precision is doubled and
the computation redone, until the exact results are obtained. The user
should be warned that this can take a very long time when the coefficients
of the fundamental units on the integral basis are very large, for 
example in the case of large real quadratic fields. In that case, there
are alternate methods for representing algeberaic numbers which are
not implemented in Pari.

The library syntax is
C<buchall(P,c,c2,nrel,borne,nbpid,minsfb,3,prec)> (see above).



=head2 X<buchgenfu>buchgenfuC<(P,...)>

Buchmann's sub-exponential algorithm for
computing the class group, the regulator and a system of fundamental units of
the general algebraic number field C<K> defined by the irreducible monic 
polynomial C<P> with integer coefficients. See the remark preceding the
description of C<buchgen> for the other parameters.

The result of this function is a vector C<v> with 10 components, which for
ease of presentation is in fact output as a one column matrix. C<v[1]> is 
equal to the polynomial C<P>. Note that for optimum performance, C<P> should
have gone through C<polred> or C<initalgred>. C<v[2]> is the 2-component
vector C<[r1,r2]> (where C<r1> and C<r2> are as usual the number of real and 
half the number of complex embeddings of the number field C<K>). C<v[3]> is the
2-component vector containing the field discriminant and the index, C<v[4]> is
an integral basis in Hermite normal form. C<v[5]> is a 3-component vector
containing the class number, the structure of the class group as a product
of cyclic groups of order C<n_i>, and the corresponding generators of the
class group of respective orders C<n_i>. C<v[6]> is the regulator computed to
an accuracy which is the maximum of an internally determined accuracy and 
of the default. C<v[7]> is a measure of the correctness of the result. If it
is close to 1, the results are correct (under GRH). If it is close to a 
larger integer, this shows that
the product of the class number by the regulator is off by a factor equal to 
this integer, and you must start again with a larger value for C<c>
or a different random seed (i.e. use the function C<setrand()>.
(Since the computation involves a random process,
starting again with exactly the same parameters may give the correct result.)
In this case a warning message is printed. C<v[8]> a vector with 2 components,
the first being the number C<w> of roots of unity in C<K> and the second a 
primitive C<w>-th root of unity expressed as a polynomial.
C<v[9]> is a system of fundamental units also expressed as polynomials.
Finally, C<v[10]> gives a measure of the correctness of the computations of
the fundamental units (not of the regulator), expressed as a number of bits.
If this number is greater than C<20>, say, everything is OK. If C<v[10]E<lt>=0>,
then we have lost all accuracy in computing the units (usually an error
message will be printed and the units not given). In the intermediate
cases, one must proceed with caution (for example by increasing the current
precision).

Note: some installations may have this function disabled.

The library syntax is C<buchgenfu(P,c,c2,prec)> or
C<buchall(P,c,c2,nrel,borne,nbpid,minsfb,2,prec)> (see above).



=head2 X<buchinit>buchinitC<(P,...)>

essentially identical to C<buchgen> 
except that the output is much longer, and should not be printed out explicitly
in general. The result of buchinit is used in programs such as 
C<isprincipal>, C<isprincipalgen>, C<isunit> or C<buchnarrow>.
The result is an 8-component vector C<v>, 
whose first 6 components are technical and in principle are not used by the
casual user. However, for the sake of completeness, their description is as
follows. We use the notations explained in the book by H. Cohen, I<A  
Course in Computational Algebraic Number Theory>, Graduate Texts in Maths
B<138>, Springer-Verlag, 1993, Section 6.5, and pages 354 and 355 in 
particular.

C<v[1]> contains the matrix C<W> (C<mit> in the source code), i.e. the matrix
in Hermite Normal Form giving on prime ideal generators 
C<(\bf p_i)_{1E<lt>= iE<lt>= r}> relations for the class group.
C<v[2]> contains the matrix C<B> (C<matalpha>), i.e. the matrix
containing the expressions of the prime ideal factorbase in terms of the
C<B<p_i>>. It is an C<r\times c> matrix. C<v[3]> contains the complex 
logarithmic embeddings of the system of fundamental units which has been found
(although not computed in the case of C<buchinit>). It is an 
C<(r_1+r_2)\times(r_1+r_2-1)> matrix. C<v[4]> contains the matrix C<M''_C> of
Archimedean components of the relations of the matrix C<M''>, except that the
first C<r_1+r_2-1> columns are suppressed since they are already in C<v[3]>.
C<v[5]> contains the prime factor base, i.e. the list of C<k> prime ideals used
in finding the relations. Finally, C<v[6]> contains the permutation of the
prime factor base which was necessary to reduce the relation matrix to the
form explained on page 354 (i.e. with a big C<c\times c> identity matrix on
the lower right). Note that in the above mentioned book, the need to permute
the rows of the relation matrices which occur was not stressed.

The less technical components are as follows. C<v[7]> is equal to the number 
field data C<nf> given by C<initalg>, and C<v[8]> is a 4-component vector
containing the 5-th, 6-th, 7-th and 8-th
components of the result of C<buchgenfu[,1]>, i.e. the class group, the 
regulator, the ``check'' number which should be close to 1 and the number of
roots of unity and a generator.

The library syntax is C<buchinit(P,c,c2,t,prec)> or
C<buchall(P,c,c2,nrel,borne,nbpid,minsfb,-1,prec)> (see above).



=head2 X<buchinitforcefu>buchinitforcefuC<(P,...)>

identical to C<buchinitfu> (see
below), except that when the precision is insufficient for obtaining
the fundamental units exactly, the internal precision is doubled and
the computation redone, until the exact results are obtained. The user
should be warned that this can take a very long time when the coefficients
of the fundamental units on the integral basis are very large.

The library syntax is
C<buchall(P,c,c2,nrel,borne,nbpid,minsfb,-3,prec)> (see above).



=head2 X<buchinitfu>buchinitfuC<(P,...)>

same as C<buchinit> except that the
8-th component contains the last 6 components of C<buchgenfu[,1]>, i.e. also
the fundamental units and the check on their computation.

The library syntax is C<buchinitfu(P,c,c2,prec)> or
C<buchall(P,c,c2,nrel,borne,nbpid,minsfb,-2,prec)> (see above).



=head2 X<buchnarrow>buchnarrowC<(bnf)>

C<bnf> being a big number field as output by
C<buchinit> or C<buchinitfu>, computes the narrow class group of C<bnf>.
The output is a 3-component row vector analogous to the corresponding
class group component C<bnf[8][1]>: the first component is the narrow
class number, the second component is a vector containing the SNF cyclic
components of the narrow class group, and the third is a vector giving the
generators of the corresponding cyclic groups. Note that this function is
a special case of C<buchray>.

The library syntax is C<buchnarrow(bnf)>.



=head2 X<buchray>buchrayC<(bnf,I)>

C<bnf> being a big number field as output
by C<buchinitfu> (or C<buchinitforcefu>, but the units are mandatory
unless the ideal is trivial), and C<I> being either an ideal in any form
or a two-component row vector containing an ideal and an C<r_1>-component
row vector of flags indicating which real Archimedean embeddings to take
in the module, computes the ray class group of the number field for the
module C<I>, as a 3-component vector as all other finite abelian groups
(cardinality, vector of cylic components, corresponding generators).

The library syntax is C<buchray(bnf,I)>.



=head2 X<buchrayinit>buchrayinitC<(bnf,I)>

same as C<buchray> except that the
output is different. It is a 5-component vector C<w>. C<w[1]> is C<bnf>.
C<w[2]> is the result of applying C<zidealstarinit> to C<I>. C<w[3]>, C<w[4]>
are technical components used only by the functions C<isprincipalray> and
C<isprincipalraygen>. C<w[5]> is the structure of the ray class group as
would have been output by C<buchray>.

The library syntax is C<buchrayinit(bnf,I)>.



=head2 X<compositum>compositumC<(x,y)>

if C<x> and C<y> are irredicible, this gives
a defining polynomial of a compositum of one of the number fields defined by
C<x> and one of the number fields defined by C<y>. This really makes sense only
when these compositums are all conjugate (for example when the degrees of C<x>
and C<y> are coprime), otherwise we would need more information to define a
number field than just a defining polynomial.

The library syntax is C<compositum(x,y)>.



=head2 X<dirzetak>dirzetakC<(nf,b)>

gives as a vector the first C<b> coefficients
of the Dedekind zeta function of the number field C<nf> considered as a 
Dirichlet series.

The library syntax is C<dirzetak(nf,b)>.



=head2 X<discf>discfC<(x)>

X<field discriminant>field discriminant of the number field defined
by the monic irreducible polynomial C<x>.

The library syntax is C<discf(x)>. See also C<basis> above.



=head2 X<factoredbasis>factoredbasisC<(x,f)>

X<integral basis>integral basis of the number field 
defined by the monic irreducible polynomial C<x>, using the round 2 algorithm,
where C<f> is the two-column matrix of the factorization of the discriminant 
of the polynomial C<x>. Note that C<f> does I<not> need to be a complete
factorization of the discriminant. This is especially useful if only a local 
integral basis at a prime or primes is desired: only factors with exponents
greater or equal to 2 will be considered.

The library syntax is C<factoredbase(x,f,&d)>, where C<d> will
receive the discriminant of the number field.



=head2 X<factoreddiscf>factoreddiscfC<(x,p)>

X<field discriminant>field discriminant of the number field defined by
the monic irreducible polynomial C<x>, using the round 2 algorithm, where C<p> is
the two-column matrix of the factorization of the discriminant of the polynomial C<x>.

The library syntax is C<factoreddiscf(x,p)>.



=head2 X<factoredpolred>factoredpolredC<(x,p)>

same as C<polred> (see below) except that
C<p> is the two-column matrix of the factorization of the discriminant of
the polynomial C<x>.

The library syntax is C<factoredpolred(x,p,prec)>.



=head2 X<factoredpolred2>factoredpolred2C<(x,p)>

same as C<polred2> (see below) except that
C<p> is the two-column matrix of the factorization of the discriminant of the polynomial C<x>.

The library syntax is C<factoredpolred2(x,p,prec)>.



=head2 X<factornf>factornfC<(x,t)>

factorization of the univariate
polynomial C<x> over the number field defined by the (univariate)
polynomial C<t>. C<x> may have coefficients in C<B<I<Q>>> or in the number
field. The main variable of C<t> must be of lower priority than that of C<x>
(in other words the variable number of C<t> must be greater than that of C<x>).
However if the coefficients of the number field occur explicitly (as polymods)
as coefficients of C<x>, the variable of these polymods I<must> be the same
as the main variable of C<t>. For example 
C<factornf(x^2+mod(y,y^2+1),y^2+1)> and
C<factornf(x^2+1,y^2+1)> are legal but
C<factornf(x^2+mod(z,z^2+1),y^2+1)> is not.

The library syntax is C<polfnf(x,t)>.



=head2 X<galois>galoisC<(x)>

Galois group of the non-constant polynomial
C<x\inB<I<Q>>[X]>. In the present version 1.39.3, C<x> must be irreducible and the
degree of C<x> must be less than or equal to 7 (for degrees 8,9,10, and 11
we have specific PARI programs available upon request).

The output is a 3-component vector C<[n,s,k]> with the following meaning:
C<n> is the cardinality of the group, C<s> is its signature (C<s=1> if the
group is a subgroup of the alternating group C<A_n>, C<s=-1> otherwise),
and C<k> is the number of the group corresponding to a given pair C<(n,s)>
(C<k=1> except in 2 cases). Specifically, the groups are coded as follows,
using standard notations (see GTM 138 quoted above):



In degree 1: C<S_1=[1,-1,1]>.



In degree 2: C<S_2=[2,-1,1]>.



In degree 3: C<A_3=C_3=[3,1,1]>, C<S_3=[6,-1,1]>.



In degree 4: C<C_4=[4,-1,1]>, C<V_4=[4,1,1]>, C<D_4=[8,-1,1]>, C<A_4=[12,1,1]>, C<S_4=[24,-1,1]>.



In degree 5: C<C_5=[5,1,1]>, C<D_5=[10,1,1]>, C<M_{20}=[20,-1,1]>, C<A_5=[60,1,1]>, C<S_5=[120,-1,1]>.



In degree 6: C<C_6=[6,-1,1]>, C<S_3=[6,-1,2]>, C<D_6=[12,-1,1]>, C<A_4=[12,1,1]>, C<G_{18}=[18,-1,1]>,
C<S_4^-=[24,-1,1]>, C<A_4\times C_2=[24,-1,2]>, C<S_4^+=[24,1,1]>, C<G_{36}^-=[36,-1,1]>,
C<G_{36}^+=[36,1,1]>, C<S_4\times C_2=[48,-1,1]>, C<A_5=PSL_2(5)=[60,1,1]>, C<G_{72}=[72,-1,1]>,
C<S_5=PGL_2(5)=[120,-1,1]>, C<A_6=[360,1,1]>, C<S_6=[720,-1,1]>.



In degree 7: C<C_7=[7,1,1]>, C<D_7=[14,-1,1]>, C<M_{21}=[21,1,1]>, C<M_{42}=[42,-1,1]>,
C<PSL_2(7)=PSL_3(2)=[168,1,1]>, C<A_7=[2520,1,1]>, C<S_7=[5040,-1,1]>.



The method used is that of resolvent polynomials. Beware that in the case of 
degree 7 one has to factor polynomials of degree 35 over C<B<I<Z>>>, and this 
can take a long time. Furthermore there is a risk that the PARI stack 
overflows, so it is prudent in this case to start with a large stack.

The library syntax is C<galois(x,prec)>.



=head2 X<galoisapply>galoisapplyC<(nf,aut,x)>

C<nf> being a number field as output
by C<initalg> or C<initalgred>, and C<aut> being a Galois automorphism
of C<nf> expressed either as a polynomial or a polymod (such automorphisms
being found using for example one of the variants of C<galoisconj>),
computes the action of the automorphism C<aut> on the object C<x> in the
number field. C<x> can be an element (scalar, polymod, polynomial or column
vector) of the number field, an ideal (either given by C<B<I<Z>>_K>-generators
or by a C<B<I<Z>>>-basis), a prime ideal (given as a 5-element row vector) or an
idele (given as a 2-element row vector). Because of possible confusion
with elements and ideals, other vector or matrix arguments are forbidden.

The library syntax is C<galoisapply(nf,aut,x)>.



=head2 X<galoisconj>galoisconjC<(nf)>

C<nf> being a number field as output by 
C<initalg> or C<initalgred>, computes the conjugates of a root C<r> of
the non-constant polynomial C<x=nf[1]> expressed as polynomials in C<r>. This
can be used even if the number field C<nf> is not Galois since some
conjugates may lie in the field. The method uses C<p>-adic approximations to
the roots and C<lllint>. However, in rare cases some conjugates may be
missed (in that case, if you know that the extension is Galois, use
C<galoisconjforce> below). As a note to old-timers of Pari, starting with
version 1.39 this function works much better than the preceding version.

The library syntax is C<galoisconj(nf,prec)>.



=head2 X<galoisconj1>galoisconj1C<(nf)>

C<nf> being a number field as output by 
C<initalg> or C<initalgred>, computes the conjugates of a root C<r> of
the non-constant polynomial C<x=nf[1]> expressed as polynomials in C<r>. This
can be used even if the number field C<nf> is not Galois since some
conjugates may lie in the field. The method uses complex approximations to
the roots and C<lllint> (through C<lindep2>).

The library syntax is C<galoisconj1(nf,prec)>. An older and usually
less efficient version of this program is C<galoisconj2(x,prec)>,
not accessible under GP, where C<x> is now the polynomial itself.



=head2 X<galoisconjforce>galoisconjforceC<(nf)>

C<nf> being a number field as output by 
C<initalg> or C<initalgred>, computes the conjugates of a root C<r> of
the non-constant polynomial C<x=nf[1]> expressed as polynomials in C<r>. This
function must be used ONLY when the number field C<nf> is Galois, since
otherwise it runs into an infinite loop. On the other hand, if the field is
Galois, it is guaranteed to give all the conjugates after a finite time. The
method uses C<p>-adic approximations to the roots and C<lllint>.

The library syntax is C<galoisconjforce(nf,prec)>.



=head2 X<idealadd>idealaddC<(nf,x,y)>

sum of the two ideals C<x> and C<y> in the 
number field C<nf>. When C<x> and C<y> are given by C<B<I<Z>>>-bases, this does
not depend on C<nf> and can be used to compute the sum of any two C<B<I<Z>>>-modules.
The result is given in HNF.

The library syntax is C<idealadd(nf,x,y)>.



=head2 X<idealaddone>idealaddoneC<(nf,x,y)>

C<x> and C<y> being two co-prime integral
ideals (given in any form), this gives a two-component row vector C<[a,b]>
such that C<a\in x>, C<b\in y> and C<a+b=1>.

The library syntax is C<idealaddone(nf,x,y)>.



=head2 X<idealaddmultone>idealaddmultoneC<(nf,v)>

C<v> being a C<k>-component vector of 
ideals (given in any form) which sum to C<B<I<Z>>_K>, gives a C<k>-component 
vector C<e> such that C<e[i]\in x[i]> for C<1E<lt>= iE<lt>= k> and 
C<\sum_{1E<lt>= iE<lt>= k}e[i]=1>.

The library syntax is C<idealaddmultone(nf,v)>.



=head2 X<idealappr>idealapprC<(nf,x)>

If C<x> is a fractional ideal (given in any
form), gives an element C<F<alpha>> in C<nf> such that for all prime ideals 
C<B<p>> such that the valuation of C<x> at C<B<p>> is non-zero, we have 
C<v_B<p>(F<alpha>)=v_B<p>(x)>, and. C<v_B<p>(F<alpha>)E<gt>=0> for all
other C<B<p>>.

The library syntax is C<idealappr(nf,x)>.



=head2 X<idealapprfact>idealapprfactC<(nf,x)>

Given a prime ideal factorization as
given by C<idealfactor>, but possibly with zero or negative exponents
gives an element C<F<alpha>> such that for all prime
ideals C<B<p>> occuring in C<x>, C<v_B<p>(F<alpha>)> is equal to the
exponent of C<B<p>> in C<x>, and for all other prime ideals, 
C<v_B<p>(F<alpha>)E<gt>=0>. This generalizes C<idealappr> since it
allows zero exponents. Note that the algorithm used is slightly different,
so that C<idealapprfact(nf,idealfactor(nf,x))> is not always the
same as C<idealappr(nf,x)>.

The library syntax is C<idealapprfact(nf,x)>.



=head2 X<idealcoprime>idealcoprimeC<(nf,x,y)>

given two integral ideals C<x> and C<y>
in the number field C<nf>, finds a C<F<beta>> in the field, expressed on the
integral basis C<nf[7]>, such that C<F<beta> .  y> is an integral ideal
coprime to C<x>. 

The library syntax is C<idealcoprime(nf,x)>.



=head2 X<idealdiv>idealdivC<(nf,x,y)>

quotient C<x .  y^{-1}> of the two ideals 
C<x> and C<y> in the number field C<nf>. The result is given in HNF.

The library syntax is C<idealdiv(nf,x,y)>.



=head2 X<idealdivexact>idealdivexactC<(nf, x, y)>

Same as C<idealdiv>,
except that the quotient C<x  .  y^{-1}> is assumed to
be an integral ideal.  This can be much faster than
C<idealdiv> when the norm of the quotient is small
even though the norms of C<x> and C<y> are large.

The library syntax is C<idealdivexact(nf,x,y)>.



=head2 X<idealfactor>idealfactorC<(nf,x)>

factors into prime ideal powers the ideal
C<x> in the number field C<nf>. The output format is similar to the
C<factor> function, and the prime ideals are represented in the form
output by the C<primedec> function, i.e. as 5-element vectors.

The library syntax is C<idealfactor(nf,x)>.



=head2 X<idealhermite>idealhermiteC<(nf,x)>

gives the Hermite normal form matrix
of the ideal C<x>. The ideal can be given in any form whatsoever
(typically by an algebraic number of it is principal, by a C<B<I<Z>>_K>-system
of generators, as a prime ideal as given by C<primedec>, or by a
C<B<I<Z>>>-basis).

The library syntax is C<idealhermite(nf,x)>.



=head2 X<idealhermite2>idealhermite2C<(nf,a,b)>

gives the Hermite normal form matrix
of the ideal C<x=aB<I<Z>>_K+bB<I<Z>>_K>, where C<a> and C<b> are elements of C<K> given
either as vectors on the integral basis C<nf[7]> or as algebraic numbers.

The library syntax is C<idealhermite(nf,x)>.



=head2 X<idealintersect>idealintersectC<(nf,x,y)>

intersection of the two ideals C<x>
and C<y> in the number field C<nf>. When C<x> and C<y> are given by 
C<B<I<Z>>>-bases, this does not depend on C<nf> and can be used to compute the 
intersection of any two C<B<I<Z>>>-modules. The result is given in HNF.

The library syntax is C<idealintersect(nf,x,y)>.



=head2 X<idealinv>idealinvC<(nf,x)>

inverse of the ideal C<x> in the number 
field C<nf>. The result is the Hermite normal form of the inverse of the 
ideal, together with the opposite of the Archimedean information if it 
is given.

The library syntax is C<idealinv(nf,x)>.



=head2 X<idealinv2>idealinv2C<(nf,x)>

inverse of the ideal C<x> in the number 
field C<nf>. The result is the Hermite normal form of the inverse of the 
ideal, together with the opposite of the Archimedean information if it 
is given. The algorithm uses the different, and can be slower or faster
than C<idealinv>.

The library syntax is C<oldidealinv(nf,x)>.



=head2 X<ideallllred>ideallllredC<(nf,x,vdir)>

LLL reduction of the ideal C<x>
in the number field C<nf>, along the direction C<vdir>. Here C<vdir> must be
either an C<r1+r2>-component vector (C<r1> and C<r2> number of real and complex
places of C<nf> as usual), or the PARI zero, in which case C<vdir> is assumed
to be equal to the vector having only components equal to 1. The notion
of reduction along a direction is technical and cannot be explained here.
Note that this is I<not> the same as the LLL
reduction of the lattice C<x> since ideal operations are involved. The
result is the Hermite normal form of the LLL-reduced ideal, which is usually,
but not always, a reduced ideal. C<x> may also be a 2-component vector,
the first being as above, and the second containing a matrix of Archimedean
information. In that case, this matrix is suitably updated.

The library syntax is C<ideallllred(nf,x,vdir,prec)>.



=head2 X<idealmul>idealmulC<(nf,x,y)>

ideal multiplication of the ideals C<x> and
C<y> in the number field C<nf>. The result is a generating set for 
the ideal product with at most C<n> elements, and is in Hermite normal 
form if C<x> and C<y> are, and this is given together with the sum of the 
Archimedean information in C<x> and C<y> if both are given.

The library syntax is C<idealmul(nf,x,y)>.



=head2 X<idealmulred>idealmulredC<(nf,x,y)>

same as C<idealmul>, except that the
result is reduced using C<ideallllred>.

The library syntax is C<idealmulred(nf,x,y,prec)>, where C<prec> is a
C-long integer representing the precision.



=head2 X<idealnorm>idealnormC<(nf, x)>

computes the norm of the ideal C<x>
in the number field C<nf>.

The library syntax is C<idealnorm(nf, x)>.



=head2 X<idealpow>idealpowC<(nf,x,k)>

computes the C<k>-th power of the ideal
C<x> in the number field C<nf>.
C<k> can be positive, negative or zero. The result is NOT reduced, it is
really the C<k>-th ideal power, and is given in HNF. Use C<idealpowred>
if you want a reduced result.

The library syntax is C<idealpow(nf,x,k)>. A similar routine
C<idealpows(nf,x,k)> is available, where C<k> is now a C-long integer.



=head2 X<idealpowred>idealpowredC<(nf,x,k)>

computes a reduced C<k>-th power of the
ideal C<x> in the number field C<nf>.
To get a non-reduced result, use C<idealpow>. Note however that 
C<idealpowred> is NOT the same as as C<idealpow> followed by 
reduction (i.e. C<ideallllred>), since the reduction is performed 
throughout the powering process.

The library syntax is C<idealpowred(nf,vp,k,prec)>, where C<prec> is a
C-long integer.



=head2 X<idealtwoelt>idealtwoeltC<(nf,x)>

computes a two-element representation of
the ideal C<x> in the number field C<nf>, using a straightforward
(exponential time) search. C<x> can be an ideal in any form, (including 
perhaps an Archimedean part, which is ignored) and the result is a
row vector C<[a,F<alpha>]> with two components such that C<x=aB<I<Z>>_K+F<alpha>B<I<Z>>_K>
and C<a\inB<I<Z>>>. Note that C<a> can be equal to zero if C<x> is given as a
polynomial, a polymod or by a single generator. If C<x> is given by at
least two generators, C<a> is chosen to be the positive generator of
C<x\capB<I<Z>>>. 

The library syntax is C<ideal_two_elt(nf,x)>.



=head2 X<idealtwoelt2>idealtwoelt2C<(nf,x,a)>

if C<x> is an integral ideal (given in
any form) and C<a> a non-zero element of C<x>, this computes a C<b\in x> 
such that C<x=aB<I<Z>>_K+bB<I<Z>>_K>, and outputs C<b> on the integral basis C<nf[7]>.
The method uses C<idealapprfact> and is asymptotically faster than
C<idealtwoelt>, but in practice it is usually slower.

The library syntax is C<ideal_two_elt2(nf,x,a)>.



=head2 X<idealval>idealvalC<(nf,x,vp)>

gives the valuation of the ideal C<x>
at the prime ideal C<vp> in the number field C<nf>, where C<vp> must be a
5-component vector as given by C<primedec>.

The library syntax is C<idealval(nf,x,vp)> and the result is a C-long integer.



=head2 X<initalg>initalgC<(x)>

C<x> being a non-constant irreducible polynomial in 
C<B<I<Q>>[X]>, computes a 9-component vector C<v> useful in working in the number
field C<K> defined by C<x>. C<v[1]> contains the polynomial C<x>. C<v[2]> 
contains C<[r1,r2]>, the number of real and complex places of C<K>. C<v[3]>
contains the discriminant C<d(K)> of the number field C<K>. C<v[4]> contains the 
index of C<v[1]>, i.e. C<[B<I<Z>>_K:B<I<Z>>[F<theta>]]>, where C<F<theta>> is any
root of C<v[1]>. C<v[5]> is a vector containing 7 matrices C<M>, C<MC>, C<T2>, 
C<T>, C<MD>, C<TI>, C<MDI> useful for certain computations in the number
field C<K>. The matrix C<M> is the C<(r1+r2)\times n> matrix whose columns
represent the numerical values of the conjugates of the elements of
the integral basis. The matrix C<MC> is essentially the conjugate of the
transpose of C<M>, except that the last C<r2> columns are also multiplied by
2. The matrix C<T2> is an C<n\times n> matrix equal to the real part of the
product C<MC .  M> (which is a real positive definite symmetric matrix),
the so-called T2-matrix. The matrix C<T> is the C<n\times n> matrix whose 
coefficients are C<Tr(F<omega>_iF<omega>_j)> where the C<F<omega>_i>
are the elements of the integral basis. Note that C<T=\overline{MC} .  M>
and in particular that C<T=T_2> if the field is totally real (in practice
C<T_2> will have real approximate entries and C<T> will have integer entries).
Note also that C< F<det> (T)> is equal to the discriminant of the field C<K>.
The columns of C<MD> express a C<B<I<Z>>>-basis of the different of C<K>
on the integral basis C<v[7]>. C<TI> is equal to C<d(K)T^{-1}>, which has
integral coefficients. Finally, the columns of C<MDI> express a
C<B<I<Z>>>-basis of C<d(K)> times the codifferent ideal (which will be
an integral ideal) on the integral basis C<v[7]>.

C<v[6]> is the vector containing the C<r1+r2> roots of C<v[1]> corresponding
to the C<r1+r2> embeddings of the number field into C<B<I<C>>> (the first C<r1> 
components are real, the next C<r2> have positive imaginary part). C<v[7]> is
an integral basis in Hermite normal form for C<B<I<Z>>_K> expressed on the 
powers of C<F<theta>>. C<v[8]> is the C<n\times n> integral matrix expressing
the power basis in terms of the integral basis, and finally C<v[9]> is the
C<n\times n^2> matrix giving the multiplication table of the integral basis.

The library syntax is C<initalg(x,prec)>.



=head2 X<initalgred>initalgredC<(x)>

same as C<initalg> except that the
polynomial C<x> is changed into a polynomial defining C<K> which is
as simple as can easily be found using the C<polred> algorithm, and
all the subsequent computations are done using this new polynomial.
In particular, the first component of the result is the modified 
polynomial. Note that C<x> must be a monic polynomial.

The library syntax is C<initalgred(x,prec)>.



=head2 X<initalgred2>initalgred2C<(P)>

this is a complement to C<initalgred>. With
the same conditions, it produces a two-element vector C<[nf,mod(a,pol)]>. C<nf>
is the same as in C<initalgred>, C<pol> is the reduced polynomial C<nf[1]>
and C<mod(a,pol)> is the polymod equal to C<mod(x,P)>.

The library syntax is C<initalgred2(x,prec)>.



=head2 X<initzeta>initzetaC<(x)>

compute a number of initilization data
concerning the number field defined by the polynomial C<x> so as to be
able to compute the Dedekind zeta and lambda functions (C<zetak>
and C<lambdak>). This function calls in particular the C<buchinit>
program, and is extremely dependent on the current precision. The
result is a 9-component vector C<v> whose components are very technical and
cannot really be used by the user except through the programs C<zetak>
and C<lambdak>. The only component which can be used if it has not
been done already is C<v[1][4]> which is the result of the C<buchinit>
call.

The library syntax is C<initzeta(x)>.



=head2 X<isideal>isidealC<(nf,x)>

returns 1 if C<x> is an ideal in the number field
C<nf>, 0 otherwise.

The library syntax is C<isideal(x)>.



=head2 X<isincl>isinclC<(x,y)>

tests whether the number field C<K> defined by the
polynomial C<x> is conjugate to a subfield of the field C<L> defined by C<y> 
(where C<x> and C<y> must be in C<B<I<Q>>[X]>). If they are not, the output is the
number 0. If they are, the output is a vector of polynomials, each polynomial
C<a> representing an isomorphism of C<K> into C<L>, i.e. being such that
C<y |  x\circ a>.

The library syntax is C<nfincl(x,y)>.



=head2 X<isinclfast>isinclfastC<(x,y)>

tests whether the number field C<K> defined by
the polynomial C<x> is conjugate to a subfield of the field C<L> defined by C<y> 
(where C<x> and C<y> must be in C<B<I<Q>>[X]>). If they are, this function may
find an embedding much faster than C<isincl>, but it may also miss
some, so you must use C<isincl> to be sure.

The library syntax is C<isinclfast(x,y)>.



=head2 X<isisom>isisomC<(x,y)>

tests whether the two number fields defined by the
polynomials C<x> and C<y> (which must be in C<B<I<Q>>[X]>) are isomorphic. If they
are not, the output is the number 0. If they are, the output is a vector of
polynomials, each polynomial C<a> representing an isomorphism, i.e. being such
that C<y |  x\circ a>.

The library syntax is C<nfiso(x,y)>.



=head2 X<isisomfast>isisomfastC<(x,y)>

tests whether the two number fields defined by 
the polynomials C<x> and C<y> (which must be in C<B<I<Q>>[X]>) are isomorphic. If 
they are this function may find the isomorphism faster than C<isisom>,
and the output is the same, i.e. a vector of polynomials, each polynomial 
C<a> representing an isomorphism, i.e. being such that C<y |  x\circ a>. 
However it may miss the isomorphism, so to be sure you must use C<isisom>.
To summarize, if you do not care about the complete list of isomorphisms:
use first C<isisomfast>. If the answer gives at least one isomorphism,
stop. Otherwise (i.e. if the function returns 0) use C<isisom>.

The library syntax is C<isisomfast(x,y)>.



=head2 X<isprincipal>isprincipalC<(bnf,x)>

C<bnf> being the number field data output
by C<buchinit> or C<buchinitfu>, and C<x> being either a C<B<I<Z>>>-basis of an
ideal in the number field (not necessarily in HNF) or a prime ideal in the
format output by the function C<primedec>, this function tests whether 
the ideal is principal or not. The result is more complete than a simple
true/false answer: it gives a row vector C<v_1> which is the vector of 
components C<c_i> of the class of the ideal C<x> in the class group,
expressed on the generators C<g_i> given by C<buchinit> 
(specifically C<buchinit[8][1][3]>). The C<c_i> are chosen so that
C<0E<lt>= c_i<n_i> where C<n_i> is the order of C<g_i> (the vector of C<n_i> being 
C<buchinit[8][1][2]>). The more complete function C<isprincipalgen>
is available, but this function is slower and may print warning messages
in the case where the precision is too low.

The library syntax is C<isprincipal(bnf,x)>.



=head2 X<isprincipalgen>isprincipalgenC<(bnf,x)>

C<bnf> being the number field data output
by C<buchinit>, and C<x> being either a C<B<I<Z>>>-basis of an ideal in the
number field (not necessarily in HNF) or a prime ideal in the format output
by the function C<primedec>, this function tests whether the ideal is 
principal or not. The result is much more complete than a simple true/false
answer: it is given as a 3 component vector C<[v_1,v_2,e]> with the following
meaning. C<v_1> is the vector of components C<c_i> of the class of the ideal C<x>
in the class group, expressed on the generators C<g_i> given by C<buchinit> 
(specifically C<buchinit[8][1][3]>). The C<c_i> are chosen so that
C<0E<lt>= c_i<n_i> where C<n_i> is the order of C<g_i> (the vector of C<n_i> being 
C<buchinit[8][1][2]>).

The second component C<v_2> gives on the integral basis
the components of C<F<alpha>> such that C<x=F<alpha>\prod_ig_i^{c_i}>.
In particular, C<x> is principal if and only if C<v_1> is equal to the zero 
vector, and if this the case C<x=F<alpha>B<I<Z>>_K> where C<F<alpha>> is given by
C<v_2>. Note that if C<F<alpha>> is too large to be given, a warning message will
be printed and C<v_2> will be set equal to the empty vector. Finally the third
component C<e> is analogous to the last component of C<buchgen>: it gives
a check on the accuracy of the result, in bits. C<e> should be at least 
C<10>, and preferably much more. In any case, the result is checked for
correctness.

The library syntax is C<isprincipalgen(bnf,x)>.



=head2 X<isprincipalray>isprincipalrayC<(bnfray,x)>

C<bnfray> being the number field data
output by C<buchrayinit> and C<x> being an ideal in any form, outputs
the components of C<x> on the ray class group generators given in C<bnfray[5]>
in a manner similar to isprincipal.

The library syntax is C<isprincipalray(bnfray,x)>.



=head2 X<isprincipalraygen>isprincipalraygenC<(bnfray,x)>

C<bnfray> being the number field data
output by the function C<buchrayinit> and C<x> being an ideal in any form, outputs
a 3-component vector C<v> analogous to the one output by C<isprincipalgen>,
but for the ray class group. C<v[1]> is the vector of components of C<x> on the
ray class group generators given in C<bnfray[5]> in a manner similar to 
isprincipal. C<v[2]> gives on the integral basis an element C<F<alpha>> such
that C<x=F<alpha>\prod_ig_i^{x_i}>. Finally C<v[3]> indicates the number of bits
of accuracy left in the result. In any case the result is checked for 
correctness, but C<v[3]> is included to see if it is necessary to increase
the accuracy in other computations.

The library syntax is C<isprincipalraygen(bnfray,x)>.



=head2 X<isunit>isunitC<(bnf,x)>

C<bnf> being the number field data output by
C<buchinit> and C<x> being an algebraic number (type integer, rational or
polymod), this outputs the decomposition of C<x> on the fundamental units an
the roots of unity if C<x> is a unit, the empty vector otherwise.
More precisely, if C<u_1>,...,C<u_r> are the fundamental units found
by C<buchgen> and if C<F<zeta>> is the generator of the group of roots
of unity found by C<buchgen>, the output is a vector C<[x_1,...,x_r,x_{r+1}]>
such that C<x=u_1^{x_1}... u_r^{x_r} . F<zeta>^{x_{r+1}}>. The C<x_i> are
integers for C<iE<lt>= r> and is an integer modulo the order of C<F<zeta>> for
C<i=r+1>.

The library syntax is C<isunit(bnf,x)>.



=head2 X<lambdak>lambdakC<(nfz,x)>

C<nfz> being a number field initialized by
C<initzeta> (not by C<initalg>), computes the value of the
Dedekind lambda function of the number field at the complex number C<x>
(i.e. the product of the Dedekind zeta function by its gamma factors).
The accuracy of the result depends in an essential way on the accuracy
of both the C<initzeta> program and the current accuracy, but even
so the result may be off by up to 5 or 10 decimal digits.

The library syntax is C<glambdak(nfz,x,prec)>.



=head2 X<modreverse>modreverseC<(a)>

C<a> being a polymod C<A(X)> modulo C<T(X)>,
finds the ``reverse polymod'' C<B(X)> modulo C<Q(X)>, where C<Q> is the minimal
polynomial of C<a>, which must be equal to the degree of C<T>, and such that
if C<F<theta>> is a root of C<T> then C<F<theta>=B(F<alpha>)> for a certain root
C<F<alpha>> of C<Q>.

This is very useful when one changes the generating element in algebraic 
extensions.

The library syntax is C<polymodrecip(x)>.



=head2 X<newtonpoly>newtonpolyC<(x,p)>

gives the vector of the slopes of the
Newton polygon of the polynomial C<x> with respect to the prime number C<p>.
The C<n> components of the vector are in decreasing order, and C<n> is equal
to the degree of C<x>. 

The library syntax is C<newtonpoly(x,p)>.





=head2 X<nfdetint>nfdetintC<(nf,x)>

given a pseudo-matrix C<x>, computes a 
non-zero ideal contained in (i.e. multiple of) the determinant of C<x>.
This is particularly useful in conjunction with C<nfhermitemod>

The library syntax is C<nfdetint(nf,x)>.



=head2 X<nfdiv>nfdivC<(nf,x,y)>

given two elements C<x> and C<y> as column
vectors on the integral basis C<nf[7]>, computes their quotient C<x/y>
in the number field C<nf>.

The library syntax is C<element_div(nf,x,y)>.



=head2 X<nfdiveuc>nfdiveucC<(nf,x,y)>

given two elements C<x> and C<y> as column
vectors on the integral basis C<nf[7]>, computes an algebraic integer
C<q> in the number field C<nf> such that the components of C<x-qy> are
reasonably small. In fact, this is functionally identical to 
C<round(nfdiv(nf,x,y))>.

The library syntax is C<nfdiveuc(nf,x,y)>.



=head2 X<nfdivres>nfdivresC<(nf,x,y)>

given two elements C<x> and C<y> as column
vectors on the integral basis C<nf[7]>, gives a two-element row vector
C<[q,r]> such that C<x=qy+r>, C<q> is an algebraic integer in C<nf>, and
the components of C<r> are reasonably small.

The library syntax is C<nfdivres(nf,x,y)>.



=head2 X<nfhermite>nfhermiteC<(nf,x)>

given a pseudo-matrix C<(A,I)>, finds a
pseudo-basis in Hermite Normal Form of the module it generates.

The library syntax is C<nfhermite(nf,x)>.



=head2 X<nfhermitemod>nfhermitemodC<(nf,x,detx)>

given a pseudo-matrix C<(A,I)> and
an ideal C<detx> which is contained in (read integral multiple of) the
determinant of C<(A,I)> finds a pseudo-basis in Hermite Normal Form of
the module generated by C<(A,I)>. This avoids coefficient explosion.
C<detx> can be computed using the function C<nfdetint>.

The library syntax is C<nfhermitemod(nf,x,detx)>.



=head2 X<nfmod>nfmodC<(nf,x,y)>

given two elements C<x> and C<y> as column
vectors on the integral basis C<nf[7]>, computes an element C<r> of C<nf>
of the form C<r=x-qy> with C<q> and algebraic integer, and such that
C<r> is small. This is functionally identical to 
C<x-nfmul(nf,round(nfdiv(nf,x,y)),y)>.

The library syntax is C<nfmod(nf,x,y)>.



=head2 X<nfmul>nfmulC<(nf,x,y)>

given two elements C<x> and C<y> as column
vectors on the integral basis C<nf[7]>, computes their product C<x*y>
in the number field C<nf>.

The library syntax is C<element_mul(nf,x,y)>.



=head2 X<nfpow>nfpowC<(nf,x,k)>

given an element C<x> as a column
vector on the integral basis C<nf[7]> and a positive or negative integer C<k>,
computes C<x^k> in the number field C<nf>.

The library syntax is C<element_pow(nf,x,k)>.



=head2 X<nfreduce>nfreduceC<(nf,x,ideal)>

Given an ideal in Hermite Normal Form
and an element x of the number field C<nf>, finds an element C<r> in C<nf>
such that C<x-r> belongs to the ideal and C<r> is small.

The library syntax is C<element_reduce(nf,x,ideal)>.



=head2 X<nfsmith>nfsmithC<(nf,x)>

given a torsion module C<x> as a 3-component
row vector C<[A,I,J]> where C<A> is a square invertible C<n\times n> matrix,
C<I> and C<J> are two ideal lists, outputs an ideal list C<d_1,...,d_n>
which is the Smith normal form of C<x>. In other words, C<x> is isomorphic
to C<B<I<Z>>_K/d_1\oplus...\oplusB<I<Z>>_K/d_n> and C<d_i> divides C<d_{i-1}> for
C<iE<gt>=2>. The link between C<x> and C<[A,I,J]> is as follows: if C<e_i> is
the canonical basis of C<K^n>, C<I=[b_1,...,b_n]> and C<J=[a_1,...,a_n]>,
then C<x> is isomorphic to
C<(b_1e_1\oplus...\oplus b_ne_n)/(a_1A_1\oplus...\oplus a_nA_n) ,>
where the C<A_j> are the columns of the matrix C<A>.

Note that every finitely generated torsion module can be given in this
way, and even with C<b_i=Z_K> for all C<i>.

The library syntax is C<nfsmith(nf,x)>.



=head2 X<nfval>nfvalC<(nf,x,pr)>

given an elements C<x> as a column
vectors on the integral basis C<nf[7]>, and a prime ideal C<pr> in the
format output by C<primedec>, computes their the valuation at
C<pr> of the element C<x>. The same result could be obtained using
C<idealval(nf,x,pr)> (since C<x> would then be converted to a principal
ideal), but it would be less efficient.

The library syntax is C<element_val(nf,x,pr)>, and the result
is a C long.



=head2 X<ordred>ordredC<(x)>

finds polynomials with reasonably small
coefficients and of the same degree as that of C<x> defining suborders
of the order defined by C<x>. One of the polynomials always defines
C<B<I<Q>>> (hence is equal to C<(x-1)^n>, where C<n> is the degree), and
another always defines the same order as C<x> if C<x> is irreducible.

The library syntax is C<ordred(x)>.



=head2 X<polred>polredC<(x)>

finds polynomials with reasonably small
coefficients defining subfields of the number field defined by C<x>. 
One of the polynomials always defines
C<B<I<Q>>> (hence is equal to C<(x-1)>, where C<n> is the degree), and another
always defines the same number field as C<x> if C<x> is irreducible.

The library syntax is C<polred(x,prec)>.



=head2 X<polred2>polred2C<(x)>

finds polynomials with reasonably small
coefficients defining subfields of the number field defined by C<x>. 
The result is a two-column matrix, the first column giving the elements,
the second giving the polynomials.

One of the polynomials always defines C<B<I<Q>>> (hence is equal to C<(x-1)>,
where C<n> is the degree), and another
always defines the same number field as C<x> if C<x> is irreducible.

The library syntax is C<polred2(x,prec)>.



=head2 X<polredabs>polredabsC<(x)>

finds one of the polynomial defining the same
number field as the one defined by C<x>, and such that the sum of the
squares of the modulus of the roots (i.e. the C<T_2>-norm) is minimal.

The library syntax is C<polredabs(x,prec)>.



=head2 X<primedec>primedecC<(nf,p)>

computes the prime ideal decomposition of 
the prime number C<p> in the number field C<nf>. C<p> must be a (positive)
prime number. Note that the fact that C<p> is prime is not checked, so if
a non-prime number C<p> is given it may lead to unpredictable results.

The result is a vector of 5-component vectors, each representing one of 
the prime ideals above C<p> in the number field C<nf>. The representation 
C<vp=[p,a,e,f,b]> of a prime ideal means the following. The prime ideal is 
equal to C<pB<I<Z>>_K+F<alpha>B<I<Z>>_K> where C<B<I<Z>>_K> is the ring of integers of the
field and C<F<alpha>=\sum_i a_iF<omega>_i> where the C<F<omega>_i> form the
integral basis C<nf[7]>, C<e> is the ramification index, C<f> is the residual
index, and C<b> is an C<n>-component column vector representing a 
C<F<beta>\inB<I<Z>>_K> such that C<vp^{-1}=B<I<Z>>_K+F<beta>/pB<I<Z>>_K> which will
be useful for computing valuations, but which the user can ignore.

The library syntax is C<primedec(nf,p)>.



=head2 X<principalideal>principalidealC<(nf,x)>

creates the principal ideal generated
by the algebraic number C<x> (which must be of type integer, rational or 
polymod) in the number field C<nf>. The result is a one-column matrix.

The library syntax is C<principalideal(nf,x)>.



=head2 X<principalidele>principalideleC<(nf,x)>

creates the principal idele generated
by the algebraic number C<x> (which must be of type integer, rational or
polymod) in the number field C<nf>. The result is a two-component vector, 
the first being a one-column matrix representing the corresponding
principal ideal, and the second being the vector with C<r_1+r_2>
components giving the complex logarithmic embedding of C<x>.

The library syntax is C<principalidele(nf,x)>.



=head2 X<rnfbasis>rnfbasisC<(bnf,x)>

given a big number field C<bnf> as 
output by C<buchinit> or C<buchinitfu>, and either a polyomial C<x>
with coefficients in C<bnf> defining a relative extension C<L> of C<bnf>,
or a pseudo-basis C<x> of such an extension, gives either a true 
C<bnf>-basis of C<L> if it exists, or an C<n+1>-element generating set of C<L>
if not, where C<n> is the rank of C<L> over C<bnf>.

The library syntax is C<rnfbasis(bnf,x)>.



=head2 X<rnfdiscf>rnfdiscfC<(nf,x)>

given a number field C<nf> as output by
C<initalg> or C<initalgred> and a polyomial C<x>
with coefficients in C<nf> defining a relative extension C<L> of C<nf>,
computes the relative discriminant of C<L>. This is a two-element row
vector C<[D,d]>, where C<D> is the relative ideal discriminant and C<d> is 
the relative discriminant considered as an element of C<nf^*/{nf^*}^2>.

Note: C<nf> can be a C<bnf> as output by C<buchinit>.

The library syntax is C<rnfdiscf(bnf,x)>.



=head2 X<rnfhermitebasis>rnfhermitebasisC<(bnf,x)>

given a big number field C<bnf> as 
output by C<buchinit> or C<buchinitfu>, and either a polyomial C<x>
with coefficients in C<bnf> defining a relative extension C<L> of C<bnf>,
or a pseudo-basis C<x> of such an extension, gives either a true 
C<bnf>-basis of C<L> in upper triangular Hermite Normal Form, if it exists,
zero otherwise.

The library syntax is C<rnfhermitebasis(bnf,x)>.



=head2 X<rnfisfree>rnfisfreeC<(bnf,x)>

given a big number field C<bnf> as 
output by C<buchinit> or C<buchinitfu>, and either a polyomial C<x>
with coefficients in C<bnf> defining a relative extension C<L> of C<bnf>,
or a pseudo-basis C<x> of such an extension, returns true (1) if
C<L/bnf> is free, false (0) if not.

The library syntax is C<rnfisfree(bnf,x)>, and the result is a
C-long integer.



=head2 X<rnfpseudobasis>rnfpseudobasisC<(nf,x)>

given a number field C<nf> as output by
C<initalg> or C<initalgred> and a polyomial C<x>
with coefficients in C<nf> defining a relative extension C<L> of C<nf>,
computes a pseudo-basis C<(A,I)> and the relative discriminant of C<L>.
This is output as a four-element row vector C<[A,I,D,d]>, where C<D> is the
relative ideal discriminant and C<d> is the relative discriminant 
considered as an element of C<nf^*/{nf^*}^2>.

Note: C<nf> can be a C<bnf> as output by C<buchinit>.

The library syntax is C<rnfpseudobasis(nf,x)>.



=head2 X<rnfsteinitz>rnfsteinitzC<(nf,x)>

given a number field C<nf> as output
by C<initalg> or C<initalgred> and either a polyomial C<x>
with coefficients in C<nf> defining a relative extension C<L> of C<nf>,
or a pseudo-basis C<x> of such an extension as output for example by
C<rnfpseudobasis>, computes another pseudo-basis C<(A,I)> (not in HNF in
general) such that all the ideals of C<I> except perhaps the last one
are equal to the ring of integers of C<nf>. The name of this functions
comes from the fact that the ideal class of the last ideal of C<I>
(which is well defined) is called the I<steinitz class> of the
module C<B<I<Z>>_L>.

Note: C<nf> can be a C<bnf> as output by C<buchinit>.

The library syntax is C<rnfsteinitz(nf,x)>.



=head2 X<rootsof1>rootsof1C<(nf)>

computes the number of roots of unity C<w> and
a primitive C<w>-th root of unity (expressed on the integral basis) 
belonging to the number field C<nf>.
The result is a two-component vector C<[w,z]> where C<z> is a column vector
expressing a primitive C<w>-th root of unity on the integral basis C<nf[7]>.

The library syntax is C<rootsof1(nf)>.



=head2 X<signunit>signunitC<(bnf)>

C<bnf> being a the number field data output by
C<buchinit> and similar programs, this computes an C<r_1\times(r_1+r_2-1)>
matrix having C<F<+->1> components, giving the signs of the real embeddings of
the fundamental units found by C<buchinit>. 

The library syntax is C<signunits(bnf)>.



=head2 X<smallbasis>smallbasisC<(x)>

X<integral basis>integral basis of the number field defined by
the monic irreducible polynomial C<x>, using the round 2 algorithm, where one does
not take into account squares of primes which are not precomputed.

The library syntax is C<smallbase(x,&y)>, where C<y> will receive the
discriminant of the number field (I<not> of the polynomial C<x>).
This program is the translation in C of a program written by David Ford.



=head2 X<smalldiscf>smalldiscfC<(x)>

X<field discriminant>field discriminant of the number field defined
by the monic irreducible polynomial C<x>, where one does not take into account
squares of primes which are not precomputed.

The library syntax is C<smalldiscf(x)>. See also C<smallbasis> above.



=head2 X<smallpolred>smallpolredC<(x)>

same as C<polred> above except that
only a suborder of the maximal order may be used.

The library syntax is C<smallpolred(x,prec)>.



=head2 X<smallpolred2>smallpolred2C<(x)>

same as C<polred2> above except that
only a suborder of the maximal order may be used.

The library syntax is C<smallpolred2(x,prec)>.



=head2 X<threetotwo>threetotwoC<(nf,a,b,c)>

Given a number field C<nf> and
three algebraic integers C<a>, C<b>, C<c> in C<nf> given as column vectors
on the integral basis C<nf[7]>, outputs a 3-component
row vector [d,e,U] such that C<U> is a unimodular (i.e. C< F<det> (U)=F<+->1>)
C<3\times 3> matrix with coefficients in the ring of integers of C<nf>
satisfying the matrix identity C<[a,b,c]U=[0,d,e]>. The elements C<d>, C<e>
and the entries of C<U> are given as column vectors on C<nf[7]>.

The library syntax is C<threetotwo(nf,a,b,c)>.



=head2 X<tschirnhaus>tschirnhausC<(x)>

apply a random Tschirnhausen transformation
to the non-constant separable polynomial C<x> so as to obtain a new equation
for the number field (or more generally the etale algebra) defined by C<x>.
This is for instance useful when computing resolvents, hence is used in
the C<galois> function above.

The library syntax is C<tschirnhaus(x)>.



=head2 X<twototwo>twototwoC<(nf,a,b)>

Given a number field C<nf> and
two algebraic integers C<a> and C<b> in C<nf> given as column vectors
on the integral basis C<nf[7]>, outputs a 3-component
row vector [d,e,U] such that C<U> is a unimodular (i.e. C< F<det> (U)=F<+->1>)
C<2\times 2> matrix with coefficients in the ring of integers of C<nf>
satisfying the matrix identity C<[a,b]U=[d,e]>, and C<d>, C<e> are
as ``small'' as possible. The elements C<d>, C<e>
and the entries of C<U> are given as column vectors on C<nf[7]>.

The library syntax is C<twototwo(nf,a,b)>.



=head2 X<zetak>zetakC<(nfz,x)>

C<nfz> being a number field initialized by
C<initzeta> (not by C<initalg>), computes the value of the
Dedekind zeta function of the number field at the complex number C<x>.
The accuracy of the result depends in an essential way on the accuracy
of both the C<initzeta> program and the current accuracy, but even
so the result may be off by up to 5 or 10 decimal digits.

The library syntax is C<gzetak(nfz,x,prec)>.



=head2 X<zideallog>zideallogC<(nf,x,bid)>

C<nf> being a number field, C<bid> being
a ``big ideal'' as output by C<zidealstarinit> and C<x> being a 
non-necessarily integral element of C<nf> which must have valuation equal to 0
at all prime ideals dividing C<I=bid[1]>, computes the ``discrete logarithm''
of C<x> on the generators given in C<bid[2]>. In other words, if C<g_i> are these
generators, of orders C<d_i> respectively, the result is a column vector
of integers C<(x_i)> such that C<0E<lt>= x_i<d_i> and 
C<x ~ \prod_ig_i^{x_i}\pmod{ ^*I} .> Note that when C<I> is a
module, this implies also sign conditions on the embeddings.

The library syntax is C<zideallog(nf,x,bid)>.



=head2 X<zidealstar>zidealstarC<(nf,I)>

C<nf> being a number field, and C<I> either
and ideal in any form, or a row vector whose first component is an ideal
and whose second component is a row vector or C<r_1> 0 or 1, computes
the structure of C<(B<I<Z>>_K/I)^*> as a 3-component vector v. v[1] is the order,
v[2] is the vector of SNF cyclic components and v[3] the corresponding 
generators. When the row vector is explicitly included, the non-zero elements
of this vector are considered as real embeddings of C<nf> in the order given in
C<roots>, i.e. in nf[6], and then C<I> is a module with components at 
infinity.

The library syntax is C<zidealstar(nf,I)>.



=head2 X<zidealstarinit>zidealstarinitC<(nf,I)>

C<nf> being a number field, and C<I> either
and ideal in any form, or a row vector whose first component is an ideal
and whose second component is a row vector or C<r_1> 0 or 1, computes
necessary data for computing in the group C<(B<I<Z>>_K/I)^*>. The result is a
as a 5-component vector w. w[1] is the ideal or module C<I> itself.
w[2] is the structure of the group as output by C<zidealstar>.
the other components are difficult to describe and are used only in conjunction
with the function C<zideallog>.

The library syntax is C<zidealstarinit(nf,I)>.



=head1 Polynomials and power series.



We group here all functions which are specific to polynomials or power
series. Many other functions which can be applied on these objects are
described in the other sections. Also, some of the functions described here
can be applied to other types.



=head2 X<apprpadic>apprpadicC<(x,a)>

vector of C<p>-adic roots of the polynomial C<x>
congruent to the C<p>-adic number C<a> modulo C<p> (or modulo 4 if C<p=2>), and
with the same C<p>-adic precision as C<a>. The number C<a> can be an ordinary C<p>-adic
number (type 7, i.e. an element of C<B<I<Q>>_p>) or can be an element of a
finite extension of C<B<I<Q>>_p>, in which case it is of type 9 (polymod), where
at least one of the coefficients of the polymod is a C<p>-adic number. In this case,
the result is the vector of roots belonging to the same extension of C<B<I<Q>>_p> as
C<a>.

The library syntax is C<apprgen9(x,a)>, but if C<a> is known to be simply
a C<p>-adic number (type 7), the syntax C<apprgen(x,a)> can be used.



=head2 X<convol>convolC<(x,y)>

convolution (or X<Hadamard product>Hadamard product) of the
two power series C<x> and C<y>; in other words if C<x=\sum a_k*X^k> and
C<y=\sum b_k*X^k> then C<convol>C<(x,y)=\sum a_k*b_k*X^k>.

The library syntax is C<convol(x,y)>.



=head2 X<cyclo>cycloC<(n)>

C<n>-th cyclotomic polynomial, where C<n> must be
positive.

The library syntax is C<cyclo(n)>, where C<n> is a C-long integer.



=head2 X<deriv>derivC<(x,y)>

derivative of C<x> with respect to the simple
variable C<y>. C<x> can be any type except polymod. The derivative of a scalar
type is zero, and the derivative of a vector or matrix is done
componentwise.

The library syntax is C<deriv(x,v)>, where C<v> is the number of the
variable C<y>.



=head2 X<disc>discC<(x)>

discriminant of C<x>. C<x> must be a polynomial.
The algorithm used is the X<subresultant algorithm>subresultant algorithm.

The library syntax is C<discsr(x)>.



=head2 X<eval>evalC<(x)>

replace in C<x> the formal variables by the
values that have been assigned to them after the creation of C<x>.
This is mainly useful in GP, and not in library mode. Do not confuse
this with substitution (see C<subst> below).

The library syntax is C<geval(x)>.



=head2 X<factorpadic>factorpadicC<(x,p,r)>

C<p>-adic factorization of the polynomial C<x>
to precision C<r>, the result being a two-column matrix as in C<factor>.
C<r> must be in general be strictly larger than the C<p>-adic valuation of the
discriminant of C<x> for the result to make any sense. The method used is
Ford-Letard's implementation of the round 4 algorithm of Zassenhaus.
Another version using an algorithm due to Buchmann and Lenstra is
C<factorpadic2>, but is less efficient.

The library syntax is C<factorpadic4(x,p,r)>, where C<r> is a C-long integer.



=head2 X<factpol>factpolC<(x,l,hint)>

C<x> must be a polynomial with 
coefficients in C<B<I<Z>>>. If C<l=0>, find the complete factorization of 
C<x>, and if C<lE<gt>0>, search only for irreducible factors of degree less 
than or equal to C<l>. C<hint> is a positive integer which tells the
program that the degrees of all the factors are multiples of C<hint>.
The result is a two-column matrix, the first one containing the 
irreducible factors, the second one the exponents.

The library syntax is C<factpol(x,l,hint)>. The algorithm used is the standard
Hensel lifting of a mod C<p> factorization. Another implementation using instead
root finding over C<B<I<C>>> (instead of implicitly using C<B<I<Q>>_p>) is
C<factpol2(x,l)> (no C<hint> included in that case).



=head2 X<integ>integC<(x,y)>

X<formal integration>formal integration of C<x> with respect to
the simple variable C<y>. No logarithmic terms
must occur in the result. C<x> can be of any type. When C<x> is a rational
function, it is assumed that the base ring is an integral domain of
characteristic zero.

The library syntax is C<integ(x)>.



=head2 X<isirreducible>isirreducibleC<(x)>

C<x> being a polynomial (univarariate
in the present version 1.39.3), returns 1 if C<x> is non-constant and 
irreducible, 0 otherwise.

The library syntax is C<gisirreducible(x)>.



=head2 X<karamul>karamulC<(x,y,k)>

Karatsuba multiplication of the polynomials
C<x> and C<y>, recursively called C<k> times. This is a very primitive and
preliminary attempt at a sturdy Karatsuba program, and will hopefully
be improved (in particular the recursion variable C<k> will disappear).

The library syntax is C<karatsuba(x,y,k)>.



=head2 X<laplace>laplaceC<(x)>

C<x> must be a power series with only
non-negative exponents. If C<x=\sum (a_k/k!)*X^k> then the result is
C<\sum a_k*X^k>.

The library syntax is C<laplace(x)>.



=head2 X<legendre>legendreC<(x)>

creates the C<x^{th}> X<Legendre polynomial>Legendre polynomial.

The library syntax is C<legendre(x)>, where C<x> is a C-long integer.



=head2 X<polint>polintC<(xa,ya,x)>

given the data vectors C<xa> and C<ya>
of the same length C<n> (C<xa> containing the C<x>-coordinates, and C<ya> the
corresponding C<y>-coordinates), this function finds the X<interpolating polynomial>interpolating polynomial
passing through these points and evaluates it at the value C<x>.

The library syntax is C<polint(xa,ya,x,&er)>, where C<er> will contain an
error estimate on the returned value.



=head2 X<polsym>polsymC<(x,n)>

creates the vector of the X<symmetric powers>symmetric powers
of the roots of the polynomial C<x> up to power C<n>.

The library syntax is C<polsym(x)>.



=head2 X<recip>recipC<(x)>

reciprocal polynomial of C<x>, i.e. the
coefficients are in reverse order. C<x> must be a polynomial.

The library syntax is C<polrecip(x)>.



=head2 X<resultant>resultantC<(x,y)>

resultant of the two polynomials
C<x> and C<y> with exact entries. The algorithm used is the subresultant algorithm.

The library syntax is C<subres(x,y)>.



=head2 X<resultant2>resultant2C<(x,y)>

resultant of the two polynomials
C<x> and C<y>. The algorithm used is the determinant of Sylvester's matrix.

The library syntax is C<resultant2(x,y)>.



=head2 X<reverse>reverseC<(x)>

reverse power series (i.e. C<x^{-1}>, not
C<1/x>) of C<x>. C<x> must be a power series whose valuation is exactly equal
to one.

The library syntax is C<recip(x)>.



=head2 X<rootmod>rootmodC<(x,p)>

row vector of roots modulo C<p> of the polynomial 
C<x>. Slightly slower than C<rootmod2> below for C<p<100>, but much faster 
for larger values. The particular non-prime value C<p=4> is accepted, mainly 
for C<2>-adic computations. Multiple roots are I<not> repeated.

The library syntax is C<rootmod(x,p)>.



=head2 X<rootmod2>rootmod2C<(x,p)>

row vector of roots modulo C<p> of the polynomial
C<x>. To be used only when C<p> is small. Multiple roots are repeated with their
order of multiplicity.

The library syntax is C<rootmod2(x,p)>.



=head2 X<rootpadic>rootpadicC<(x,p,r)>

row vector of C<p>-adic roots of the polynomial
C<x> with C<p>-adic precision equal to C<r>. Multiple roots are I<not> 
repeated.

The library syntax is C<rootpadic(x,p,r)>, where C<r> is a C-long integer.



=head2 X<roots>rootsC<(x)>

complex roots of the polynomial C<x>, given
as a column vector where each root is repeated according to its
multiplicity. The precision is given as for transcendental functions:
under GP it is kept in the variable C<prec> and is transparent to
the user, but it must be explicitly given as a second argument in library mode.

The algorithm used is a variant of the Newton-Raphson method and is not
guaranteed to converge, but is rather fast. If you get the messages
``too many iterations in roots'' or
``INTERNAL ERROR: incorrect result in roots'', try
modifying your polynomial to get the roots, or try to use the slower function
C<rootslong>.

The library syntax is C<roots(x,prec)>.



=head2 X<rootslong>rootslongC<(x)>

same as C<roots> except that the program is
a little more robust and slower.

The library syntax is C<rootslong(x,prec)>.



=head2 X<sturm>sturmC<(x)>

number of real roots of the real polynomial C<x>,
using Sturm's algorithm.

The library syntax is C<sturm(x)>. The result is a C-long integer.



=head2 X<sturmpart>sturmpartC<(x,a,b)>

number of real roots of the real polynomial C<x> in
the interval C<]a,b]>, using Sturm's algorithm.

The library syntax is C<sturmpart(x)>. The result is a C-long integer.



=head2 X<subst>substC<(x,y,z)>

replace the simple variable C<y> by the argument C<z> in expression C<x>. 
Every non-scalar type is allowed for C<x>. If C<x> is a
power series, C<z> must be either a polynomial, a power series, or a
rational function. C<y> must be a simple variable name.

The library syntax is C<gsubst(x, v,z)>, where C<v> is the number of
the variable C<y>.



=head2 X<sylvestermatrix>sylvestermatrixC<(x,y)>

forms the Sylvester matrix corresponding
to the two polynomials C<x> and C<y>, where the coefficients of the polynomials
are put in the columns of the matrix (which is the natural direction for
solving equations afterwards). The use of this matrix can be essential when
dealing with polynomials with inexact entries, since polynomial Euclidean
division doesn't make much sense in that case.

The library syntax is C<sylvestermatrix(x,y)>.



=head2 X<taylor>taylorC<(x,y)>

Taylor expansion around C<0> of C<x> with
respect to the simple variable C<y>. C<x> 
can be of any reasonable type, for example a rational function. The number of
terms of the expansion is transparent to the user under GP, but must be
given as a second argument in library mode.

The library syntax is C<tayl(x,y,n)>, where the C-long integer C<n>
is the desired number of terms in the expansion.



=head2 X<tchebi>tchebiC<(x)>

creates the C<x^{th}> Tchebicheff
polynomial.

The library syntax is C<tchebi(x)>, where C<x> is a C-long integer.



=head1 Vectors, matrices, linear algebra and sets.





=head2 X<adj>adjC<(x)>

X<adjoint matrix>adjoint matrix of C<x>, i.e. the matrix C<y>
of cofactors of C<x> such that C<x*y=det(x)*Id>. C<x> must be
a (non-necessarily invertible) square matrix.

The library syntax is C<adj(x)>.



=head2 X<algdep>algdepC<(x, k)>

X<algebraic dependence> C<x> being real or complex, finds a
polynomial of degree at most C<k> having C<x> as approximate root.
The algorithm used is a variant of the LLL algorithm due to Hastad,
Lagarias and Schnorr (STACS 1986). Note that the polynomial which is
obtained is not necessarily the ``correct'' one. One can check the
closeness either by a polynomial evaluation or substitution, or by
finding the roots of the polynomial given by algdep.

The library syntax is C<algdep(x,k,prec)>, where C<k> is a C-long integer.



=head2 X<algdep2>algdep2C<(x, k, dec)>

X<algebraic dependence> C<x> being real or complex, finds a
polynomial of degree at most C<k> having C<x> as approximate root.
C<dec> is a number which should be between half the number of decimal
digits of precision and that number. The algorithm used is the LLL
algorithm. Note that the polynomial which is
obtained is not necessarily the ``correct'' one. One can check the
closeness either by a polynomial evaluation or substitution, or by
finding the roots of the polynomial given by algdep2.

The library syntax is C<algdep2(x,k,dec,prec)>, where C<k> and C<dec> are
C-long integers.



=head2 X<char>charC<(x,y)>

X<characteristic polynomial>characteristic polynomial of C<x> with respect
to the variable C<y>, i.e. determinant of C<y*I-x> if C<x> is a square
matrix, determinant of the map multiplication by C<x> if C<x> is a polymod,
error if C<x> is of any other type.
For matrices, the method used is essentially the same as for computing the
adjoint matrix, i.e. computing the traces of the powers of C<x>.

The library syntax is C<caradj0(x, v)>, where C<v> is the variable 
number, or even C<caradj(x,v,0)>. Note that the function 
C<caradj(x,v,pty)> returns the characteristic polynomial of C<x> in the 
variable C<v>, and if C<pty> is not equal to 0, puts in C<pty> the
address of the adjoint matrix of C<x>, so both can be obtained at once.



=head2 X<char1>char1C<(x,y)>

X<characteristic polynomial>characteristic polynomial of C<x> with respect
to the variable C<y>, i.e. determinant of C<y*I-x> if C<x> is a square
matrix, determinant of the map multiplication by C<x> if C<x> is a polymod,
error if C<x> is of any other type.
For matrices, the method used is that of Lagrange interpolation and is almost
always slower than C<char>. Identical to C<char> for polymods.

The library syntax is C<caract(x, v)>, where C<v> is the variable 
number.



=head2 X<char2>char2C<(x,y)>

characteristic polynomial of the square matrix
C<x> with respect to the variable C<y> using the Hessenberg form. This is
faster than C<char> when the
coefficients are integermod a prime or real numbers, but is usually slower in
other base rings.

The library syntax is C<carhess(x,v)>, where C<v> is the variable number.



=head2 X<concat>concatC<(x,y)>

concatenation of C<x> and C<y>. If
C<x> or C<y> is not a vector or matrix, it is considered as a 
one-dimensional vector. All types are allowed for C<x> and C<y>, but
the sizes must be compatible. Note that matrices are concatenated
horizontally, i.e. the number of rows stays the same. Using
transpositions, it is easy to concatenate them vertically.

To concatenate vectors sideways (i.e. to obtain a two-row or two-column
matrix), first transform the vector into a one-row or one-column matrix
using the function C<mat> below.

The library syntax is C<concat(x,y)>.



=head2 X<det>detC<(x)>

determinant of C<x>. C<x> must be a
square matrix. Another program called B<X<det2>det2>C<(x)> is better
when the entries of the matrix are reals or integers for example,
but can be much worse for more complicated entries like multivariate
polynomials.

The library syntax is C<det(x)> and C<det2(x)>.



=head2 X<detint>detintC<(x)>

C<x> being an C<m\times n> matrix with integer
coefficients, this function computes a multiple of the determinant of the 
lattice generated by the columns of C<x> if it is of rank C<m>, and returns
zero otherwise. This function can be useful in conjunction with the function
C<hermitemod> which needs to know such a multiple. Other ways to obtain
this determinant (assuming the rank is maximal) is 
C<det(lllkerim(x)[2]C<*>x)> or simply C<det(hermite(x))>. 
Try to see which is faster in your case.

The library syntax is C<detint(x)>.



=head2 X<eigen>eigenC<(x)>

gives the eigenvectors of C<x> as columns of
a matrix.

The library syntax is C<eigen(x)>.



=head2 X<extract>extractC<(x,y)>

extraction of components of the
vector or matrix C<x> according to C<y>. C<x> must be a vector or
a matrix. In the case of a matrix, the components are as usual the
I<columns> of C<x>. The parameter C<y> must be either a number of type
integer or a vector. If C<y> is an integer, it is considered as a mask:
The binary bits of C<y> are read from right to left, but correspond to 
taking the components from left to right. For example, if C<y=13=(1101)_2>
then the components 1,3 and 4 are extracted. 

If C<y> is a vector, which must have integer entries, these
entries correspond to the component numbers to be extracted, in the order
specified.

In the case of a matrix, the difference between extract and matextract
is that only columns are extracted.

The library syntax is C<extract(x,y)>.



=head2 X<gauss>gaussC<(x,y)>

C<x> being a square matrix and
C<y> a column vector, finds the solution C<u> of C<x*u=y>, using
Gaussian elimination. This has the same effect as, but is much faster,
than C<x^{-1}*y>.

The library syntax is C<gauss(x,y)>.



=head2 X<hermite>hermiteC<(x)>

if C<x> is a (not necessarily square) matrix of
maximal rank, finds the I<upper triangular> Hermite Normal Form of C<x>
If the rank of C<x> is equal to its number of rows, the result is a square
matrix. In general, the columns of the result form a basis of the lattice
spanned by the columns of C<x>.

The library syntax is C<hnf(x)>.



=head2 X<hermitemod>hermitemodC<(x,d)>

if C<x> is a (not necessarily square) 
matrix of maximal rank with integer entries, and C<d> is a multiple of the
(non-zero) determinant of the lattice spanned by the columns of C<x>,
finds the I<upper triangular> Hermite Normal Form of C<x>.

If the rank of C<x> is equal to its number of rows, the result is a square
matrix. In general, the columns of the result form a basis of the lattice
spanned by the columns of C<x>. This is much faster than C<hermite> when
C<d> is known.

The library syntax is C<hnfmod(x,d)>.



=head2 X<hess>hessC<(x)>

Hessenberg form of the square matrix C<x>.

The library syntax is C<hess(x)>.



=head2 X<hilbert>hilbertC<(x)>

C<x> being a C-long integer,
creates the X<Hilbert matrix>Hilbert matrix of order C<x>, i.e. the matrix whose
coefficient (C<i>,C<j>) is C<1\over {i+j-1}>.

The library syntax is C<hilbert(x)>.



=head2 X<idmat>idmatC<(n)>

creates the C<n\times n> identity matrix.

The library syntax is C<idmat(n)> where C<n> is a C-long integer.

Related
functions are C<gscalmat(x,n)>, which creates C<x> times the identity
matrix (C<x> being a GEN and C<n> a C-long integer),
and C<gscalsmat(x,n)> which is the same when C<x> is a C-long integer.



=head2 X<image>imageC<(x)>

gives a basis for the image of the matrix
C<x> as columns of a matrix. A priori the matrix can have entries of any type.

The library syntax is C<image(x)>.



=head2 X<imagecompl>imagecomplC<(x)>

gives the vector of the column indices which are 
not extracted by the function C<image>. Hence the number of components
of C<imagecompl(x)> plus the number of columns of C<image(x)> is equal
to the number of columns of the matrix C<x>.

The library syntax is C<imagecompl(x)>.



=head2 X<imager>imagerC<(x)>

gives a basis for the image of the matrix C<x> as
columns of a matrix, where C<x> has elements which can be non-exact real or
complex numbers. In that case, the precision of the matrix entries determines
what is meant by an element of the image. In particular, if the matrix is
ill-conditioned, the results may not be what you expect.

The library syntax is C<imagereel(x)>.



=head2 X<indexrank>indexrankC<(x)>

C<x> being a matrix of rank C<r>, gives two vectors
of length C<r> giving a list of rows and columns respectively (starting from 1)
such that the extracted matrix obtained from these 2 vectors using 
C<matextract> is invertible.

The library syntax is C<indexrank(x)>.



=head2 X<indsort>indsortC<(x)>

indirect sorting of the vector C<x>, i.e. if C<x>
is an C<n>-component vector, creates a permutation of C<[1,2,...,n]>
which applied to the components of C<x> sorts C<x> in increasing order.

The library syntax is C<indexsort(x)>.



=head2 X<intersect>intersectC<(x,y)>

C<x> and C<y> being two matrices with the
same number of rows each of whose columns are independent, finds a basis
of the C<B<I<Q>>>-vector space equal to the intersection of the spaces 
spanned by the columns of C<x> and C<y> respectively. See also the function
C<idealintersect> above, which does the same for free C<B<I<Z>>>-modules.
X<idealintersect>

The library syntax is C<intersect(x,y)>.



=head2 X<inverseimage>inverseimageC<(x,y)>

gives a column vector belonging to the 
inverse image of the column vector C<y> by the matrix C<x> if one exists,
the empty vector otherwise. To get the complete inverse image, it 
suffices to add to the result any element of the kernel of C<x> obtained 
for example by C<ker>.

The library syntax is C<inverseimage(x,y)>.



=head2 X<isset>issetC<(x)>

returns true (1) if C<x> is a set, false (0) if not.
In PARI, a set is simply a row vector whose entries are strictly increasing.
To convert any vector (and other objects) into a set, use the function 
C<set> below.

The library syntax is C<isset(x)>, and this returns a C-long integer.



=head2 X<jacobi>jacobiC<(x)>

C<x> being a real symmetric matrix, this gives a
 vector having two components: the first one is the vector of eigenvalues of
C<x>, the second is the corresponding orthogonal matrix of eigenvectors of
C<x>. The method used is Jacobi's method for symmetric matrices.

The library syntax is C<jacobi(x)>.



=head2 X<ker>kerC<(x)>

gives a basis for the kernel of the matrix
C<x> as columns of a matrix. A priori the matrix can have entries of any type.
See also C<keri> and C<kerr>.

The library syntax is C<ker(x)>.



=head2 X<keri>keriC<(x)>

same as C<ker>, except that it assumes that the 
matrix has entries of type integer. In that case it is much faster.

The library syntax is C<keri(x)>.



=head2 X<kerint>kerintC<(x)>

gives an LLL-reduced C<B<I<Z>>>-basis for the lattice
equal to the kernel of the matrix C<x> as columns of the matrix C<x> with
integer entries (rational entries are not permitted) using a modified integer 
LLL algorithm.

The library syntax is C<kerint(x)>.



=head2 X<kerint1>kerint1C<(x)>

like C<kerint>, but using C<matrixqz3>,
gives an LLL-reduced C<B<I<Z>>>-basis for the lattice
equal to the kernel of the matrix C<x> as columns of the matrix C<x> with
integer or rational entries. If LLL reduction of the final result is not
desired, use C<matrixqz3(ker(x))> instead.

The library syntax is C<kerint1(x)>.



=head2 X<kerint2>kerint2C<(x)>

like C<kerint>, but using another modified LLL
algorithm, gives an LLL-reduced C<B<I<Z>>>-basis for the lattice
equal to the kernel of the matrix C<x> as columns of the matrix C<x> with
integer entries (rational entries are not permitted). In the present version
1.39.3, only independent rows are allowed. 

The library syntax is C<kerint2(x)>.



=head2 X<kerr>kerrC<(x)>

gives a basis for the kernel of the matrix C<x> as
columns of a matrix, where C<x> has elements which can be non-exact real or
complex numbers. In that case, the precision of the matrix entries determines
what is meant by an element of the kernel. In particular, if the matrix is
ill-conditioned, the results may not be what you expect.

The library syntax is C<kerreel(x)>.



=head2 X<lexsort>lexsortC<(x)>

sort the elements of the vector C<x> by 
ascending lexicographic order (see C<lex> above).

The library syntax is C<lexsort(x)>.



=head2 X<lindep>lindepC<(x)>

X<linear dependence>C<x> being a vector with real
or complex coefficients, finds a small integral linear combination
among these coefficients using a variant of the LLL algorithm due to
Hastad, Lagarias and Schnorr (STACS 1986).

The library syntax is C<lindep(x,prec)>.



=head2 X<lindep2>lindep2C<(x,dec)>

X<linear dependence>C<x> being a vector with real
or complex coefficients, finds a small integral linear combination
among these coefficients using the LLL algorithm. C<dec> is a parameter which
should be between one half the number of decimal digits of precision
and that number.

The library syntax is C<lindep2(x,dec,prec)> where C<dec> is a C-long integer.



=head2 X<lll>lllC<(x)>

LLL algorithm applied to the B<columns>
of the (not necessarily square) matrix C<x>. The columns of C<x> must
however be of maximal rank (otherwise if C<x> has integral coefficients
use C<lllint>. The result is a square 
transformation matrix C<T> such that C<x .  T> is an LLL-reduced
basis of the lattice generated by the column vectors of C<x>. The
computations are done with real numbers (i.e. not with rational numbers) hence
are fast but as presently programmed (version 1.39.3) are numerically unstable.
An older version of this program is C<lll1>.

The library syntax is C<lll(x,prec)>.



=head2 X<lllgram>lllgramC<(x)>

same as LLL except that the matrix C<x>
which is now square is the Gram matrix of the lattice vectors, and
not the coordinates of the vectors themselves. The result is again
the transformation matrix C<T> which gives (as columns) the coefficients 
with respect to the initial basis vectors. Same remarks as for LLL about
numerical instability in the present version 1.39.3. An older version of
this program is C<lllgram1>.

The library syntax is C<lllgram(x,prec)>.



=head2 X<lllgramint>lllgramintC<(x)>

The matrix C<x> being the Gram matrix of a
basis of some lattice, is assumed to have integral entries. The result is
the unimodular transformation matrix C<T> which gives (as columns) the
coefficients with respect to the initial basis vectors. The computation
is done entirely with integers and is both accurate and quite fast.

The library syntax is C<lllgramint(x)>.



=head2 X<lllgramkerim>lllgramkerimC<(x)>

LLL algorithm applied to the Gram matrix of
some lattice, which is assumed to have integral entries.
Here the columns can be linearly dependent. The result is a two-component
vector of matrices whose concatenation form a unimodular transformation matrix
C<T> which gives as columns the coefficients with respect to the initial basis
vectors. The first matrix will give the kernel, the second will give an 
LLL-reduced basis of the image.

The library syntax is C<lllgramkerim(x)>.



=head2 X<lllint>lllintC<(x)>

LLL algorithm applied to the B<columns> of the
(not necessarily square) matrix C<x>. It is assumed that the corresponding
Gram matrix is integral. The result is a transformation matrix C<T> such
that C<x .  T> is an LLL-reduced basis of the lattice generated by the
column vectors of C<x>. The matrix C<T> is square if the columns of C<x>
are linearly independent.

The computation is done entirely with integers and the algorithm is both
accurate and quite fast.

The library syntax is C<lllint(x)>.



=head2 X<lllintpartial>lllintpartialC<(x)>

similar to C<lllint>, except C<x>
should be an integer matrix whose columns are linearly independent.
The output is a square transformation matrix C<T>
such that C<x  .  T> is a partially reduced basis of the
lattice generated by the column vectors of C<x>.
A basis is said to be I<partially reduced> if
C<| v_i F<+-> v_j | E<gt>= |v_i|> for any two distinct
basis vectors C<v_i,   v_j>.

This can be faster than C<lllint> when one row of C<x>
is huge and the rest of C<x> is small.
If C<T1 = C<lllintpartial>(x)> and
C<T2 = C<lllint>(C<gmul>(x, T1)>, then
output C<x  .  T1  .  T2> is an LLL reduced basis for C<x>.

The library syntax is C<lllintpartial(x)>.



=head2 X<lllkerim>lllkerimC<(x)>

LLL algorithm applied to the columns of the (not
necessarily square) matrix C<x> which is assumed to have integral entries.
Here the columns can be linearly dependent. The result is a two-component
vector of matrices, the columns of the first matrix representing a basis
of the integer kernel of C<x> (not necessarily LLL-reduced) and the columns
of the second matrix being an LLL-reduced C<B<I<Z>>>-basis of the image of the
matrix C<x>.

The library syntax is C<lllkerim(x)>.



=head2 X<lllrat>lllratC<(x)>

same as LLL except that the computations
are all done in rational numbers. Hence no risk of numerical instability,
but extremely slow. This function is essentially superseded by C<lllint>
so will soon disappear.

The library syntax is C<lllrat(x)>.



=head2 X<mat>matC<(x)>

transform the object C<x> into a matrix.
If C<x> is not a vector or a matrix, this creates a C<1\times 1> matrix.
If C<x> is a row (resp. column) vector, this creates a 1-row (resp.
1-column) matrix. If C<x> is already a matrix, a copy of C<x> is created.

This function can be useful in connection with the function C<concat>
(see above).

The library syntax is C<gtomat(x)>.



=head2 X<matextract>matextractC<(x,y,z)>

extraction of a matrix
from the matrix C<x>, the line mask or vector C<y> and the column mask 
or vector C<z>.
C<x> must be a matrix, and C<y> and C<z> either numbers of PARI
type integer or vectors. The extraction is done using the same rules as for
C<extract> (see above). The difference with C<extract> is that both lines
and columns are extracted.

The library syntax is C<matextract(x,y,z)>.



=head2 X<matinvr>matinvrC<(x)>

computes the inverse matrix of C<x> assumed to
have real entries. This may be more efficient than using C<ginv>
X<ginv> (or C<x^{-1}> under GP).

The library syntax is C<invmatreel(x)>. A related function is
C<invmulmatreel(x,y)> which directly computes C<x^{-1}*y> for matrices
C<x> and C<y>.



=head2 X<matsize>matsizeC<(x)>

C<x> being a vector or matrix, returns a row vector
 with two components, the first being the number of rows (1 for a row vector),
the second the number of columns (1 for a column vector).

The library syntax is C<matsize(x)>.



=head2 X<matrixqz>matrixqzC<(x,p)>

C<x> being an C<m\times n> matrix with C<mE<gt>= n> with
rational or integer entries and of maximal rank, this function returns a matrix
having only integral entries, having the same image as C<x> (which is
obtained from C<x> by right multiplication with an C<n\times n> invertible matrix)
and such that the GCD of all its C<n\times n> subdeterminants is equal to 1 when
C<p> is equal to 0, or not divisible by C<p> otherwise. Here C<p> must be a prime
number (when it is non-zero). However, if the function is used when C<p> has no small
prime factors, it will either work or give the message ``impossible inverse modulo''
and a non-trivial divisor of C<p>.

The library syntax is C<matrixqz(x,p)>.



=head2 X<matrixqz2>matrixqz2C<(x)>

C<x> being an C<m\times n> matrix with rational
or integer entries, this function returns a matrix whose columns form a
basis of the lattice equal to C<B<I<Z>>^n> intersected with the lattice generated
by the columns of C<x>.

The library syntax is C<matrixqz2(x)>.



=head2 X<matrixqz3>matrixqz3C<(x)>

C<x> being an C<m\times n> matrix with rational
or integer entries, this function returns a matrix whose columns form a
basis of the lattice equal to C<B<I<Z>>^n> intersected with the 
C<B<I<Q>>>-vector space generated by the columns of C<x>.

The library syntax is C<matrixqz3(x)>.



=head2 X<minim>minimC<(x,b,m)>

C<x> being a square and symmetric
matrix with integer entries representing a positive definite quadratic form,
gives the number of vectors of square norm less than or equal to C<b> (for
the norm defined by C<x>), and at most C<m> of these vectors. The result
is a three-component vector, the first component being the number of vectors,
the second being the maximum norm found, and the last vector is a matrix
whose columns are the vectors found (at most C<m>).

In the special case where C<b=0>, the function searches for the minimal
non-zero vectors.

The library syntax is C<minim(x,b,m)>



=head2 X<perf>perfC<(x)>

C<x> being a square and symmetric matrix with
integer entries representing a positive definite quadratic form,
looks for the perfection of the form: gives the rank of the family of the
C<s> symmetric matrices C<v_iv_i^t>, where C<s> is half the number of minimal
vectors and the C<v_i> (C<1E<lt>= iE<lt>= s>) are the minimal vectors.

The library syntax is C<perf(x)>



=head2 X<pascal>pascalC<(x)>

creates
as a matrix the lower triangular X<pascal triangle>pascal triangle of order C<x+1>
(i.e. with binomial coefficients up to C<x>).

The library syntax is C<pascal(x)>, where C<x> is a C-long integer.



=head2 X<rank>rankC<(x)>

rank of the matrix C<x>.

The library syntax is C<rank(x)>, and the result is a C-long integer.



=head2 X<set>setC<(x)>

convert C<x> into a set, i.e. into a row vector with
strictly increasing entries. C<x> can be of several types, but is most useful
when C<x> is already vector.

The library syntax is C<gtoset(x)>.



=head2 X<setintersect>setintersectC<(x,y)>

intersection of the two sets C<x> and C<y>.

The library syntax is C<intersect(x,y)>.



=head2 X<setminus>setminusC<(x,y)>

difference of the two sets C<x> and C<y>, i.e.
set of elements of C<x> which do not belong to C<y>.

The library syntax is C<setminus(x,y)>.



=head2 X<setsearch>setsearchC<(x,y)>

searches if C<y> belongs to the set C<x>. If it
does, returns the index C<j> such that C<x[j]==y>, otherwise returns 0.

The library syntax is C<setsearch(x,y)> which returns a C-long integer.



=head2 X<setunion>setunionC<(x,y)>

union of the two sets C<x> and C<y>.

The library syntax is C<union(x,y)>.



=head2 X<signat>signatC<(x)>

signature of the quadratic form
represented by the symmetric matrix C<x>. The result is a two-component vector.

The library syntax is C<signat(x)>



=head2 X<smith>smithC<(x)>

if C<x> is a (singular or non-singular) square matrix
with integer coefficients, outputs the vector of elementary divisors of C<x>
(i.e. the diagonal of the Smith normal form of C<x>).

The library syntax is C<smith(x)>.



=head2 X<smithpol>smithpolC<(x)>

if C<x> is a (singular or non-singular) square 
matrix with polynomial coefficients, outputs the vector of elementary divisors
of C<x> (i.e. the diagonal of the Smith normal form of C<x>).

The library syntax is C<gsmith(x)>.



=head2 X<smith2>smith2C<(x)>

if C<x> is a (singular or non-singular) square matrix,
outputs a 2-component vector C<[u,v]> where C<u> and C<v> are two unimodular
matrices such that C<uxv> is the diagonal matrix whose diagonal is 
C<smith(x)>.

The library syntax is C<smith2(x)>.



=head2 X<sort>sortC<(x)>

sort the vector C<x> in ascending order, using the
heapsort method. C<x> must be a vector, and its components integers, reals, or
fractions. A related function is C<indsort> (see above) which gives
the indices of the sorted vector in terms of the initial one. For example, 
C<extract(x,indsort(x))> is equivalent to C<sort(x)>.

The library syntax is C<sort(x)>.



=head2 X<sqred>sqredC<(x)>

X<decomposition into squares>decomposition into squares of the quadratic form
represented by the symmetric matrix C<x>. The result is a matrix whose diagonal
entries are the coefficients of the squares, and the non-diagonal entries
represent the bilinear forms.

The library syntax is C<sqred(x)>.



=head2 X<supplement>supplementC<(x)>

assuming that the columns of the matrix C<x> are
linearly independent (if they are not, an error message is issued), find a
square invertible matrix whose first columns are the columns of C<x>, i.e. 
supplement the columns of C<x> to a basis of the whole space.

The library syntax is C<suppl(x)>.



=head2 X<trace>traceC<(x)>

This applies to quite general C<x>.
If C<x> is not a matrix, it is equal to the sum of C<x> and its conjugate,
except for polymods where it is the trace as an algebraic number.

For C<x> a square matrix, it is the ordinary trace. If C<x> is a
non-square matrix (but not a vector), an error occurs.

The library syntax is C<trace(x)>.



=head2 X<trans>transC<(x)> or C<x~{ }>

transpose of C<x>.
This has an effect only on vectors and matrices.

The library syntax is C<gtrans(x)>.



=head2 X<vecsort>vecsortC<(x,k)>

sort the vector of vectors or matrix C<x> in
ascending order of the C<k>-th component, using the heapsort method. The 
components being compared must be of type integer, real or fraction.
C<k> can also be a vector, in which case the sorting is done lexicographically
according to the components listed in the vector C<k>. For example, if
C<k=[2,1,3]>, sorting will be done with respect to the second component,
and when these are equal, with respect to the first, and when these are 
equal, with respect to the third.

The library syntax is C<vecsort(x,k)>.



=head1 Sums, products, integrals and similar functions.



Although the GP calculator is programmable,
it is useful to have preprogrammed a number of loops, including sums, products,
and a certain number of recursions. Also, a number of functions from numerical
analysis like numerical integration and summation of series will be
described here.

One of the parameters in these loops must be the control variable, hence a
simple variable name. The last parameter must be any legal PARI expression,
including of course expressions using loops. 
Since it is much easier to program directly the loops in library mode, these
functions are mainly useful for GP programming. The use of these functions
in library mode is a little tricky and its explanation will be 
omitted, although the reader can try and figure it out by himself by reading
the source code. A brief explanatory sketch is given in section 11.
Hence in this section we only give the library syntax, with no semantic
explanation.

The letter C<X> will always denote any simple variable name, and represents the
formal parameter used in the function.



=head2 X<divsum>divsumC<(n,X,expr)>

sum of expression C<expr> over
the positive divisors of C<n>.

In the present version 1.39.3, C<n> is restricted to being less than C<2^{31}>.

The library syntax is X<divsomme>divsommeC<(entree *ep, GEN num, char *ch)>.



=head2 X<hvector>hvectorC<(n,X,expr)>

creates a row vector with C<n> components
whose components are the expression C<expr> evaluated at the integral points
between 1 and C<n>.

The library syntax is X<vecteur>vecteurC<(entree *ep, GEN nmax, char *ch)>.



=head2 (numerical) integration

X<numerical integration>
A number of Romberg-like integration methods are implemented. The user should
not require too much accuracy: 18 or 28 decimal digits is OK, but not much 
more. In addition, analytical cleanup of the integral must have been done: 
there must be no singularities in the interval or at the boundaries. In 
practice this can be accomplished with a simple change of variable. 
Furthermore, for improper integrals, where one or both of the limits of 
integration are plus or minus infinity, the function must decrease 
sufficiently rapidly at infinity. This can often be accomplished
through integration by parts.

Note that X<infinity>infinity can be represented with essentially no loss of 
accuracy by 1e4000. However beware of real underflow when dealing with rapidly
decreasing functions. For example, if one wants to compute the
C<\int_0^\infty e^{-x^2} dx> to 28 decimal digits, then one should set 
infinity equal to 10 for example, and certainly not to 1e4000.

The integrand may have values belonging to a vector space over the real
numbers; in particular, it can be complex-valued or vector-valued.



=head2 X<intgen>intgenC<(X=a, b, expr)>

general driver routine for doing 
numerical integration from C<a> to C<b> of the expression C<expr>, with respect to
the formal variable C<X>.

The library syntax is X<rombint>rombintC<(entree *ep, GEN a, GEN b, char *ch, long int prec)>.



=head2 X<intinf>intinfC<(X=a, b, expr)>

numerical integration from C<a> to C<b>,
tailored for being used when C<a> or C<b> are infinite. One I<must> have 
C<abE<gt>0>, and in fact if for example C<b=\infty>, then it is preferable to have 
C<a> as large as possible, at least C<aE<gt>=1>.

The library syntax is X<qromi>qromiC<(entree *ep, GEN a, GEN b, char *ch, long int prec)>.



=head2 X<intnum>intnumC<(X=a,b,expr)>

simple numerical integration from C<a> to C<b>.
This is the fastest method, and should be used when C<a> and C<b> are not too
large, the function is smooth, and can be evaluated exactly everywhere on the
interval C<[a,b]>.

The library syntax is X<qromb>qrombC<(entree *ep, GEN a, GEN b, char *ch, long int prec)>.



=head2 X<intopen>intopenC<(X=a,b,expr)>

numerical integration from C<a> to C<b>. This
method should be used, again when C<a> and C<b> are not too large, but when the 
function is now allowed to be undefined (but continuous) at C<a> or C<b>, for
example the function C< F<sin> (x)/x> at C<x=0>.

The library syntax is X<qromo>qromoC<(entree *ep, GEN a, GEN b, char *ch, long int prec)>.

Two summation methods are also implemented, for alternating series, and for
series with terms of the same sign (see C<sumalt> and C<sumpos> below).



=head2 X<matrix>matrixC<(m,n,X,Y,expr)>

creation of the C<m\times n> matrix
whose coefficients are given by the expression C<expr>. There are two formal
parameters in C<expr>, the first one (C<X>) corresponding to the rows, the
second (C<Y>) to the columns, and C<X> goes from 1 to C<m>, C<Y> goes from 1 to
C<n>.

The library syntax is X<matrice>matriceC<(entree *ep1, entree *ep2, GEN nlig, GEN ncol, char *ch)>.



=head2 X<prod>prodC<(x,X=a,b,expr)>

product of expression C<expr>, initialized
at C<x>, the formal parameter C<X> going from C<a> to C<b>. As for C<sum>, the
initialization parameter C<x> must be given: its main purpose is to force
the type of the operations being performed. For example if it is put equal
to the integer 1, operations will start being done exactly. If it is put
equal to the real C<1.>, they will be done using real numbers having the
default
precision. If it is put equal to the power series C<1+O(X^k)> for a certain
C<k>, they will be done using power series of precision at most C<k>. These
are the three most common initializations.

As an extreme example, compare C<prod(1,j=1,100,(1-X^j))>
with  C<prod(1+O(X^101),j=1, 100, (1-X^j) ).>

The library syntax is X<produit>produitC<(entree *ep, GEN x, GEN a, GEN b, char *ch)>.



=head2 X<prodeuler>prodeulerC<(X=a,b,expr)>

product of expression C<expr>,
initialized at 1., the formal parameter C<X> ranging over the prime numbers
between C<a> and C<b>.X<Euler product>

The library syntax is X<prodeuler>prodeulerC<(entree *ep, GEN a, GEN b, char *ch, long int prec)>.



=head2 X<prodinf>prodinfC<(X=a,expr)>

X<infinite product>infinite product of expression C<expr>, 
the formal parameter C<X> starting at C<a>. The evaluation stops when the 
relative error of the expression minus 1 is less than the default precision. 
The expressions must always evaluate to an element of C<B<I<C>>>.

The library syntax is X<prodinf>prodinfC<(entree *ep, GEN a, char *ch, long int prec)>.



=head2 X<prodinf1>prodinf1C<(X=a,expr)>

infinite product of expression C<1+expr>, the
formal parameter C<X> starting at C<a>. The evaluation stops when the relative 
error of the expression is less than the default precision. The expressions
must always evaluate to an element of C<B<I<C>>>.

The library syntax is X<prodinf1>prodinf1C<(entree *ep, GEN a, char *ch, long int prec)>.



=head2 X<solve>solveC<(X=a,b,expr)>

real root of expression C<expr> between C<a> and
C<b>, under the condition C<expr(X=a)*expr(X=b)E<lt>=0>. The method used is 
Brent's method.

The library syntax is X<zbrent>zbrentC<(entree *ep, GEN a, GEN b, char *ch, long int prec)>.



=head2 X<sum>sumC<(x,X=a,b,expr)>

sum of expression C<expr>, initialized at
C<x>, the formal parameter going from C<a> to C<b>. As for C<prod>, the
initialization parameter C<x> must be given: its main purpose is to force
the type of the operations being performed. For example, if it is put
equal to the integer 0, then operations will start being done exactly. 
If it is put equal to the real C<0.>, then they will be done using real
numbers having the default precision. If it is put equal to the power
series C<O(X^k)> for a certain C<k>, then they will be done using power
series of precision at most C<k>. These are the three most common
initializations.

As an extreme example, compare C<sum(0,j=1, 1000, 1/j)>
with  C<sum(0.,j=1, 1000, 1/j ).>

The library syntax is X<somme>sommeC<(entree *ep, GEN x, GEN a, GEN b, char *ch)>.



=head2 X<sumalt>sumaltC<(X=a, expr)>

numerical summation of the series C<expr>,
which should be an X<alternating series>alternating series, the formal variable C<X> 
starting at C<a>. The algorithm used is an algorithm of F. Villegas as modified by
D. Zagier, and is much better than sumalt2() below which was used formerly.
Beware that the stopping criterion is that the term gets small enough, hence
terms which are equal to 0 will create problems and should be removed.

Divergent alternating series can sometimes be summed by this method, as well as
series which are not exactly alternating (see for example section 11).

The library syntax is X<sumalt>sumaltC<(entree *ep, GEN a, char *ch, long int prec)>.



=head2 X<sumalt2>sumalt2C<(X=a, expr)>

numerical summation of the series C<expr>,
which should be an X<alternating series>alternating series, the formal variable C<X> 
starting at C<a>. The algorithm used is Euler's method of finite differences
combined with a trick due to van Wijngaarden.
Beware that the stopping criterion is that the term gets small enough, hence
terms which are equal to 0 will create problems and should be removed.

Divergent alternating series can sometimes be summed by this method, as well as
series which are not exactly alternating (see for example section 11).

The library syntax is X<sumalt2>sumalt2C<(entree *ep, GEN a, char *ch, long int prec)>.



=head2 X<suminf>suminfC<(X=a,expr)>

X<infinite sum>infinite sum of expression C<expr>, the 
formal parameter C<X> starting at C<a>. The evaluation stops when the relative
error of the expression is less than the default precision. The expressions
must always evaluate to an element of C<B<I<C>>>.

The library syntax is X<suminf>suminfC<(entree *ep, GEN a, char *ch, long int prec)>.



=head2 X<sumpos>sumposC<(X=a,expr)>

numerical summation of the series C<expr>,
which must be a series of terms having the same sign, the formal variable C<X>
starting at C<a>. The algorithm used is van Wijngaarden's
trick for converting such a series into an alternating one, and is quite slow.
Beware that the stopping criterion is that the term gets small enough, hence
terms which are equal to 0 will create problems and should be removed.

The library syntax is X<sumpos>sumposC<(entree *ep, GEN a, char *ch, long int prec)>.



=head2 X<vector>vectorC<(n,X,expr)>

creates a row vector with C<n> components
whose components are the expression C<expr> evaluated at the integral points
between 1 and C<n> (identical with C<hvector>).

The library syntax is X<vecteur>vecteurC<(entree *ep, GEN nmax, char *ch)>.



=head2 X<vvector>vvectorC<(n,X,expr)>

creates a column vector with C<n> components
whose components are the expression C<expr> evaluated at the integral points
between 1 and C<n>.

The library syntax is X<vvecteur>vvecteurC<(entree *ep, GEN nmax, char *ch)>.



=head1 Plotting functions.



Although plotting is not the main purpose of PARI, a number of plotting
functions are provided. These functions are either high-level plotting
functions (all the functions starting with C<plot>) in which the user
has little to do but explain what type of plot he wants, and whose syntax
is similar to the one used in the preceding section. Or they can be low-level
plotting functions, where every drawing primitive (point, line, box, etc...)
must be specified by the user. These low-level functions (called rectplot 
functions) work as follows. You have at your disposal 16 virtual windows which
are filled independently, and can then be physically ORed on a single window at
user-defined positions. These rectwindows are numbered from 0 to 15, and must
be initialized before being used by the function C<initrect>, which 
specifies the height and width of the virtual window. At all times, a virtual
cursor (initialized at C<[0,0]>) is associated to the window, and its current
value can be obtained using the function C<cursor>.

A number of primitive graphic objects can then be drawn in these windows, and
only the part of the object which is inside the window will be drawn, with
the exception of polygons and strings which are drawn entirely (but the
virtual cursor can move outside of the window). Finally, the actual physical
drawing is done using the function C<draw>. Note that the windows are
preserved so that further drawings using the same windows at different 
positions or different windows can be done without extra work. If you want to
erase a window (and free the corresponding memory), use the function
C<killrect>. It is not possible to partially erase a window. Erase it
completely, initialize it again and then fill it with the graphic
objects that you want to keep.

In addition to initializing the window, you may want to have a scaled
window to avoid unnecessary conversions. For this, use the function
C<scale> below. As long as this function is not called, the scaling
is simply the number of pixels, the origin being at the upper left and
the C<y>-coordinates going downwards. 

Finally, note that in the same way that C<texprint> allows you to have
a TeX output corresponding to printed results, the functions starting
with C<post> allow you to have C<postscript> output of the plots. This
will not be absolutely identical with the screen output, but will be 
sufficiently close. Note that you can use postscript output even if you do
not have the plotting routines enabled. The postscript output is written in
a file called C<pari.ps>. Each time a new postscript output is asked for
the postscript output is appended to that file. Hence the user must remove
this file first if he does not want unnecessary drawings from preceding
sessions to appear. On the other hand, in this manner as many plots as desired
can be kept in a single file.





=head2 X<box>boxC<(w,x2,y2)>

let C<(x1,y1)> be the current position of
the virtual cursor. Draw in the rectwindow C<w> the outline of
the rectangle which is such that the points C<(x1,y1)> and C<(x2,y2)> are 
opposite corners. Only the part of the rectangle which is in C<w> is drawn.
The virtual cursor does I<not> move.

The library syntax is C<rectbox(w,x2,y2)> where C<w> is a C-long integer.



=head2 X<cursor>cursorC<(w)>

give as a 2-component vector the current
(scaled) position of the virtual cursor corresponding to the rectwindow C<w>.

The library syntax is C<rectcursor(w)> where C<w> is a C-long integer.



=head2 X<draw>drawC<(list)>

physically draw the rectwindows given in C<list>
which must be a vector whose number of components is divisible by 3. If
C<list=[w1,x1,y1,w2,x2,y2,...]>, the windows C<w1>, C<w2>, etc... are physically
placed with their upper left corner at physical position C<(x1,y1)>, C<(x2,y2)>,
... respectively, and are then drawn together. Overlapping regions will thus
be drawn twice, and the windows are considered transparent.

The library syntax is C<rectdraw(list)>.

Note that in the present version 1.39.3{} this function has been written for the 
X11-window system (hence also for GUI's based on X11 such as
Openwindows and Motif), and for Sunview/Suntools.



=head2 X<initrect>initrectC<(w,x,y)>

initialize the rectwindow C<w> to width C<x> and
height C<y>, and position the virtual cursor at C<(0,0)>.

The library syntax is C<initrect(w,x,y)> where all 3 arguments are
C-long integers.



=head2 X<killrect>killrectC<(w)>

erase rectwindow C<w> and free the corresponding
memory. Note that if you want to use the rectwindow C<w> again, you
must use C<initrect> first to specify the new size.

The library syntax is C<killrect(w)> where C<w> is a C-long integer.



=head2 X<line>lineC<(w,x2,y2)>

let C<(x1,y1)> be the position of the
virtual cursor. Draw in the rectwindow C<w> the part of the
segment C<(x1,y1)-(x2,y2)> which is inside C<w>, and move the virtual cursor to
C<(x2,y2)> (even if it is outside the window). If you want to draw a
line from C<(x1,y1)> to C<(x2,y2)> where C<(x1,y1)> is not necessarily
the position of the virtual cursor, use C<move(w,x1,y1)> before
using the C<line> function.

The library syntax is C<rectline(w,x2,y2)> where C<w> is a C-long integer.



=head2 X<lines>linesC<(w,listx,listy)>

draw on the rectwindow C<w> the polygon
such that the (x,y)-coordinates of the vertices are in the vectors of equal
length C<listx> and C<listy>. The virtual cursor does not move. This is
basically the same function as the function C<ploth2>, but with no scaling
factors. Note that to obtain a closed polygon, the first and last point must
be the same. Finally, for simplicity, the whole polygon is drawn, not only the
part of the polygon which is inside the rectwindow.

The library syntax is C<rectlines(w,listx,listy)> where C<w> is a
C-long integer.



=head2 X<move>moveC<(w,x,y)>

move the virtual cursor of the rectwindow C<w> to
position C<(x,y)>.

The library syntax is C<rectmove(w,x,y)> where C<w> is a C-long integer.



=head2 X<plot>plotC<(X=a, b, expr)>

crude plot of the function represented by
expression C<expr> from C<a> to C<b>.

The library syntax is X<plot>plotC<(entree *ep, GEN a, GEN b, char *ch)>.



=head2 X<ploth>plothC<(X=a,b,expr)>

high precision plot of the function C<y=f(x)>
represented by the expression C<expr>, C<x> going from C<a> to C<b>. Since this
involves around 1000 function calls, it is advised to keep the current
precision to a minimum (i.e. 9) before calling C<ploth>.

Note that in the present version 1.39.3{} this function has been written for the 
Macintosh, the X11-window system (hence also for GUI's based on X11 such as
Openwindows and Motif), and for Sunview/Suntools. An Atari/gem version is also
available upon request.

The library syntax is X<ploth>plothC<(entree *ep, GEN a, GEN b, char *ch, long int prec)>.



=head2 X<plothmult>plothmultC<(X=a,b,[expr1,expr2,...])>

high precision plots of the
functions C<y=f_i(x)> represented by the expressions C<expr_i>, C<x> going from C<
a> to C<b>. Since this involves around 1000 function calls times the number
of functions, it is advised to keep the current precision to a minimum 
(i.e. 9) before calling C<ploth>.

Note that in the present version 1.39.3{} this function has been written 
only for the X11-window system (hence also for GUI's based on X11 such as
Openwindows and Motif).

The library syntax is X<plothmult>plothmultC<(entree *ep, GEN a, GEN b, char *ch, long int prec)>.



=head2 X<ploth2>ploth2C<(T=a,b,expr)>

high precision plot of the curve represented
in parametric form by C<x=f(t),y=g(t)>, represented by the expression C<expr>,
C<t> going from C<a> to C<b>. The expression must be a two-component vector.
Since this involves around 2000 function calls, it is advised to keep the 
current precision to a minimum (i.e. 9) before calling C<ploth2>.

Note that in the present version 1.39.3{} this function has been written for
the Macintosh, the X11-window system (hence also for GUI's based on X11 such as
Openwindows and Motif), and for Sunview/Suntools. An Atari/gem version is also
available upon request.

The library syntax is X<ploth2>ploth2C<(entree *ep, GEN a, GEN b, char *ch, long int prec)>.



=head2 X<plothraw>plothrawC<(listx,listy)>

high precision plot of the points whose
(x,y)-coordinates are in the vectors of equal length listx and listy. Automatic
positioning and scaling is done, but with the same scaling factor on C<x> and 
C<y>.

The library syntax is C<plothraw(listx,listy)>.

Note that in the present version 1.39.3{} this function has been written for
the X11-window system (hence also for GUI's based on X11 such as
Openwindows and Motif), and for Sunview/Suntools.



=head2 X<point>pointC<(w,x,y)>

draw the point C<(x,y)> on the rectwindow C<w> (if
it is inside C<w>), and in any case move the virtual cursor to position C<(x,y)>.

The library syntax is C<rectpoint(w,x,y)> where C<w> is a C-long integer.



=head2 X<points>pointsC<(w,listx,listy)>

draw on the rectwindow C<w> the points
whose (x,y)-coordinates are in the vectors of equal length C<listx> and C<listy>
and which are inside C<w>. The virtual cursor does not move. This is basically 
the same function as the function C<plothraw>, but either with no
scaling factor or with a scale chosen using the function C<scale>.

The library syntax is C<rectpoints(w,listx,listy)> where C<w> is a
C-long integer.



=head2 X<postdraw>postdrawC<(list)>

same as C<draw>, except that the output is
a postscript program appended to the file C<pari.ps>.

The library syntax is C<postdraw(list)>.



=head2 X<postploth>postplothC<(X=a,b,expr)>

same as C<ploth>, except that the 
output is a postscript program appended to the file C<pari.ps>.

The library syntax is X<postploth>postplothC<(entree *ep, GEN a, GEN b, char *ch)>.



=head2 X<postploth2>postploth2C<(T=a,b,expr)>

same as C<ploth2>, except that the
output is a postscript program appended to the file C<pari.ps>.

The library syntax is X<postploth2>postploth2C<(entree *ep, GEN a, GEN b, char *ch)>.



=head2 X<postplothraw>postplothrawC<(listx,listy)>

same as C<plothraw>, except that
the output is a postscript program appended to the file C<pari.ps>.

The library syntax is C<postplothraw(listx,listy)>.



=head2 X<rbox>rboxC<(w,dx,dy)>

draw in the rectwindow C<w> the outline of
the rectangle which is such that the points C<(x1,y1)> and C<(x1+dx,y1+dy)> are 
opposite corners, where C<(x1,y1)> is the current position of the cursor.
Only the part of the rectangle which is in C<w> is drawn. The virtual cursor
does I<not> move.

The library syntax is C<rectrbox(w,dx,dy)> where C<w> is a C-long integer.



=head2 X<rline>rlineC<(w,dx,dy)>

draw in the rectwindow C<w> the part of the
segment C<(x1,y1)-(x1+dx,y1+dy)> which is inside C<w>, where C<(x1,y1)>
is the current position of the virtual cursor, and move the virtual cursor to
C<(x1+dx,y1+dy)> (even if it is outside the window).

The library syntax is C<rectrline(w,dx,dy)> where C<w> is a C-long integer.



=head2 X<rmove>rmoveC<(w,dx,dy)>

move the virtual cursor of the rectwindow C<w> to
position C<(x1+dx,y1+dy)>, where C<(x1,y1)> is the initial position of the cursor
(i.e. to position C<(dx,dy)> relative to the initial cursor).

The library syntax is C<rectrmove(w,dx,dy)> where C<w> is a C-long integer.



=head2 X<rpoint>rpointC<(w,dx,dy)>

draw the point C<(x1+dx,y1+dy)> on the rectwindow
C<w> (if it is inside C<w>), where C<(x1,y1)> is the current position of the
cursor, and in any case move the virtual cursor to position C<(x1+dx,y1+dy)>.

The library syntax is C<rectrpoint(w,dx,dy)> where C<w> is a C-long integer.



=head2 X<scale>scaleC<(w,x1,x2,y1,y2)>

scale the local coordinates of the
rectwindow C<w> so that C<x> goes from C<x1> to C<x2> and C<y> goes from C<y1> to
C<y2> (C<x2<x1> and C<y2<y1> being allowed). Initially, after the initialization
of the rectwindow C<w> using the function C<initrect>, the default scaling
is the graphic pixel count, and in particular the C<y> axis is oriented 
downwards since the origin is at the upper left. The function C<scale> 
allows to change all these defaults and should be used whenever functions are
graphed.

The library syntax is C<rectscale(w,x1,x2,y1,y2)> where C<w> is a 
C-long integer.



=head2 X<string>stringC<(w,x)>

draw on the rectwindow C<w> at the current position
of the cursor the string corresponding to C<x>. C<x> can either be a string
enclosed in quotes ( " ), or C<x> can be a number which can be converted into
a real number. In that case it is printed in the format 9.3lf, i.e. 9 
characters before the decimal point, and 3 after.

The library syntax is C<rectstring(w,x)> where C<w> is a C-long integer and
C<x> is a GEN which either represents a vector of ASCII values, or can be
converted into a real number.



=head1 Programming under GP and user-defined functions.



X<programming>



=head2 X<Variables>Variables and symbolic expressions.

In GP you can use up to 256 variable names (up to 65536 on 64-bit 
machines). These names can be any standard identifier names, i.e. they 
must start with a letter and contain only alphanumeric characters. To
avoid confusion with other symbols, you must not 
use non-alphanumeric symbols like '_', 'F<dollar>', or 'C<.>'. In addition to the
function names which you must not use (see the list with C<\>c) there
are exactly three special variable names which you are not allowed to use:
B<pi> and B<euler>, which represent well known constants, but also 
B<i> which is always equal to the square root of C<-1>.

Since usually you are not going to use the variable name C<pi> for anything else but
the number C<F<pi>>, and similarly for C<euler>, these two will not create any problems.
On the other hand, you will have to get used to calling a loop control variable
with a name different from C<i>. We realize that this may initially be the cause for
some confusion, but we do not have any replacement symbol for the square root of C<-1>.

Now the main thing to understand is that PARI/GP is I<not> a symbolic manipulation
package, although it shares some of the functionalities. One of the main consequences
of this fact is that all expressions are evaluated as soon as they are written, they
never stay in a purely abstract form. As an important example, consider what happens
when you use a variable name I<before> assigning a value into it. This is perfectly
acceptable to GP, who considers this variable in fact as a polynomial of degree 1, with
coefficients 1 in degree 1, 0 in degree 0, whose variable is the variable name you used.

If later you assign a value to that variable, the objects which you have created before
will still be considered as polynomials. If you want to obtain their value, use the
function C<eval> (see section 7 above).

Another consequence is that the variables are numbered in the order
that they appear, and the main variable of an expression is always
the lowest numbered variable. Hence if you are working with expressions
involving several variables and want to have them ordered in a specific manner
I<in the internal representation>, the simplest is just to write down the variables
one after the other under GP before starting any real computations.
If you already have started working and want to change the names of the variables
in an object, use the function C<changevar> (see section 2). If you only want
to have them ordered when the result is printed, you can also use the function
C<reorder> (see below).

Finally, note that if C<x> is a vector, you can assign a result to C<x[m]> (i.e. write
something like C<x[k]=expr>). If C<x> is a matrix, you can assign a result to C<x[m,n]>, but I<not> to C<x[m]>, which is a vector. If you want to assign an
expression to the C<m>-th column of a matrix C<x>, use C<x[,m]=expr> instead. Similarly, use C<x[m,]=expr> to assign an expression to the C<m>-th row of C<x>.

% compactarrays(num)=Changes algorithm for assignments to elements of
% arrays and matrices. If 0: assignment of a shorter value will leave a 
% hole speeding up processing. The hole survives until the next operation
% with the whole array.
% Returns old value.



=head2 X<Expression>Expressions and X<expression sequence>expression sequences.

An expression is formed by combining the GP operators, functions (including user-defined
functions) and control statements. It may be preceded by an assignment statement 'C<=>'
into a variable. It always has a value, which can be any PARI object.

Several expressions can be combined on a single line by separating them with semicolons
('C<;>') and also with colons ('C<:>') for those who are used to BASIC. Such an expression
sequence will be called simply a C<seq>. A C<seq> also has a value, which is the value
of the last non-empty expression in the sequence. Under GP, the value of the C<seq> is
always put on the stack (i.e. it will become the next object C<%n>), and only that value.
The values of the other expressions in the C<seq> are discarded after the execution of
the C<seq> is complete, except of course if they were assigned into variables.
In addition, the value of the C<seq> (or of course of an expression if there is only one)
is printed if the line does not end with a semicolon ('C<;>').



=head2 Control statements.

A number of control statements are available under GP. They are simpler and have a
slightly different syntax than their C counterparts, but are quite powerful enough
to write any kind of program. Some of them are specific to GP, since they are made
for number theorists. They are as follows. As usual, C<X> will denote any simple variable
name, and C<seq> will always denote a sequence of expressions, including the empty
sequence.



=item X<for>forC<(X=a,b,seq)>

the formal variable C<X> going from C<a> to C<b>,
the C<seq> is evaluated. Nothing is done if C<aE<gt>b>. C<a> and C<b> must be in C<B<I<R>>>.



=item X<fordiv>fordivC<(n,X,seq)>

the formal variable C<X> ranging through the
positive divisors of C<n>, the sequence C<seq> is evaluated. C<n> must be of type integer.



=item X<forprime>forprimeC<(X=a,b,seq)>

the formal variable C<X> ranging over the prime
numbers between C<a> to C<b> (including C<a> and C<b> if they are prime),
the C<seq> is evaluated. Nothing is done if C<aE<gt>b>. Note that C<a> and C<b>
must be in C<B<I<R>>>.



=item X<forstep>forstepC<(X=a,b,s,seq)>

the formal variable C<X> going from C<a> to
C<b>, in increments of C<s>, the C<seq> is evaluated. Nothing is done if C<sE<gt>0> and 
C<aE<gt>b> or if C<s<0> and C<a<b>. C<a>, C<b> and C<s> must be in C<B<I<R>>>, and C<s> must
be non-zero.



=item X<forvec>forvecC<(X=v,seq)>

C<v> being an C<n>-component vector (where
C<n> is arbitrary) of two-component vectors C<[a_i,b_i]> for C<1E<lt>= iE<lt>= n>,
the seq is evaluated with the formal variable C<x[1]> going from C<a_1>
to C<b_1>,...,C<x[n]> going from C<a_n> to C<b_n>. The formal variable
with the highest index moves the fastest. 



=item X<goto>gotoC<(a)>

C<a> being an integer between 0 and 99, go to the
position in the seq referred to by label C<a>. This can be either a forward skip
or a backwards skip. In case of multiple labels, control is transferred in the
following manner. If one such label is to the left of the goto instruction, 
control is transferred to the rightmost one among those which are to the left.
Otherwise, control is transferred to the rightmost label with a given number.
In any case, multiple labels in a given seq should be avoided. 

Also, good programming practice implies that the 
C<goto> instruction should be used only in special cases, such as getting
out of a deeply nested set of control instructions in one step.
In fact, in the present version 1.39.3, the C<goto> instruction almost always
leads to syntax errors hence should be avoided, except as a means to stop a
program catastrophically without getting out of GP. This may be corrected in a
future release.

Note that usually it is possible to use the C<goto> instruction
with an C<a> which is not an absolute constant, but may vary in the seq
("computed goto").



=item X<if>ifC<(a,seq1,seq2)>

if C<a> is non-zero, the expression sequence C<seq1>
is evaluated, otherwise the expression C<seq2> is evaluated. Of course, C<seq1> or C<seq2>
may be empty, but the syntax must stay the same: C<if(a,seq,)> evaluates C<seq> if
C<a> is not equal to zero, does nothing otherwise; C<if(a,,seq)> evaluates C<seq> if C<a>
is equal to zero, does nothing otherwise.



=item X<label>labelC<(a)>

C<a> being an integer between 0 and 99, label this
position as label number C<a> for use by the C<goto> instruction. Labels
are specific to a given seq.



=item X<until>untilC<(a,seq)>

evaluate expression sequence C<seq> until C<a> is not
equal to 0 (i.e. until C<a> is true). If C<a> is initially not equal to 0, C<seq> is
evaluated once (more generally, the condition on C<a> is tested I<after> execution of
the C<seq>, not before as in C<while>).



=item X<while>whileC<(a,seq)>

while C<a> is non-zero evaluate the expression sequence
C<seq>. The test is made I<before> evaluating the C<seq>, hence in particular if C<a>
is initially equal to zero the C<seq> will not be evaluated at all.





=head2 Specific functions used in GP programming.

In addition to the general PARI functions, it is necessary to have some functions
which will be of use specifically for GP. They are as follows:



=item X<kill>killC<(x)>

kills the present value of the variable or user-defined
function C<x>. After C<kill> of a variable, since the variable does not have a value,
as has been explained above it is again considered as a monic polynomial of degree 1
with no constant term.

For the following four printing functions, C<list> represents a list (separated by
commas) either of PARI objects or of character strings between double quotes
'C<">', which are always printed as they are.



=item X<pprint>pprintC<(list)>

output C<list> in prettyprint (beautified) format,
ending with a newline.



=item X<pprint1>pprint1C<(list)>

output C<list> in prettyprint (beautified) format,
without ending with a newline.



=item X<print>printC<(list)>

output C<list> in raw format, ending with a newline.



=item X<print1>print1C<(list)>

output C<list> in raw format, without ending with a 
newline.



=item X<read>readC<()>

reads a string, interpreted as a GP expression, from
the input file, usually standard input (i.e. the keyboard). If a sequence of
expressions is given, the result is the result of the last expression of the
sequence. When using this instruction, it is useful to prompt for the string
by using the C<print1> function. Note that in the present version 2.12 of
C<pari.el>, when using GP under gnuemacs (see section 11) one I<must>
prompt for the string, with a string which ends with the same prompt as the
current one (usually a 'C<?>').



=item X<reorder>reorderC<(x)>

C<x> must be a vector. If C<x> is the empty vector,
this gives the vector whose components are the existing variables in increasing
order (i.e. in decreasing importance). If C<x> is non-empty, it must be a permutation
of variable names, and this permutation gives a new order of importance of the variables.
For example, if the existing order is C<[x,y,z]>, then after C<reorder([z,x])> the
order of importance of the variables will be C<[z,y,x]>.



=item X<texprint>texprintC<(list)>

outputs C<list> in TeX format. This
output can then be used in a TeX manuscript. 

Warning: in the present version 1.39.3, the printing is done on the standard
output, hence to be able to get the output into a file, you must be either
in an emacs session or shell (see section 11), in a windowing system (which enables
you to grab the output with the mouse), under a UNIX script command, or with
the logfile enabled (see the command C<\>l). This will be improved.






=head2 User defined functions.

It is very easy to define a new function under GP, which can then be used like any other
function. The syntax is as follows:

C<name(list of true formal variables, list of local variables)=seq>

where C<name> is the name that you want to give to your function (same syntactic
restrictions as for variable names). C<list of true formal variables> is the list
of variables corresponding to those which you will actually use when calling your
function, the variables being separated by commas, and the list being allowed to be
empty. C<list of local variables> is the list of the additional local variables
which you will use in the definition of the function. If you omit some or all of these
local variable declarations, the function will probably still work, but the non-declared
variables will become global, hence known outside of the function, and this may have
undesirable side-effects. On the other hand, in some cases it may also be what you
want. Finally, as usual C<seq> is any expression sequence.

Once the function is defined using the above syntax, you can use it like any other
function. In addition, you can also recall its definition exactly as you do for
predefined functions, that is by writing C<?name>. One small difference
with predefined functions is that you can never redefine such a function, while
you can redefine a user-defined function as many times as you want, without using the
C<kill> instruction.

In a given session you can give any identifier name to a function, I<except>
those of predefined functions (of course) but also those of any variables that
have been used, even if they have been killed. On the other hand, if you want
to use as a variable name the name of a user-defined function, it is enough
(and necessary) to kill this function name first.

An amusing example of a user-defined function is the following. It is intended
to illustrate both the use of
user-defined functions and the power of the C<sumalt> function. Although
since version 1.34 the X<Riemann zeta-function>Riemann zeta-function is included in the standard
functions, let us assume that this is not the case (or that we want another
implementation). One way to define it, which is probably the simplest
(but certainly not the most efficient), is as follows:

X<zeta function>
C<zet(s,j)=sumalt(j=1,(-1)^(j-1)*j^(-s))/(1-2^(1-s))>

Then this gives reasonably good accuracy and speed as long as you are not too far
from the domain of convergence. Try it for C<s> integral between C<-5> and C<5>, say,
or for C<s=0.5+i*t> where C<t=14.134...> Of course, the call to the function is
done by C<zet(s)>, the variable C<j> must not be given.



=head2 Special X<editing character>editing characters.

A GP program can of course have more than
one line. Since GP executes your commands as soon as you have finished typing them, there
must be a way to tell it to wait for the next line or lines of input before doing
anything. There are two ways of doing this.

The first one is simply to use the X<backslash character>backslash character 'C<\>' at the end of the
line that you are typing, just before hitting C<<>returnC<E<gt>>. This tells GP that what you
will write on the next line is the physical continuation of what you have just written.
In other words, it makes GP forget your newline character. For example if you use this
while defining a function, and if you ask for the definition of the function using
C<?name>, you will see that your backslash has disappeared and that everything is on
the same line. You can type a C<\> anywhere. It will be interpreted as above
only if it is immediately followed by a newline. For example, you can type

C<3+C<\>>

C<4>

instead of typing C<3+4>.

The second one cannot be used everywhere, but is in general more useful.
It is the use of braces `C<{>' and  `C<}>'.X<brace characters>
When GP sees an opening brace (`C<{>') at the beginning of a line, it
understands that you are writing a program, and newlines will be ignored
(but registered, contrary to when you use a backslash) until you type a 
closing brace `C<}>'. However, there is an important (but easily obeyed) 
restriction: inside an open brace-close brace pair, all newlines must
occur after a semicolon ('C<;>'), i.e. between two expressions forming a
C<seq>.

Of course you can combine the use of backslash and braces.



=head2 The GP/PARI X<programming>programming language.

As we have seen, the GP calculator uses a primitive purely interpreted language.
The structure of this language is in fact more reminiscent of LISP with a functional
notation, C<f(x,y)> rather than C<(f x y)>: all programming constructs,
such as C<if, while,> etc... are functions, and the main loop does not really
execute, but rather evaluates (sequences of) expressions.

Of course, it is by no means a true LISP. Function names are distinct from variable
names: once a name has been used as a variable name, this cannot be changed in the
same session. Predefined function names cannot be used for anything else, and the
number of actual parameters must match the declaration given in the online help.
Identifiers that are used for user-defined functions can be freely redefined for other
functions, or totally forgotten (using C<kill>) and later reused for a variable,
for example.

Each variable has a stack of values, implemented as a linked list. When a new
scope is entered, during a function call,
the value of the actual parameter is pushed on the stack. If the parameter is not
supplied, a special C<0> value called B<X<gnil>gnil> is pushed on the stack
(this value is not printed if it is
returned as the result of a GP expression sequence). Upon exit, the stack decreases.
You can C<kill> a variable, decreasing the stack yourself. This should be used
only at the top level of GP, to undo the effect of an assignment,
not from a function. However, the stack has a bottom:
the value of a variable is the monomial of degree 1 in
this variable, as is natural for a mathematician.

Note that the iterative constructs which use a variable name (C<for, fordiv,
forprime, prod, sum, vector, matrix, plot,> etc.) also consider the given
variable to be local to the construct. A value is pushed on entry and pulled on
exit. So, it is not necessary for a function using such a construct to declare
the variable as a dummy formal parameter. In particular, in our C<zet>
example above, the variable C<j> need not be declared.

Otherwise, it is strongly recommended to declare in this way all other variables that are used
inside a function: If a function accesses a variable which is not one of its
formal parameters, the value used will be the one which happens to be on top of
the stack at the time of the call. This could be a ``global'' value, or a local
value belonging to any function higher in the call chain. So, be warned.

B<Implementation note.> For the curious reader, here is how these stacks are
handled: a X<hashing function>hashing function is computed from the identifier, and used as an
index in C<X<hashtable>hashtable>, a table of pointers. Each of these pointers begins
a linked list of structures (type C<X<entree>entree>). The linked list is searched
linearly for the identifier (each list will have less than 7 components or
so). When the correct C<entree> is found, it points to the top of the
stack of values for that identifier if it is a variable, to the function
itself if it is a predefined function, and to a copy of the text of the
function if it is a user-defined function. When an error occurs, all of this
maze (rather a tree, in fact) is searched and (hopefully) replaced in the
situation preceding the last call of the main evaluator.



=head1 Using GP under X<gnuemacs>gnuemacs.



Thanks to the initial help of Annette Hoffman from the University of
Saarbr\"ucken, but now since version 1.34.05 thanks to David Carlisle
from the University of Manchester, it is possible and in fact desirable
to use GP as a subprocess of gnuemacs. This is of course possible only 
if gnuemacs has been installed on your machine.

To use this, you must include in your C<.emacs> file the following line:

C<(load "X<pari>pari" nil t)>

where C<pari.el> is the name of the file that will have to be loaded by gnuemacs
(if you have changed the name, or if you have the file in a different directory, you
must of course supply the correct name). This file is included in the PARI distribution.

Once this is done, under gnuemacs if you type C<M-x gp> (where as usual M is the
Meta key, i.e. Escape, or on SUN keyboards, the Left key), a special shell
will be started, which in particular launches GP with the default stack size,
prime limit and input buffer size. If you type instead C<C-u M-x gp>,
you will be asked for the name of the GP executable, the stack size, the prime limit
and the input buffer size before the execution of GP begins. If for any of these
you simply type return, the default value will be used (on UNIX machines it will be
C</usr/local/bin/gp> for the executable, 4000000 for the stack, 500000 for the
prime limit and 30000 for the buffer size).



You can then work as usual under GP, but with two notable advantages.
First and foremost, you have at your
disposal all the facilities of a text editor like emacs, in particular for
correcting or copying blocks. Second, you can have an on-line help which is
much more complete than what you obtain by typing C<?name>.
This is done by typing M-? (where M is the Meta key). In the minibuffer,
emacs asks what function you want to describe, and after your reply you obtain
the description which is in the users manual, including the description of
functions (such as C<\>, C<%>) which use special symbols.

This help system can also be menu-driven, by using the command C<M-\char`\ c>
which opens a help menu window which enables you to choose the category
of commands for which you want an explanation.

Finally you can use command completion in the following way. After the prompt,
type the first few letters of the command, then M-TAB where TAB is the TAB key
(of course not the letters T,A,B). If there exists a unique command starting
with the letters you have typed, the command name will be completed. If not,
either the list of commands starting with the letters you typed will be
displayed in a separate window (which you can then kill by typing as usual
C-x 1 or by typing in more letters), or ``no match found'' will be displayed
in the Emacs command line.



You also have at your disposal a few other commands. Read the file
pari.txt for details.

Note that if for some reason the session crashes (due to a bug in your program
or in the PARI system), you will usually stay under emacs, but the GP buffer
will be killed. To recover it, simply type again M-x gp (or C-u M-x gp), and
a new session of GP will be started after the old one, so you can recover
what you have typed. Note that this will of course I<not> work if for some
reason you exited emacs before coming back (except for the C-z temporary
stopping command).

B<Remark>. Thanks to Ilya Zakhharevitch, there is a possibility
of command name completion outside of an emacs buffer by using the
TAB character. This can also give very primitive help on the necessary
syntax.

        
