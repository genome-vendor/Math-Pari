Changes to the 1.31.2 version
1) trans2.c: mppsi: replace a=mplog(affsr... by:
  affsr(x,a=cgetr(l));a=mplog(a);
2) gen1.c: gadd: type 2+ type 4: replace signe(y) by signe(y[1]).
3) gen1.c: gadd: type 10+ type 11: after if(gcmp0(x)) ... else { replace by:
  i=signe(y)?valp(y)+ly-gval(x,vx):valp(y)+3-gval(x,vx);
  if(i<3) z=gcopy(y);else { same as before }
4) gen2.c: gpui: replace long m by unsigned long m.
5) mp.c: addir: replace lgef(x)-expo(y)>>5 by lgef(x)-(expo(y)>>5).
6) mp.c: addrr: towards the end, after if(m) { k=0;... replace
  for(i=lp1-1;... by for(i=lp1-1-j;...
7) mp.c: cgetg: replace x*4 by ((unsigned short x)<<2).
8) mp.c: dvmdii: after if((long)z==0xffffffff){...} replace p1[1]=... by
  if(lx!=(dec+2)) {p1[1]=p1[0];setsigne(p1,sy);} else {avma=av;p1=gzero;}
9) mp.c: dvmdii: later, replace p3[1]=p3[0] by
  if(lg(p3)<3) p3[1]=2;else {p3[1]=p3[0];setsigne(p3,sy);}
10) usersch3.tex: in numer, replace the library syntax denom by numer.
11) usersch3.tex: replace additionnal by additional.
12) usersch4.tex: replace lint ar by {\tt lint} at.
13) Changed slighly the README and INSTALLATION files.
14) trans1.c: transc: case 13,14: replace varn(x) by gvar(x).

Changes to the 1.31.3 version
15) mp.c: divrr: towards the middle, replace if(z[i]==si) {qp=0xffffffff;
    addll(si,z[i+1]);} by
    if(z[i]==si) {qp=0xffffffff;k=addll(si,z[i+1]);} (the only change is the
    k= in front of addll).
16) mp.c: mulrr: line 3 after declarations,
    replace z=cgetr(3);z[2]=0;z[1]=e+0x800000;return z; by
    z=cgetr(3);z[2]=0;z[1]=e;return z;
17) In gen1.c, write code to allow type 3 by type 6 or 8 operations.
    Specifically:
    gadd, case 3+case 6 and 8:
      case 6 : z=cgetg(ly,ty);z[2]=lcopy(y[2]);z[1]=ladd(x,y[1]);break;
      case 8 : z=cgetg(ly,ty);z[1]=y[1];z[3]=lcopy(y[3]);z[2]=ladd(x,y[2]);
	break;
    gmul, case 3*case 6 and 8:
      case 6 : z=cgetg(ly,ty);z[1]=lmul(x,y[1]);z[2]=lmul(x,y[2]);break;
      case 8 : z=cgetg(ly,ty);z[1]=y[1];z[2]=lmul(x,y[2]);z[3]=lmul(x,y[3]);
	break;
    gdiv, case 6/case 3: fall through with cases 1,2,4,5.

Changes to the 1.31.4 version
18) In gen1.c, gdiv: type 1/type 6 falls through with type 1/type 8;
    repeat the same code for type 3/type 6 and 8.
19) In gen1.c, gdiv: case 8/case 3: fall through with cases 1,4,5
    instead of falling through with case 7.
20) Corrected a few misprints and details in the manual.
21) In mp.c, affsi: replace if(!s) x[1]=2; by
    if(!s) {x[1]=2;return;}
22) In arith.c, isprime and ispsp: add after {: long av=avma;x=gabs(x);
    and before each of the three returns, add avma=av (and put {} after
    the first 2 ifs).
23) trans3.c: written agm().
24) bibli2.c: written initell(),coordch(),pointch(),hell(),ordell(),
    oncurve(),powell(),addell(),subell(),matell().
25) gp.c changed version number to 1.32.
26) arith.c: classno, declare a long k2, and in the two lines following
    if(tabla[j2]==k) {, replace k by k2 (3 times) (but leave tabla[j2]==k).
27) in erreurs.h and messages.c, added the three error messages initeler1,
    initeler2, heller1.
28) written forprime().
29) In gen1.c: gmul, case 1*case 7, start with if(signe(x)) {...} and before
    the break add else z=gzero;. Similarly in case 4,5*case 7, except that 
    one starts with if(signe(x[1])) instead. Similarly again in gdiv,
    for case 1/case 7 and case 4,5/case 7. Finally, in gen3.c: gmulsg,
    similarly but starting with if(s) instead of if(signe(x)).
30) In init.c: err, added talker, which simply prints the message.
    Made the corresponding changes in messages.c and erreurs.h.
31) In arith.c: classno, insert lines to check for stack overflow
    (limite etc...)
32) In bibli1.c: lllgram, replace p2=x at the beginning by p2=gcopy(x).
33) Wrote issquarefree(),isfundamental().
34) Added a few error messages.
35) Unified the genpari.h files for the different versions. We need now
    gencom.h, containing all the common declarations, and which in principle
    is now the only file to change when a new function is added. Then
    gen68k.h, containing the 680x0 specific declarations, genport.h for the
    others. Finally, genpari68k.h and genpariother.h are simply 3 includes.
36) Updated the manual for version 1.32.
37) trans1.c: transc, output an error message for type 16.
38) trans3.c: slight cleanup of polylog functions, but no corrected bugs.
39) mp.c: in most places where a C-integer is involved (divsi, modsi, etc...)
    add hiremainder=0; before execution of divll(). This is was a severe bug
    of the portable versions.
40) More changes in the manual, and explanations of the polylog functions.
41) polarit.c: squff, replace p1=gadd(gabs(a[da+2],4),... by
    p1=gadd(p2=gabs(a[da+2],4),... and 3 lines later, replace a[da+2] by p2.
42) bibli2.c: wrote zell(), addsell(), powsell(), apell2().
43) Polished and rewrote kronecker(),krogs() and kross().
44) Wrote apell().
45) Wrote glogagm(),theta(),thetanullk().
46) mp.c: cmpir, change lgef(y) into lg(y).
47) In many places, replace gerepile(,,0)/4 by gerepile(,,0)>>2, and before
    adding displacement, check if pointer is universal or not.
48) trans2.c: hyperu, after if(ex) {y=cgetg(3,6)...}, add:
    else y=cgetr(l);
49) gen3.c: gsubst, case 11,case 10,13,14, after the else, replace
    e=gval(y,v) by e=gvar(y,gvar(y));
    three lines after, replace else p1=taylor(y,v,l); by
    else p1=gdiv(greffe(y[1],l),greffe(y[2],l));
50) gen3.c: gsubst, case 11, case 11 vx=vy, 10 line addition in case
    vy!=vx.
51) gen3.c: precision, replace if((tx=typ(x))==2)... by
    if (tx==2) return signe(x) ? lg(x) : 2-(expo(x)>>5);
    and add tx=typ(x) in declaration.
52) arith.c: sfcont, case 13,14 change definition of l1, and at the end copy
    y to vector of correct length.
53) es.c: sori and bruti, add a default printing the codeword in hex:
    break;default: printf("08x  ",*g);
54) mp.c: affir,shifti,mulsr, test whether shift is zero.
55) mp.c: divrs, replace z[lx-1]=shiftl... by
    shiftl(garde,sh);k=hiremainder; and start for loop at i=lx-1.
56) mp.c: rtodbl, replace exp2(ex-co) by exp2(ex+1-co).
57) mp.c: gerepile!!! Finally found the two year old bug. Needs change if 
    typ(ll)==10, and also when the GEN after l is not complete.
58) mp.s: same of course.
59) arith.c: divisors, change gerepile(tetpil,av,... into gerepile(av,tetpil,.
60) bibli1.c: tayl, between p1[vx+1]=lpolx[v]; and p1[v+1]=lpolx[vx]; insert
    for(i=vx+1;i<v;i++) p1[i+1]=lpolx[i];
61) changevar() available under gp.
62) mp.c: modis, change return (y>0) .... to
    return (signe(x)>0) ? stoi(hiremainder) : stoi(abs(y)+hiremainder);
63) polarit.c: polgcd, set gcd > 0 in case of type 1,2,4,5.
64) polarit.c: with code from R. Schroeppel, finished writing factpol, hence
    factor.
65) updated the manual.

Release version of pari-1.32

-------------------------------------------------------------------------------
	
Retour en France et au francais.

1) bibli2.c: remplace les occurences de lint par qlint
2) gencom.h: ajoute #undef PI avant le #define PI
3) mp.c: itos(), remplacer -p1 par -((long)p1)
         et dans divss(), resss(),divsi(),divis() remplacer -hiremainder par
         -((long)hiremainder)
4) trans3.c: wf(), enlever les ,prec aux 2 appels de inteta.
5) bibli2.c: subsell(), remplacer addsell(z1,zp) par addsell(e,z1,zp), et idem dans
   subell(), remplacer addell(z1,zp) par addell(e,z1,zp).
6) gen2.c: gaffect() case 7-->case 3, remplacer val=pvaluation(y[1],&p1); par
   val=pvaluation(y[1],x[2],&p1);
7) versionsparc.c et versionport.c: divll(), enlever les (ulong) devant
   hiremainder.
8) mp.c: divss(), remplacer abs(x),abs(y) par (ulong)abs(x),(ulong)abs(y).
9) trans2.c: mpgamdz(), remplacer p1=mpgamd(s) par p1=mpgamd(s,l).
10) trans2.c: gach(), remplacer y=glog(p1) par y=glog(p1,prec).
11) trans2.c: eint1(), remplacer mplog(x,prec) par mplog(x) et mpexp(gneg(x),prec)
    par mplog(negr(x)).
12) arith.c: fin de classno2(), la ligne commencant par p5=addrr... enlever le ,4 final.
13) trans1.c: transc(), remplacer roots(x[1]) par roots(x[1],prec).
14) gen2.c: gaffect(), case 10--> case 12, remplacer gmod(x,y[1],y[2]) par
    gmodz(x,y[1],y[2]).
15) arith.c: isprime() et ispsp(), rajouter au debut if(typ(x)!=1) err(arither1); et
    remplacer x=gabs(x) par x=absi(x).
16) arith.c: kro8(), remplacer gmul(p2,p2)-gmul2n(... par gmul(p2,p2),gmul2n(... 
    et mettre au debut av=avma et a la fin avant le return avma=av.
17) gen3.c: deriv(), remplacer ggrando(polx[vx],vx,e+lx-2) par ggrando(polx[vx],e+lx-2).
18) trans3.c: polylog(), remplacer gnorm(x,prec) par gnorm(x).
19) alglin.c: caract(), if(tx==12) remplacer caract(p2) par caract(p2,v).
20) bibli1.c: lindep(), fin, remplacer gtrans(p4,p3) par gtrans(p4).
21) mp.c: addrr(), dans le else avant if(sx==sy), ajouter m=0; apres
    flag=2;p2=x;
22) mp.c: dvmdii(), dans le if(p1[i]==si), remplacer addll(si,p1[i+1])
    par k=addll(si,p1[i+1]).
23) changements de nature cosmetiques dans differents programmes.
24) alglin.c: gnorml2(), commencer par y=gzero; puis if(lx>1)
    mettre av=avma;y=gnorm(x[1]);et remplacer y=gerepile... par
    if(lx>2) y=gerepile.
25) gen3.c: gdivmod(), remplacer else(gdivmoder) par 
    else err(gdivmoder).
26) gp.c: changer *tch=='\{' en *tch=='{'

Chargement Mac par Dominique

-----------------------------------------------

27) Dans example, mattrans.c, changer gscalmat(r,lx) en gscalmat(r,lx-1).
28) Inclut dans la version 1.32 les programmes keri() et kerr() de C. Batut,
    et modifie le manuel en consequence.
29) polarit.c: squff, remplace gsqrt(p1,4) par gaddsg(1,racine(p1)), et enlever
    le gfloor.
30) init.c: catchinterrupt(), ajoute signal(SIGINT,catchinterrupt) avant err().
31) polarit.c: factmod(), ajoute else err(impl,"factmod for p>=2^31"); apres
    psim=itos(p);
32) bibli2.c: dans forprime() et prodeuler(), remplacer
    while(gcmpgs(a,prime)>0) prime+= *p++; par
    while((*p)&&gcmpgs(a,prime)>0) prime+= *p++;if(!*p) err(recprimer);
33) Ajoute un ; juste avant le \ de l'avant derniere ligne de Makefile.port.
34) polarit.c: a plusieurs endroits (factmod et squff), remplace gmodulo par
    gmodulcp.
35) bibli1.c: ecrit ordred(). 
36) gencom.h: change MAXBLOC de 1000 a 5000.
37) bibli2.c: fordiv(), ajouter killvalue(ep) avant le return gnil.
38) polarit.c: split(), remplacer av=avma;if(p==2) par
      av=avma;
      if(p==2)
	{
	  w=gmul(gpuigs(polx[v],m-1),unmodp);m+=2;
	  for(w0=w,j=1;j<d;j++) w=gmod(gadd(w0,gmul(w,w)),*t);
	}
      else
	{
	  w=gmul(stopoly(m++,p,v),unmodp);
	  wm=gpui(gmodulo(w,*t),q);w=gsub(*(wm+2),unmodp);
	}
39) polarit.c: factmod(), apres else av=avma (ligne 5 executable) mettre
    if(lgef(f)==3) {avma=av;y=cgetg(3,19);y[1]=lgetg(1,18);y[2]=lgetg(1,18);return y;}
40) gen1.c: gmul(), enleve un printf de debuggage oublie.

disquette dominique (pas encore la 1.32.2 definitive)

----------------------------------------------------------------------

41) ajoute kerreel
42) ajoute apell1, optimisation pour p < 2^30
43) supprime les #ifdef macintosh de init.c et messages.c, il n'en reste
    plus que dans plot.c et gp.c
44) ajoute genparimac.h et Makefile.mac pour uniformiser la distribution
45) supprime 24 declarations de variables locales inutilisees.
46) bibli2.c: interverti apell() et apell1().
47) gen3.c: modifie gmodulo() et gmodulcp() pour qu'ils acceptent
    mod(scalaire,polynome).
48) polarit.c: modifie content() pour qu'il accepte n'importe quel type, et
    dans anal.c et message.c, appel a content() possible de gp.
49) mp.s et mp.c: expi rendait toujours 1 de trop. Soustraire 1 avant de partir.
50) es.c: sori(), corrige la sortie du type 12: pas de test signe(g[2])<0.
51) polarit.c: ggcd() case 1, case 3, remplacer if(!gcmp1(z)) par if(!gcmp1(p1)).
52) polarit.c: squff() a deux endroits, remplacer pro&0xffff+rem par (pro&0xffff)+rem.
53) polarit.c: squff() remplacer GEN tabd[NOMDEP][30] par GEN tabd[NOMBDEP][500] (ou mieux
    faire une allocation dynamique).
54) alglin.c : Dans kerreel,eigen,jacobi remplacer
           affsr(1,eps=cgetr(prec)) ou affsr(0,eps=cgetr(prec));
    par :
	eps=cgetr(3);eps[2]=0x80000000;eps[1]=0x01800010-((prec-2)<<5);
    Ajouter le parametre prec dans kerreel et eigen.
    Dans eigen() : remplacer ssesp=kerreel(z) Par : ssesp=kerreel(z,prec)
55) arith.c: classno() rajouter au debut (avant les hash) 
  if(gcmpgs(x,12)<=0) return gun;
  et deplacer le test x=0 ou 3 mod 4 au debut.
56) trans3.c: sagm(), remplacer while(ep<pp) par
  while((ep<pp)&&(!gcmp0(p1))).
57) top,bot et avma sont maintenant definis dans init.c. Les reservations
  de memoire dans mp.s, sparc.s et versionport.c pour
  ces trois variables sont supprimees.
58) corrige quelques typos dans le manuel.
59) ecrit les fonctions gtoser() (series dans gp) et gtopoly() (poly dans gp),
  et decrit leur fonction dans le manuel.
60) ecrit gtovec() (vec dans gp) et manuel.
61) bibli2.c: ordell() change if(signe(d)) en if(!gcmp0(d)).
    et p3=gsub(gsqrt(d,prec),p2) en p3=gsqrt(d,prec).
    et elimine le message d'erreur au cas ou il n'y a pas de point
    mod p.
62) bibli2.c: powsell1(), ajouter la declaration du parametre formel
   long n!!.
63) bibli2.c: apell(), trouve la bug 1439. Declarer une variable sellpt f2;
    puis remplacer la ligne if(bcon>1) powssell1(cp4,p,bcon,&f,&f); par
    if(bcon>1) powssell1(cp4,p,bcon,&f,&f2);else f2=f;
    ensuite 12 lignes plus loin remplacer addsell1(cp4,p,&fh,&f,&fh) par
    addsell1(cp4,p,&fh,&f2,&fh), et idem 3 lignes plus loin remplacer 
    powssell(cp4,p,s,&f,&fg) par powssell1(cp4,p,s,&f2,&fg). Par contre, laisser
    le powssell1(cp4,p,p3,&f,&fh) apres trouve (c'etait justement ca la bug: f etait
    detruit, on utilise donc provisoirement f2).

Prerelease de la version 1.33 (en attente de confirmation Bernardi).

64) mp.s (si si!) gerepile (encore!): remplacer le bhi 8$ qui se trouve juste avant
    movl #gerper,sp@- par un bhi 4$.
65) Simplification de la fonction divmod, declaree statique dans bibli2.c
66) Reecriture mpfact, 25% plus rapide sur 5000!.
67) Ajout d'un paragraphe et d'une reference a install dans usersch4.tex
68) typo dans usersch4.tex

Version 1.33 definitive, le 13/6/90 a 0h.

----------------------------------------------------------------------

69) Change le library mode de hermite a hnf.
70) Introduit la commande \v (version).
71) bibli2.c: sumalt(): remplacer if(gexpo(p1)<... par if(gcmp0(p1)||(gexpo(p1)<...
72) trans2.c: gacos() et gach(): remplacer setvalp(y,0) par setexpo(y,0).
73) polarit.c: factor(), dans le if(gcmp0(x)) remplacer y=cgetg(2,19) par
    y=cgetg(3,19).
74) gen1.c: gadd() case 11+ case 13,14 remplacer if(lz<1) par if(lz<3).
75) anal.c, messages.c, gencom.h, trans3.c, usersch3.tex: modifications assez
    profondes de tout ce qui concerne les polylogarithmes, sauf polylog
    lui-meme. En particulier, suppression des fonctions dm2, dm3, dst3, trilog
    (conserve dilog), modification de dm (qui s'appelle maintenant polylogd),
    et ecriture de polylogp.
76) trans2.c: dans les commentaires de mpbern() et bernvec(), changer nomb en
    2*nomb.
77) bibli2.c: plot(), ajouter un printf("\n"); avant et apres le trace.
78) gen1.c: gmul() type 11*type 11: remplacer tout par:
        case 11: if(lx>ly) {k=ly;ly=lx;lx=k;p1=y;y=x;x=p1;}
        if (gcmp0(x)||gcmp0(y))
          {
	    z=cgetg(3,11);
	    z[1]=0x8000+valp(x)+valp(y);
	    setvarn(z,vx);
          }
        else
          {
	    l=avma;p1=cgeti(lx);z=cgetg(lx,ty);
	    setvalp(z,valp(x)+valp(y));setvarn(z,vx);setsigne(z,1);
	    for (i=2;i<lx;i++)
	      {
		p1[i]=!gcmp0(y[i]);z[i]=p1[i]?lmul(x[2],y[i]):zero;
	      }
	    for(i=3;i<lx;i++)
	      if(!gcmp0(x[i]))
		for(j=2;j<=lx+1-i;j++)
		  if(p1[j]) z[i+j-2]=ladd(z[i+j-2],gmul(x[i],y[j]));
	    tetpil=avma;z=gerepile(l,tetpil,gcopy(z));
	    normalize(&z);
          }
        break;
  Ceci ameliore considerablement (d'un facteur 2 a 20 parfois) la
  multiplication de deux series.
79) trans3.c: ecrit jbesselh(), version primitive (a ameliorer quand l'argument
    est proche de zero).
80) anal.c: change la definition de mod() en gmodulcp, et ajoute modp() qui est
    l'ancien mod(), i.e. qui cree un nouveau bloc.
81) gen1.c: ameliore la division case 11/case 11 en testant des le debut les zeros
    du diviseur.
82) trans2.c: ecrit cxgamma() et cxpsi(), et fait quelques modifs de 
    presentation dans mppsi() et mpgamma().
83) bibli2.c: ecrit forstep(), et modifie forpari() pour qu'ils acceptent des
    bornes non entieres. Ajoute des messages d'erreur.
84) arith.c: classno(), replace if(gcmpgs(x,12)<=0) by if(gcmpgs(x,-12)>=0).
85) bibli2.c: les modifs (83) de forstep et forpari etaient fausses. Les remplacer par
    la nouvelle version.
86) plot.c: ecrit ploth2(). 
87) arith.c: commence a ecrire nucomp() (ne pas utiliser).
88) Ajoute anell() (ou ca?)
89) Jacobi entierement re-ecrit
90) dans eigen remplacer rr=roots(p,5) par : rr=roots(p,prec) 
91) dans sqred2 ajouter :   if (typ(a)!=19) err(kerer1);

-----------

Le 21/8/90

92) alglin.c: gtrans(), case 19 remplacer lx=lg(x) par
    if((lx=lg(x))==1) return cgetg(1,19).
93) polarit.c: subres(): remplacer if(dy==3) return gun;av=avma;/*p3=...*/ p3=gun;p4=gun; par
    av=avma;p4=content(y);
    if(dy==3) {tetpil=avma;return gerepile(av,tetpil,gpuigs(p4,dx-3));}
    p3=content(x); /*p3=gun;p4=gun; */.
    Ensuite, remplacer if(varn(x)!=varn(y)) return gun; par
    if(varn(x)!=varn(y))
      return (varn(x)<varn(y))?gpuigs(y,lgef(x)-3):gpuigs(lgef(y)-3);
    Enfin, remplacer if((tx<10)||(ty<10)) return gun par
    if((tx<10)||(ty<10))
      {
        if(tx==10) return gpuigs(y,lgef(x)-3);
        if(ty==10) return gpuigs(x,lgef(y)-3);
        else return gun;
      }.
94) alglin.c: greal() et gimag() case 13 et case 14 ne doivent pas etre traites
    comme types vect/mat. Declarer GEN p1, p2 et long tetpil au debut, et apres
    case 14 mettre
dans greal():
    av=avma;p1=gadd(gmul(greal(x[1]),greal(x[2])),gmul(gimag(x[1]),gimag(x[2])));
    p2=gadd(gsqr(greal(x[2])),gsqr(gimag(x[2])));tetpil=avma;
    z=gerepile(av,tetpil,gdiv(p1,p2));break;
dans gimag():
    av=avma;p1=gsub(gmul(gimag(x[1]),greal(x[2])),gmul(greal(x[1]),gimag(x[2])));
    p2=gadd(gsqr(greal(x[2])),gsqr(gimag(x[2])));tetpil=avma;
    z=gerepile(av,tetpil,gdiv(p1,p2));break;
95) mp.c: mpent() remplacer les & dans les deux while par des
   &&. Puis, mettre les5 lignes allant de for(i=d+2;(i>=2)&&...
   jusqu'a } a l'interieur de if(f){ ... }.
96) Supprimer des affectations de variables inutiles:
  alglin.c gauss() (av), rank (y). arith.c mpsqrtmod() (av2)
  regula() (p4). bibli1.c lll() (dx). bibli2.c initell() (r0)
  apell1() (av2) hell() (w). mp.c mulir() (lx) modss() (p1).
  trans1.c gexp() (tx) mpsc1() (l3) mpsincos() (l).
  trans2.c kbessel() et hyperu() (lbin2). trans3.c sagm() (tx)
  jbesselh() (p3).
97) gen3.c truecoeff() mettre des {} autour du if..;else.
98) plotdummy.c rajouter return gnil dans les deux fonctions.
99) trans2.c (et anal.c, gencom.h, messages.c) ecrit gzeta().
100) Mis a jour le manuel.
(Version 1.34 devrait etre prete bientot)
101) reecrit gzeta() avec estimation rigoureuse de l'erreur.
102) (C. Batut) reecrit lll et lllgram. C'est beaucoup plus stable.
103) Ecrit la division sparc 64/32 -> 32,32. Cela gagne environ 20%
   sur une sparcstation.
104) Inclus un fichier mp.asm qui devrait etre la copie conforme de
    mp.s mais avec une syntaxe plus standard.
105) bug dans bibli2: addell() , ligne 10, remplacer gadd(e[4],gmul(x1,...
   par gadd(gsub(e[4],gmul(e[1],y1)),gmul(x1,...
106) gen2.c: reecrit completement la fonction gval(), qui est
   maintenant une macro de la fonction ggval utlisable tres generalement
   et appelable par la fonction valuation() sous GP.
   au passage, ecrit une fonction poldivis(), analogue de mpdivis mais
   pour les polynomes.
107) arith.c: primeform(), supprimer la ligne if(gcmp0(b)) err(sqrter5);

------ Disquette envoyee a Dominique le 4/10/90 a 12h

108) base.c: hnf() inclus du code pour eviter les debordements de pile:
    long lim=(avma+bot)>>1; au debut, puis juste avant l'accolade fermante du
    for(i=li-1;i>=1;i--), mettre:
    if(avma<lim) {tetpil=avma;y=gerepile(av,tetpil,gcopy(y));}
109) (suite de 103) Grace a l'aide de Dik Winter, ameliore encore de
   15% la division 64/32 sparc (sparc.s).
110) Enleve quelques variables inutilement declarees (sauf dans 
   nucomp qui est en cours d'ecriture).
111) Ecrit ploth2 pour mac et XWindows. Remanie le Makefile.sun3 en y ajoutant
    les remarques pour construire la version XWindows. Utilisation forcee de cc
    pour assembler mp.s . Suppression des ifdef dans plot.sun. plot.c est supprime
    ce n'est plus qu'un lien vers plot.sun ou bien plot.X
112) Bug mod(3,5)*mod(3,5): dans gen1.c, partout ou il y a des affectations z[1]=x[1]
    ou z[1]=y[1] correspondant aux types 3, 8 ou 12, remplacer par z[1]=copyifstack(x[1])
    (resp. y[1]). Dans gen2.c, gcopy(), quand i est entre lontyp[tx] et lontyp2[tx],
    remplacer y[i]=x[i] par y[i]=copyifstack(x[i]). Dans gencom.h, declarer 
    extern GEN RAVYZARC, modifier la macro isonstack, et rajouter la macro copyifstack
    comme suit:

   #define isonstack(x)   (RAVYZARC=(GEN)(x),((RAVYZARC>=(GEN)bot)&&(RAVYZARC<(GEN)top)))
   #define copyifstack(x) (RAVYZARC=(GEN)(x),((RAVYZARC>=(GEN)bot)&&(RAVYZARC<(GEN)top))?lcopy(RAVYZARC):(long)RAVYZARC)
   Enfin, dans init.c, declarer GEN RAVYZARC dans la liste des variables globales communes.
113) Remanie les Makefiles.
114) Suite de 112: dans gen2.c, gneg() et gpuigs() meme modifs.
   (J'espere que je n'en ai pas rate d'autres).
115) Inclus une gestion de pile (preserve) dans lll et programmes
   associes, ce qui fait que lll peut traiter de grandes matrices
   sans overflow.
116) base.c: Ecrit smith(), reduction de Smith.
117) Suite de 112 et 114. Encore meme modifs dans gen1.c, gen3.c, alglin.c.
118) gen3.c: ground() et grndtoi() case 19 remplacer dans le premier for, y[1]=x[1]
    par y[i]=x[i] (ca a le meme effet mais c'est plus logique).

Le 16/10/90 release de la version 1.34 beta

119) Encore des modifs comme 112 oublies, y compris en sens inverse (i.e. des z[1]=lcopy a
    remplacer par z[1]=copyifstack dans certains cas.
120) gen1.c, gmul() case 7* case 8, remplacer cgetg(3,8) par cgetg(4,8).
121) alglin.c, messages.c, anal.c, gencom.h. ecrit les fonction detreel (detr sous gp),
     invmulmatreel(), invmatreel() (matinvr sous gp).
122) gen3.c: gmul2n, enlever case 8 des cases 10,6,11,... et remplacer par
     case 8 : y=cgetg(lx,tx);y[1]=copyifstack(x[1]);for(i=2;i<lx;i++) y[i]=lmul2n(x[i],n);
     break;
123) gen3.c: gdiventres, nettoyage: remplacer deux fois des copy de zero par zero.
124) trans1.c: mpcs1(), remplacer alpha=gcmp0(p1) ? ... par
      if(gcmp0(p1)) alpha=1000000.0;
      else {m=expo(p1);alpha=(m< -1023) ? -1-m*LOG2 : -1-log(fabs(rtodbl(p1)));}
125) mp.c: modifier le code de rtodbl() pour que l'on renvoie 0.0 au lieu d'une erreur
     en cas d'underflow: remplacer la premiere ligne par
     if((!s)||((ex=expo(x))< -1023)) return 0.0; et supprimer le ex=expo(x) qui suit.
126) supprime rtodbl() et dbltor() de mp.s, genport.h, et deplace de mp.c a gen2.c.
     Inclus les declarations dans gencom.h. Le patch mac n'est plus necessaire.


Release internationale de la version 1.34
____________________________________________________________________________________

Numerotation recommence a 1.

1) gen2.c: gneg(), mettre un message d'erreur en cas de negation d'une forme quadratique.
2) es.c: sori(), changer if ((typy>2)&&(typy<17)) en
         if ((typy>2)&&(typy<15))
3) gen3.c: ginv() changer typ==9 en typ==16.
4) ajoute la fonction anell() qui avait disparue (???).
5) Mis un peu partout le type 15 (formes quadratiques de discriminant >0). Desole Dominique,
   on enlevera 15 et 16 si cela devient genant.
6) bibli1.c: ecrit minim().
7) polarit.c: factmod() vers la fin remplacer t[1]=gcopy(t[1]) par
   t[1]=gdiv(t[1],((GEN)t[1])[lgef(t[1])-1])
   et mettre la ligne commencant par "if (expos[j]) t[j]=...."
   juste avant la ligne "for(k=1;k<j....".
8) base.c: ecrit une nouvelle version de hnf(), a priori meilleure.
9) Makefile.sun3: remplacer 8 blancs avant cc ... mp.s par un TAB.
10) gp.c: infile() et outfile(), traiter correctement le cas ou on ne peut pas ouvrir un
   fichier.
11) gp.c: rajouter la reinitialisation du prompt a "? " (ou "?\ " pour le mac) en cas de \k.
12) BUG IMPORTANTE POUR LA VERSION PORT: dans versionport.c, divll() remplacer
    else{dbl-=(C4/2);p=(ulong)dbl;p|=0x80000000;} par:

  else
    {
      if(dbl>=C4) p=0xffffffff;
      else{dbl-=(C4/2);p=(ulong)dbl;p|=0x80000000;}
    }
13) bugs dans lllgram
 ajouter errger2 (matrice non carree)
 et errger3 (matrice non definie)
14) gen2.c: gpui() exponentiation des series incorrectes ; corrections faites.
15) gp.c: rajouter un blanc en cas de changement de prompt.
16) gen3.c recip() remplacer y[i]=y[i]+decal par
    if(y[i]<av6) y[i]+=decal
    et u[k]=u[k]+decal par u[k]+=decal
17) Gros changements dus a Dominique pour traiter plus correctement les
    entrees-sorties, en particulier dans es.c et gp.c.
18) Un grand nombre de fonctions void declarees explicitement void.
19) Remplacement du pari.el de A. Hoffmann par celui de David Carlisle.
20) gen3.c: gfloor() remplacer signe(x) par gsigne(x).
21) trans1.c: gsqrt() case 3: remplacer y[1]=x[1] par
    y[1]=copyifstack(x[1]).
22) bibli1.c: gprec() case 7: changer y[4]=lcopy(x[4]) par
    y[4]=lmodii(x[4],y[3]).
23) bibli1.c: ecrit gconvpe() (conversion p-adique--> entier ou rationnel)
    et incorpore dans trunc.
24) corrige divers bugs dans gp.c
25) gencom.h: ajoute les macros mulri et lmulri.
26) gp.c: apres unused characters... ajoute pariputc('\n').
27) Version 2.4 de pari.el.
28) gen2.c: ggval() case 19: remplacer val=0 par val=2147483647.
29) gen2.c: ggval() case 10 et 11: modifier pour autoriser la valuation p-adique
    d'un polynome/serie, et corrige le case 11.
30) polarit.c: ecrit sturmpart() (et modifie les autres fichiers en consequence).
31) Change le decoupage de trans2.c et trans3.c, coupe en deux alglin.c, arith.c
    et polarit.c, et change les Makefiles.
32) Remplace tous les gmodulo restants (dans polarit1.c et arith1.c) par des gmodulcp.
33) Enleve tous les talker restants et remplace par des err normales (recompile tout).
34) Ecrit newtonpoly().
35) Reecrit completement rootmod(), renomme l'ancien en rootmod2().
36) Ecrit approxp(), apprgen().
37) Ecrit rootpadic().
38) alglin1.c: extract() remplacer if(in>=lx) err(extracter3);
par if((in>=lx)||(in<=0)) err(extracter3);
39) gen2.c: ggval() case 7: remplace val=valp(x) par
    val=signe(x[4])?valp(x):valp(x)+precp(x).
40) Modifie le manuel a plusieurs endroits, ainsi que users.tex et index.tex.
41) Ecrit smallpolred(), factoredpolred(), factoredbase(), factoreddiscf().
42) Modifie quelques lignes de factmod() pour pouvoir factoriser modulo un p>=2^31.
43) Modifie gen1.c, gen2.c et gen3.c pour que les operations entre entiers modulo
et p-adiques soient legales.
44) Ecrit bittest().
45) Fait une petite modif a gsigne() dans le cas 4 et 5 (pas une bug), et modifie
rootmod pour que les racines soient "ordonnees".
46) BUG DANS mp.c: dvmdii(): dans le if(ly==3) remplacer p2[1]=(sy<<24)+3 par
p2[1]=(sx<<24)+3 (comme le suivant).
47) Ecrit polred2() (pas tres different de polred()).
48) versionport.c: divll() (le vieux, ou est passe le nouveau ?), remplacer
    if(dbl>=C4) par if(dbl>C4-1).
49) mp.c: divrr() remplacer if(!ldif) {y0=y[lz+2];y[lz+2]=0;}
    par if(!ldif) {y0=y[lz];y[lz]=0;}
    et if(!ldif) y[lz+2]=y0; par if(!ldif) y[lz]=y0;
    Enfin, remplacer for(i=2;i<=lz;i++) z[i-1]=x[i];
    par:
        for(i=2;i<=lz-1;i++) z[i-1]=x[i];
        z[lz-1]=(lx>lz) ? x[lz] : 0;
50) mp.s: _divis: apres 4$:, juste avant le divull d1,d3:d4 ajouter moveq #0,d3
  (remarque: cela ne semble pas affecter les sun3 et les MacII que d3 ne soit pas
  initialise a 0. Mais ca plante d'autres 68020).
  Corrections semblables dans _divss, _modss, _resss: apres movem d2-d3,-(sp), mettre
  moveq #0,d3, puis apres l'etiquette 1$, remplacer divsl d1,d3:d4 par:
    bpl   9$
    moveq #-1,d3
9:  divsl d1,d3:d4

51) es.c: bruti(), ligne 6 du case 10: remplacer sanssigne par 0.
52) arith1.c: sfcont(), case 4,5: dans le if(signe(p3)<0) remplacer
    addiiz(p3,p2,p3);affii(p3,p1); par
    p4=addii(p3,p2);affii(p4,p1);cgiv(p4);
    Puis, au debut de ce meme case 4,5 remplacer p1=gcopy(x[1]) par
    if(lgef(x[1])>=lgef(x[2])) p1=lcopy(x[1]);else affii(x[1],p1=cgeti(lgef(x[2])));
53) trans2.c: ggamma(), cxgamma() et mpgamma(): quelques changements pour avoir une
    erreur en cas d'entier negatif ou nul (modifie le message gamer2 dans messages.c).
54) ecrit(!!!) gtype() (type sous gp).
55) arith1.c: classno2() reecrit pour marcher en cas de discriminants non fondamentaux.
    (classno(x) utilise classno2(x) pour x>0).
56) arith1.c: regula() (et erreurs.h, messages.c) ajoute un test et un message d'erreur
    quand l'argument du regulateur est un carre.
57) Dans de nombreux endroits, modifie le traitement du zero p-adique pour 
    qu'il ne depende que de valp et pas de precp.
58) polarit1.c: enlever #define vvalp et remplacer par valp partout.
59) gen2.c: ggval() case 7: remplacer signe(x[4]) par valp(x).
60) messages.c: and factorpadic a rajouter au message rootper1.
61) polarit2.c: content() ajoute avant le case 10:

    case 19: if(lx==1) return gun;
      p1=content(x[1]);l=avma;
      for(i=2;i<lx;i++) {tetpil=avma;p1=ggcd(p1,content(x[i]));}
      if(l==avma) return gcopy(p1);
      else return gerepile(l,tetpil,p1);
62) polarit2.c: ggcd() case 1,case 3 remplacer z[1]=y[1] par
    z[1]=copyifstack(y[1]).
    idem case 3,case 3 remplacer ? z[1] par ? copyifstack(x[1]).
    case 1 rajouter
      case 7 : z=gpuigs(y[2],min(valp(y),ggval(x,y[2])));break;
    case 3 rajouter la meme chose.
63) (suite de 62) case 4,5 remplacer tout par

      case 4 :
      case 5 : 
	switch(ty)
	  {
	  case 4:
	  case 5: z=cgetg(3,4);
	    z[2]=lmulii(x[2],y[2]);l=avma;
	    p1=mulii(x[1],y[2]);
	    p2=mulii(x[2],y[1]);tetpil=avma;
	    z[1]=lpile(l,tetpil,mppgcd(p1,p2));
	    gredsp(&z);break;
	  case 6:
	  case 8: z=gun;break;
	  case 7 : z=gpuigs(y[2],min(valp(y),ggval(x,y[2])));break;
	  }break;
      case 7: if((ty!=7)||(!gegal(x[2],y[2]))) z=gun;
            else z=gpuigs(y[2],min(valp(y),valp(x)));break;
64) Remplacer tout les return gcopy(gun) par return gun.
65) polarit2.c: content() changer le default: les premieres lignes sont

    default: f=1;
      if(tx!=15) {for(i=lontyp[tx];(i<lx)&&f;i++) f=(typ(x[i])==1);i=lx-1;}
      else i=lx-2;
      p1=(GEN)x[i];l=avma;

   puis remplacer i>=3 par i>lontyp[tx], i>=2 par i>=lontyp[tx].
66) A changer les Makefile pour install (-c, -m,  -s a voir).
    Changer les numeros de version.
67) gen2.c: cvtop() remplacer (7 fois) les pvaluation(x,y,&z) par ggval(x,y).
68) gen2.c: ecrit gcvtop() (et modifie le message d'erreur cvtoper2 dans 
    messages.c).
69) polarit1.c: en train d'ecrire factorpadic() et padicff().
70) Toutes les fonctions a partir de approxp(): remplacer valp(x) par 
    ggval(x,p), ou p a ete mis convenablement (egal a a[2]).
71) ggval() remplacer if(gcmp0(x)) par if(gcmp0(x)&&(tx!=7)&&(tx!=11)).
72) Modifie quelques endroits dans le manuel.
73) polarit1.c: rootpadic() cas r==1, remplacer yi[4]=p1[2] par
    yi[4]=lcopy(p1[2]).
74) gen2.c ggval() case 12: remplacer tp!=1 par tp!=10.
75) polarit1.c: enleve approxp() et incorpore apprint() a apprgen(), et 
    legerement modifie apprgen.
76) gen3.c: ecrit isexactzero() (pas identique a isnull()).
77) gen2.c: Modifie normalizepol() pour ne chasser que les zeros exacts.
    Desormais, un polynome "nul" peut avoir une lgef>2, et les coefficients
    sont alors significatifs.
78) polarit2.c: primpart() changer if(lgef(x)==2) z=gzero en
    if(!signe(x)) z=gcopy(x);
79) gen1.c: gadd() fin du case 10,case 10 remplacer apres z[i]=lcopy(x[i])
    tout ce qui suit jusqu'au break par:
    z[1]=x[1];setsigne(z,1);normalizepol(&z);break;      
80) gen1.c: gadd(), gmul(), gdiv() changer le debut du case 10 case <10.
81) gen2.c: Modifie ggval() case 12 pour accepter valuation / entier et case 10
    en changeant gcmp0 en iszero.
82) polarit2.c: factpol() remplace fa[30] par fa, mettre un lx=lgef(x) au 
    debut, puis un fa=cgetg(lx,17);for(i=1;i<lx;i++) fa[i]=zero; et enfin
    quelques typecasts.
83) gen3.c: deriv() et integ(), modifie quelques trucs pour tenir compte de la
    modification des polynomes nuls.
84) mp.s: gerepile() (!!!) etiquette 7:, remplacer movl  40(sp),d0 par
    movl  d0,d1
    movl  40(sp),d0
    puis 2 lignes apres remplacer cmpl d0,a0 par cmpl d0,d1.
    (ceci corrige entre autres l'erreur de reorder([])).

*********************A FAIRE SUR ELLIPTIC.C DE DOMINIQUE**********************
85) remplacer tres souvent (peut etre partout) pvaluation(x,p,&p9) par
    ggval(x,p).
86) ghell(): apres grandn=pval... mettre les 3 lignes suivantes dans un
    if(grandn), suivi de else avma=av2, ou av2=avma est mist apres 
    z=hell(e,a,prec) et declare.
    Modifs essentiellement identiques pour ghell2() et ghell3().
******************************************************************************
87) es.c: modifier 4 lignes de bruti.
88) mp.s: nombreuses modifications (simplifications) dues au remplacement par
    des _gzero.

----------------------------------------------------

Version 1.34.90 (pre alpha version de la 1.35)

89) gpreadline.c: changer buffer=strdup("\\q") en strcpy("\\q",buffer).
90) bibli2.c: sumpos() changer 4 lignes apres le debut,
    newvalue(ep,cgetr(prec)) en 

    p1=cgeti(prec+1);p1[1]=0x1000001+prec;
    newvalue(ep,p1);
91) deplace eulsum() de bibli1.c a bibli2.c.
92) bibli2.c: sumalt() dans le grand if(gcmp0(p1)||....) rajouter la condition
    &&(jterm>=10) pour eviter les arrets triviaux.
93) anal.c: dans les case 1,....200, partout ou il y a des itos(), tester
    avant si le type est egal a 1, et sinon envoyer l'erreur caseer. Ajouter
    cette erreur dans erreurs.h et messages.c.
94) dans padicff(), change pro[++j]=p1[k] en pro[++j]=(long)lift(p1[k]).
95) incorpore factorpadic a anal.c et messages.c.
96) Fini d'ecrire padicff et factorpadic.
97) alglin2.c: caract() mettre le setvarn(p5,v) apres le p5[1]=0x01000004
    et non pas avant.
98) polarit1.c: dans apprgen() et apprgen12() remplacer ggval par gmaxval
    (sauf a la division par p^ggval ou on teste simplement a zero), ou
    #define gmaxval(x,y) (gcmp0(x)?BIGINT:ggval(x,y)).
99) polarit1.c: apprgen12() rajouter un lift() devant p1=poleval(...).
100) arith2.c: primeform() ajouter la variable long prec et remplacer a la fin
    cgetr(3) par cgetr(prec). De plus, dans classno() ajouter ,3 dans l'appel
    de primeform.
101) arith2.c: rhoreal(): debut, changer tout le calcul de l en
    l=max(lg(x[4]),((-expo(x[4]))>>5)+2);if(l<=2) l=3;
    gencom.h: rajouter (apres min) la definition de max.
102) polarit1.c: bezoutpol() modifier les 5 lignes apres le while(signe(w3)).
103) presque partout: verifier systematiquement si les decalages sont
    necessaires a l'aide de la macro adecaler(x,tetpil,anavma).
104) mis a jour manuel et pari.menu. Modifie messages.c en remplacant constant
    polynomial in roots par zero polynomial.
105) polarit1.c: roots(), retourner le vecteur vide au lieu d'une erreur en cas
    de polynome constant non nul.
106) gp.c (et gpreadline.c) enlever le #define BUFFSIZE fixe et le remplacer
    par un long paribuffsize modifiable par -b. Changer le stacksize de 500
    a 1000 dans gencom.h. Modifie manuel, pari.el, usage() en consequence.
107) bibli1.c: lllgram() apres le if(!gcmp0(r=ground(...))) enlever le ; (!!!)
    et mettre else mu1=coeff(mu,k,k-1).
108) bibli1.c: polrecip() avant return y ajouter normalizepol(&y).
109) bibli1.c: lindep2() remplacer l'appel lll(p4,prec) par 
     lll(p4,(prec<<1)-2).
110) bibli1.c (et messages.c, anal.c et gencom.h) ajoute la fonction algdep2().
111) bibli1.c, anal.c, messages.c: ecrit polredreal().
112) bibli1.c: modifie la derniere ligne de polred(), polredreal(), 
     factoredpolred(), smallpolred() pour que la trace soit toujours >=0.
113) gen3.c: lift() corrige le case 11.
114) polarit1.c: apprgen() et apprgen12() remplacer if((vv=1)... par
     if((vv==1)....
115) polarit1.c: rootmod() remplacer gcmpgs(p,stoi(4)) par gcmpgs(p,4).
116) polarit1.c: apprgen() et apprgen12() remplacer idiot2=ggrando(p,1)
     par idiot2=gcmpgs(p,gdeux) ? ggrando(p,2) : ggrando(p,1);
117) polarit1.c: rootpadic(), traiter correctement la creation de yi dans
     le cas p=2.
118) polarit1.c: apprgen() et apprgen12(), encore des modifs pour p=2.
119) polarit1.c: rootpadic() etc... changer les cgetg(,17) en cgetg(,18).
120) gen3.c: gsubst() modifier le case 12 (de toutes facons il va falloir
     modifier tous les case 12).
122) polarit1.c: apprgen12() modifie l'utilisation de idiot et idiot2.
     La factorisation p-adique pour p>2 a l'air de marcher completement
     maintenant.
123) polarit1.c: apprgen12() enleve un lift() apres p1=.
124) Saut quantique: modification complete du traitement du case 12,
     qui devient le case 9. Modifs trop nombreuses pour etre detaillees.
125) gen1.c: gadd() dans le cas ty==10, et e==2, sortir le setvarn(z,vy)
     du else.
126) gen3.c: gmul2n() corriger le case 13,14 et rajouter case 9.
127) es.c: ecrire() remplacer 2 fois dec>=deceff par dec>deceff.
128) polarit1.c: padicff() modifier l'appel a apprgen9 pour que dans le cas
     du degre 1, apprgen soit appele.
129) Enleve tous les gcopy((g)zero) et gcopy((g)un) et remplace par gzero et
     gun.
130) Reecriture complete de elliptic.c par dominique, avec algorithme de Tate.
131) arith2.c: classno() Oublie de remttre com=0 vers la fin, et remplacer
     if(cmpii(fh[2],ftest[2])) com= -com par
     if(!cmpii(fh[2],ftest[2])) com= -com.
132) elliptic.c: apell() changer la declaration multiple table[100] en une 
     declaration dynamique, et ajouter des unsigned long (2 fois) a la fin,
     au moment du calcul de q.
133) elliptic.c: modifie quelques 19 en 20 pour la longueur donne par initell().
134) elliptic.c: coordch(), mis correctement le calcul de eta1, eta2 et
     volume.
135) mp.s: (pendant de la correction 49) divrr() juste avant dext:
     remplacer les instructions commencant par bne   2$ par
        bne     2$   
        movl    a3@(-8),a6@(-20)
        clrl    a3@(-8)
2$:     subqw   #1,d6
        bgt     3$
        movl    a3@(-4),a6@(-24)
        clrl    a3@(-4)
3$:     moveq   #0,d6

     et plus loin, apres bcdf:, autour de 7$ echanger
     a5@(-8) et a5@(-4).
 
    Enfin, dans dvrr:, mettre apres movl a0@,a6@(-10):
	movw	a2@(2),d6
	subw	#2,d6

    et apres le dbra d0, 1$:

        cmpw    d7,d6           | l2>l1 ?
        bgt     4$
        clrl    a4@(-4)         | Si l2<=l1, y(m+1) n'existe pas
                                | a4 pointe apres y(m+1)
4$:     movl    a0,a2.
Enfin, dans divri apres 2$, apres le bsr getr (alloc. du resultat) ajouter
	movl	_avma,a3        | eviter le chevauchement.
	subql	#8,a3
	movl	a3,_avma
	movl	#2,a3@		| Hack pour que giv rende ceci
     (l'instruction suivante etant movl a0,a3).
136) polarit2.c: sturm(), et es.c: sori(), remplacer les signe par gsigne (dans sori,
     uniquement quand typy==4 ou 5.
137) mp.s: mulir(), en 2$+3 remplacer movw a1@(2),d0 par addqw #1,d0.
     Dans mulrr() et mulir(), remplacer le link a6,#-8 par link a6,#-16.
138) mp.s: mulir(), juste avant bsr murr, ajouter
	exg	a1,a2		| Il faut que a2 soit le plus court!
	movw	a2@(2),d0	| Mettre l'inf des longueurs dans d0 pour murr
139) mp.s: changer toute la fin de mulrr() 

munzr:  movw    a2@(2),d0
	clrl	a6@(-12)	| Initialiser flag a 0
        cmpw    a1@(2),d0
        bls     1$
        movw    a1@(2),d0       | d0.w contient L+2=inf(L1,L2)+2
        exg     a1,a2           | a2 pointe sur le + court
	bra	2$
1$:	bne	2$
        lea     a1@(0,d0:w:4),a3 | a3 pointe sur x[L+1]
	movl	a3,a6@(-12)	| longueurs egales: flag egal adresse
	movl	a3@,a6@(-16)	| sauvegarde de x[L+1]
	clrl	a3@
2$:     bsr     getr
        movl    a0,a6@(-8)
        bsr     murr            | effectuer la multiplication
	tstl	a6@(-12)
	beq	mulrrf
	movl	a6@(-12),a1
	movl	a6@(-16),a1@	| remettre x[L+1]
mulrrf: movl    a6@(-8),d0      | adresse du resultat
        moveml  sp@+,d2-d7/a2-a4
        unlk    a6
        rts
 
     et enlever le movw   a2@(2),d0 a la troisieme ligne de murr.
140) mp.c: mulrr() et mulir() remplacer le premier if(p1) (apres garde=hiremainder) 
  (ou son equivalent dans mulir) par:
  if(p1)
    {
      mulll(p1,y[3]);garde=addll(hiremainder,garde);p2=mulll(p1,y[2]);
      hiremainder+=overflow;garde=addll(p2,garde);z[lz-1]=overflow+hiremainder;
    }
  else z[lz-1]=0; (pas le if else dans mulir).
141) Un peu partout remplacer les occurences de gpi par des mppi().
142) ecrit pnqn() (arith1.c, anal.c, messages.c, erreurs.h, gencom.h, 
     pari.menu, manuel).
143) versionport.c: ne pas oublier de remettre la fin du commentaire de divll
     et d'enlever celui de la fin de l'ancien divll.
144) Un certain nombre de modifs d'ordre essentiellement esthetique, y compris
     le changement de nom de fc en gcf.
145) mp.c: mulrr() et mulir(), modif 140 incorrecte. remplacer la meme chose par
  if(p1)
    {
      mulll(p1,y[3]);p2=addmul(p1,y[2]);
      garde=addll(p2,garde);z[lz-1]=overflow+hiremainder;
    }
146) mp.c: divrr() changer tout le if(lz==3) en 

  if(ly==3) /* Ce n'est pas une erreur: c'est bien ly et pas lz ici */
    {
      i=x[2];si=(lx>3)?x[3]:0;
      if((ulong)i<(ulong)y[2])
	{
	  hiremainder=i;z[2]=divll(si,y[2]);
	  z[1]=ex1-1;return z;
	}
      else
	{
	  hiremainder=((ulong)i)>>1;
	  z[2]=(i&1)?divll((((ulong)si)>>1)|(0x80000000),y[2]):divll(((ulong)si)>>1,y[2]);
	  z[1]=ex1;return z;
	}
    }
147) mp.s: reecrit dvrr(). Les versions port, sparc et 68k ont maintenant l'air
     de coincider parfaitement.
148) arith1.c: ajouter un troisieme parametre a sfcont() pour limiter la
     longueur des fractions continues, et ecrit et installe la fonction
     gboundcf() (boundcf() sous gp).
149) arith1.c: ecrit et installe la fonction gcf2() (cf2() sous gp).
150) elliptic.c: globalreduction() ajoute verification type de e1 correct.
151) elliptic.c: installe la fonction smallinitell(), et legerement modifie
     les messages.
152) elliptic.c: quelques petites modifs pour accepter un vecteur de longueur
     14, et mis a jour le manuel.
153) trans1.c: pasqrt() corrige des bugs dans le traitement des racines carrees
     2-adiques et modifie le manuel.
154) trans2.c etc...: ecrit et installe glngamma().
155) arith2.c: modifie le code pour supprimer les longjmp.
156) trans2.c: mpbern() mettre nomb=0 si nomb<0.
157) trans2.c et trans3.c: modif analogue a la 141 pour les bernoulli: ne pas
     utiliser toute la precision disponible.
158) trans2.c: mpgamma(), cxgamma(), mplngamma(), cxlngamma() corrige pour les
     arguments de grand module.
159) elliptic.c: initell() modifie pour que dans le cas p-adique toutes les
     composantes soient du type p-adique.
160) bibli1.c: minim(), ajoute eps a la borne pour arrondir correctement.
161) Remplace des malloc() par newbloc() et free() par killbloc().
162) Ecrit setprecision() et getprecision().

------------------- version 1.34.95 --------------------------------

163) elliptic.c: subell() apres le premier if(), et subsell() au debut,
     rajouter:  if(lg(z2)<3) return gcopy(z1);
     powell(), powsell() et powssell(), apres le if(!s) (ou le if(!n)) rajouter
     if(lg(z)<3) return gcopy(z);
164) polarit2.c: squff(), changer if(!klim) en
     kd=da>>1;if((!klim)||(klim>kd)) klim=kd;
165) gp.c et gpreadline.c: ajoute  nbchi=dec=glbfmt[2];apres z=readseq(&tch);
     (au cas ou GP aurait fait appel a setprecision()).
     Modifie setprecision() et deplace de gp.c a bibli1.c, ainsi que
     setserieslength.
166) gp.c, gpreadline.c, init.c, gencom.h: rendu paribuffsize global, et modifs
     en consequence pour qu'il soit initialise par init().
     anal.c, truc(): change le newbloc(1000) par newbloc(paribuffsize>>1).
167) gp.c et gpreadline.c: globs() et tous les appels a globs(), ajouter
     comme parametres parisize et primelimit, et les faire imprimer. Modif
     semblable pour escape(). Enfin, dans globs() changer
     thestring[20] en thestring[70], et le nom primes en primelimit.
168) alglin2.c: invmulmat() ajoute la verification des tailles.
169) bibli1.c: ordred() modifie la fin pour que, comme polred, on ne renvoie
     que les polynomes minimaux.
170) bibli1.c: polredreal() modifie la multiplication par base, incorrecte a
     cause du nouveau traitement du type 9 (se trouve peut-etre a d'autres
     endroits).
171) bibli1.c: polred() et polredreal(), nettement acceleres en tenant compte
     des denominateurs.
172) Modifie le nom de la fonction bibliotheque setprecision en setprecr (le
     nom de la fonction gp ne change pas).
173) Enleve quelques variables inutilisees.
174) Dans arith1.c et arith2.c, remplace random() par rand().
175) trans3.c: jbesselh() juste apres le case 5, rajouter av=avma.
176) bibli1.c: polredreal() accelere en en calculant la matrice des traces
     autrement.
177) base.c, erreurs.h, messages.c: ajoute deux verifications et messages
     d'erreur dans factoredbase().
178) base.c: ...base() mettre la variable correcte.
179) init.c: init() creer polx[255] et polun[255].
180) alglin2.c: caract() et gnorm() case 9: changer completement d'algorithme,
     utiliser un resultant.
181) bibli1.c: factoredpolred(), smallpolred(), ordred() memes modifs que la
     modif 171.
182) users.tex et index.tex change l'espacement des points (!)
183) gp.c et gpreadline.c: envoyer le prompt seulement quand infile==stdin.
     et dans pari.el version 2.6 remplacer \n\n\n par \n (a voir pour 2.7).
184) bibli1.c: polred() et tous les autres, mise du signe finale modifiee.
185) legerement modifie appa.tex et INSTALLATION.
186) pari.el 2.7 de David Carlisle recu et installe.
187) modifie legerement pari.el, users.tex et index.tex suivant lettres de
     D. Carlisle et D. Bernardi.

----------------------- release preliminaire de la version 1.35 ------------

188) Corrige quelques erreurs d'impression dans le manuel.
189) elliptic.c: zell(), le resultat n'etait correct qu'au signe pres 
   modulo le reseau. Modifie un peu au pif. A verifier.
190) elliptic.c: zell(), corriger si c0=0.
191) mp.s: suivant une suggestion de R. Schroeppel, modifie mulii(),
   mulir(), mulrr(), dvmdii() et divrr() pour que les boucles internes de
   multiplication ne necessitent que 7 instructions. Gain 5% en vitesse.
192) arith1.c: mppgcd() completement reecrit en utilisant la version 
   simple de l'algorithme binaire. L'ancienne version s'appelle mppgcd1().
   Ecrit egalement le bezout correspondant, mais pour l'instant il semble
   plus lent, donc pas en service.
193) base.c: tous les programmes (3 fois) changer n=lg(x)-3 en n=lgef(x)-3.
194) bibli1.c: lindep2(), remplacer lll(p4,.. par gmul(p4,lll(p4,..., et
   rajouter un parametre variable long bit. D'ou modif dans algdep2(), anal.c, 
   messages.c et le manuel.
195) usersch3.tex: modifie le paragraphe lll: cela ne rend plus la meme 
   chose!
196) es.c: ecrire() corrige l'ecriture d'un reel en format exponentiel.

------------------- Release internationale de la version 1.35---------------

