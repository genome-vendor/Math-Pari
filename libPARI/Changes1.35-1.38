(Modifications de 1.31 a 1.35 dans le fichier Changes1.31-1.35)
-----------------------------------------------------------------------------
Modifications a la version 1.35.

Code: B: bug, M: modification, N: nouveau programme, D: erreur de doc.
1 a 3: de peu important a tres important

1) [N] Ecrit et installe suppl() (supplement dans GP) et image().
2) [N] Ecrit et installe la factorisation dans les corps finis factmod9()
   (factfq() dans GP).
3) [B1] alglin1.c: modifier les ker() pour que quand le noyau est nul le
   resultat soit vide.
4) [B1] es.c: dans tous les programmes d'impression, accepter les matrices
   a 0 colonnes.
5) [N] alglin1.c: ecrit un nouvel image(), et renomme l'ancien
   image2().
6) [B1] es.c: comme 4, pour les vecteurs.
7) [B3] gen1.c: gmul() changer (dans ty>=10) le if() en
    if(((vx>vy)&&((tx<17)||(ty<17)))||((vx==vy)&&(tx<10))||((ty>=17)&&(tx<17)))
    gadd() idem changer le if() en
    if(((vx>vy)&&((tx<17)||(ty<17)))||((vx==vy)&&(tx<10)))
    gdiv() idem changer le if() en
    if(((vx<vy)&&((tx<17)||(ty<17)))||((vx==vy)&&(ty<10))||((tx>=17)&&(ty<17)))
8) [M1] mis a jour testin et testout

----------------------- Version 1.35.01 --------------------------

9) [B2] polarit2.c, ggcd() reecrit completement le type 9,9, en analogie avec
   le type 3, ainsi que type 9,10 en analogie avec 3,1.
10) [N] alglin1.c: ecrit et installe inverseimage().
11) [B2] polarit1.c: rootmod() et factmod(), modifie les appels a ggcd pour les
   rendre compatible avec la correction 9).
12) [M1] mp.s etc...: modifie le code pour ne plus du tout utiliser a5, par
   compatibilite avec le Mac.
13) [N] bibli1.c: ecrit et installe cyclo().
14) [N] bibli1.c: ecrit et installe vecsort().
15) [N] anal.c, gp.c, init.c: mis globalement infile et echo (transforme en
    pariecho), ainsi qu'un buffer parireadbuffer, alloue dans gp.c. Puis
    ecrit et installe read().
16) [N] anal.c: installe label() et goto() (honte a moi!), mais goto() ne
    marche pas bien.

------------------------ Version 1.35.02 ----------------------------

17) [B2] gen2.c: dbltor() changer ex=log2(x) en ex=floor(log2(x)).
18) [B1] bibli1.c: lllgram(), apres n=lx-1 mettre:
    if(n<=1) return gcopy(x).
19) [M1] arith1.c: bezout1(), (ligne 655) remplacer st=-1 par st= -1.
20) [M1] arith2.c: initprimes(), changer size=(maxnum+1)/2 en
    size=(maxnum+257)>>1, et 2*(q-s) en (q-s)<<1.
21) [N] bibli1.c: ecrit et installe polymodrecip() (modreverse dans GP).
22) [N] bibli1.c: ecrit et installe polred2().
23) [N] gen3.c: ecrit et installe gtopolyrev() (polyrev dans GP).
24) [M3], [N] bibli1.c, base.c, etc...: unifie tous les base() en un seul, tous les polred,
    supprime polredreal (un sturm est fait systematiquement), et ajoute smallpolred2() et
    factoredpolred2().
25) [N] polarit1.c: ecrit et installe rootslong().
26) [D1] usersch3.tex: indiquer que dans binome(x,y), y doit etre un entier
    du C, et dans anell(e,n) que e doit etre une equation minimale et n un
    entier du C.
27) [B1] messages.c: changer factpadic en factorpadic.
28) [B1] alglin1.c: modifier concat() pour accepter des matrices vides.
29) [M1] elliptic.c: modifie initell en remplacant l'appel de roots()
    par rootslong(), et installe l'ancien comme initell2() 
    provisoirement.

----------------------- Version 1.35.03 --------------------------------

30) [B2] alglin1.c: keri() modifie, le precedent donnait tout simplement des
    resultats faux.
31) [M1] usersch3.tex: divres, le reste est du signe du dividende, et non positif
    ou nul comme signale.
32) [B1] gen1.c: gmul(), modifie pour traiter correctement les matrices vides,
33) [B1] polarit2.c: ggcd(), modifie pour que le pcgd d'un polynome avec l'entier 0
    donne le polynome.
34) [N] base.c etc... Ecrit et installe galois() et tchirnhausen().
35) [N] bibli1.c etc... Ecrit et installe genrand() (random dans GP) et permute() 
    (permutation in GP).
36) [M1] polarit2.c: modifie ggcd() et glcm() pour permettre des arguments
    vecteurs/matrices.
37) [N] base.c etc... Ecrit et installe initalg().
38) [M1] gen2.c: normalize() remplace gcmp0 par isexactzero ainsi que les autres occurences
    analogues dans gen1.c.
39) [B1] gen2.c: ggval() apres la premiere ligne isexactzero... ajouter
    if((tx<9)&&(ty==10)) return 0;
40) [N] polarit2.c etc... ecrit et installe resultant2() valable pour des types non exacts.
41) [M1] alglin1.c: det() change la ligne de division pour qu'en cas de polynomes la division
    soit euclidienne.
42) [M1] base.c: smith() modifie le code apres le if(!c) pour permettre des
    matrices singulieres (b=0), et prendre la valeur absolue a la fin.
43) [B3] anal.c: lindep2 est de type 23 et pas 21.
44) [M1] usersch3.tex: galois, legerement modifie la terminologie.
45) [B3] base.c: corrige une bug dans smith() dans le cas ou p1=-p2.
46) [M1] pari.menu et usersch3.tex: oublie arg().
47) [M1] Modifie sumdivk pour qu'il accepte k<0.
48) [N] Ecrit les fonctions mpfactr() (fact dans gp) et izeta().
49) [B1] Corrige incgam() pour que ca marche quand a<=0. Ecrit incgam4().
50) [N] Ecrit et installe lseriesell() (a titre temporaire).
51) [N] Ecrit cxpolylog() et incorpore a polylog.
52) [N] Ecrit glngamma(), ggamma() pour les series, et gpolylog().
53) [B3] es.c: texi() corrige 4 lignes au type 10, identiques a la correction
    correspondante dans bruti.
54) [N] Ecrit galoisconj().
55) [M1] Modifie gnorml2() pour accepter tous les types, en particulier matrices.
56) [B4] !!! gen1.c gadd() type 2+type 4 et 5, code incorrect modifie.
57) [N] Ecrit et installe matrixqz().
58) [N] Ecrit et installe centerlift().
59) [M2] Modifie err() et invmod() pour qu'il imprime les inversesmodulo
    impossibles.
60) [N] Ecrit(!) et installe matlength(). 

----------------------- Version 1.35.04 --------------------------------

61) [B2] base.c: tchirnhausen() mettre {} apres le if(v).
62) [M1] reecrit commands() pour tenir compte des noms trop longs.
63) [M1] supprime encore une fois (!) les random() dans polarit1.c
64) [M1] ggval et pvaluation ne font plus deborder la pile pari.
65) [B1] gen3.c: matlength() donnait 1 ligne de trop.
66) [M1] gencom.h,gp.c,init.c,anal.c: modifie pour que la fonction read()
    de GP soit reentrante.
67) [M2] anal.c: reecrit et nettement ameliore le programme constante().
68) [B2] alglin2.c: matrixqz() change pp en p dans la premiere division.
69) [M1] base.c: hnf() modifie pour accepter des matrices ayant plus de lignes
    que de colonnes. Le resultat n'est maintenant pas toujours une matrice carree.
70) [N] alglin2.c: ecrit et installe matrixqz2() (algorithme de Dominique).
71) [N] alglin1.c: ecrit et installe indexrank().
72) [N] alglin2.c: ecrit et installe matrixqz3().
73) [B1] alglin1.c et alglin2.c: modifie invmulmat(), caract(), rank() 
    et indexrank() pour accepter des matrices vides.
74) [N] alglin2.c: ecrit et installe kerint().
75) [M1] alglin2.c: matrixqz3() corrige une bug et ajoute une LLL-reduction a la fin.
76) [N] gen2.c, etc...: installe size() et rounderror().
77) [M1] alglin2.c: sqred1(), sqred2() (donc sqred()) modifies, et ajoute la protection
    contre stack overflow.
78) [N] bibli1.c, alglin2.c: ecrit sqred3(), et nouvelles versions de lll() et lllgram(),
    les anciennes s'appelant lll1() et lllgram1(). Les nouvelles sont beaucoup plus rapides
    et necessitent moins de place.
79) [N] elliptic.c: ecrit et installe pointell() (fonction P de Weierstrass et sa derivee).
80) [M1] alglin1 et 2.c: modifie encore d'autres programmes d'algebre lineaire pour accepter
    les matrices vides.
81) [M1] trans3.c: modifie polylog() pour qu'il accepte tout argument meme tres grand, et
    gpolylog pour avoir les polylog d'indice negatif.
82) [M1],[N] trans3.c: renomme polylogd en polylogdold, et modifie pour que polylogd soit
    maintenant le D_m~. De plus, traite les cas particuliers 0 et 1 dans les polylog.
83) [N] alglin2.c: ecrit et installe intersect().
84) [B2] alglin2.c: corrige une faute de frappe dans kerint().
85) [B2] elliptic.c: zell(), inverse le signe de t, change le mode de calcul de t pour
    eviter au maximum les erreurs d'arrondis, ajoute une iteration agm systematiquement
    et traite le cas particulier t=0 (zell() est donc correct et beaucoup plus precis).
86) [M1] bibli2.c: suminf(), prodinf(), prodinf1(), modifie la condition d'arret pour
    qu'il puisse y avoir des coefficients nuls.
87) [M1] elliptic.c: matell(), double les coefficients (la precedente definition
    donnait le regulateur divise par 2^r).
88) [D1] Modifie quelques fautes de frappe du manuel.
89) [M1] elliptic.c: oncurve(), modifie pour qu'il accepte un resultat approximatif 
    dans le cas de courbes a coefficients inexacts.
90) [M1] anal.c et messages.c: interverti length et legendre qui n'etaient pas dans
    l'order alphabetique.
91) [N] gen2.c, bibli1.c, etc...: ecrit et installe lexcmp() (lex dans GP) et lexsort().
92) [M1] polarit2.c, arith2.c: permis a smallfact() et boundfact() d'avoir des arguments
    rationels, et tries les nombres premiers qui interviennent.
93) [M1] gen2.c: gpui(), modifie pour un traitement correct des vecteurs.

------------------------- Version 1.35.05 ---------------------------------

94) [M1] elliptic.c: apell() modifie pour accepter des nombres premiers >2^16.
95) [B2] alglin2.c: hess() etait incorrect. Modifie et en fait simplifie.
96) [B1] gen2.c: ajoute du code a dbltor() pour s'assurer que le resultat est
    normalise.
97) [M2] version68k.c: ajoute presque toutes les routines de versionport.c
    pour la correction 96 ci-dessus. Deplace les declarations externes de
    overflow et hiremainder de genport.h a gencom.h.
98) [N] Donne a GP l'acces au polynome caracteristique calcule par la comatrice
    et interverti avec caract. D'ou char() dans GP correspond a caradj0() dans
    alglin2.c, et char1() dans GP correspond a caract() dans alglin2.c.
99) [M1] alglin2.c: Modifications cosmetiques a caract().
100) [M1] base.c: hnf() change j=def en j=def-1, puis a la fin (apres le if(
    signe(p1))) mettre else def++.
101) [N] alglin2.c: ecrit un nouveau kerint() utilisant HNF. renomme l'ancien
    kerint1().
102) [B3] bibli1.c: lllgram() et lllgram1(), la formule donnant mu_{i,k-1}
    etait completement fausse! Corrige, et change la constante de 9/10 a 
    99/100.
103) [B1] mp.s: negs() changer vers la fin tstl d1 en negl d1 (sinon identique
    a stoi!). Ajoute #define negs(s) (stoi(-s)) dans genport.h. Egalement,
    remplace le calcul d'un zero par _gzero, et dans abss enlever le link.
104) [M1] gen2.c: ismonome() remplace gcmp0() par isexactzero().
105) [M0] gen3.c: supprime conpol(); gencom.h ajoute une macro pour gdiventz().
106) [B2] gen1.c: gdiv() s/10, modifie pour que le resultat soit un polynome
    quand s=0 exactement, gmul() et gen3.c: gmulsg() s*13,14 aussi.
107) [M3,N] anal.c (et erreurs.h, messages.c): modifie le case 200 de 
    identifier() et skipidentifier() pour accepter les syntaxes m[j,] et m[,k]
    ou m est une matrice. Ces objets peuvent etre utilises dans une expression,
    et a gauche d'un symbole d'affectation (si m est une variable).
108) [N] Installe dans gp shift() (gshift() dans pari) et shiftmul() (gmul2n()
    dans pari).
109) [N] es.c: Nouveau format matbrute(), nouvelle commande de GP \m,
    modification de la signification de \p et \b.
110) [M1] gen3.c: gsubst() permis a nouveau une substitution dans un polymod.
    et de facon similaire dans geval().
111) [M1] alglin2.c: caradj0() autorise polynome caracteristique de tout
    scalaire.
112) [B1] polarit2.c: verifie le type dans quadpoly().
113) [M2] alglin2.c: trace() change completement l'algorithme pour le type 9:
    utiliser les formules de Newton.
114) [B1] bibli1.c: verifie le type dans ggrando().
115) [M1] trans*.c: autorise les fonctions transcendantes de type 9.
116) [M1] polarit1.c: split() et split9() remplace gvar(*t) par varn(*t).
    polarit2.c: discsr() type 10 remplace gvar(x) par varn(x).
117) [M3] gen*.c: nombreuses modifications pour un traitement un peu plus
    correct du type 9 (suite des modifs liees a la modif 124 sur 1.34).
    En particulier nouvelle fonction gvar2() et macro gvar9.
118) [M1] accepte le type 9 dans ground() et grndtoi().
119) [B3] polarit1.c: decpol() ajouter (i1<=k) avant (i==pos[i1]).
120) [B1] polarit1.c: gredsp() dans les 2 cas p1=0, faire un cgiv(p1) avant
    l1=(long)(x+3).
121) [M2] polarit1.c: gred() tx==13 ou 14 calcule le contenu pour essayer
    de mieux simplifier. En consequence dans d'autres programmes (gen*.c
    en particulier), de tres nombreuses modifs aux case 13, case 14.
122) [B1] polarit2.c: remplacer quelques polgcd par ggcd.
123) [B1] polarit2.c: ggcd(), type 13,14 remplacer if(ty>=17) par if(ty>=15).
124) [B2] polarit1.c: poldivres() if(tx<10) *pr=gcopy(x) et pas gcopy(y).
125) [M1] gen3.c: gmulsg() et gdivgs() case 10: mettre ly=lgef(y) et 
    lx=lgef(x).
126) [M1] anal.c: constante() remplace stoi(10) (dans l'exposant) par une
    affectation dans un reel.
127) [B1] polarit2.c: ggcd() case 3, case 4: commencer par p1=mppgcd(x[1],y[2])
    et non pas x[2].
128) [M1] polarit2.c: ggcd() autorise le pgcd case 9 case 13,14.
129) [M1] polarit2.c: ggcd() traite correctement le cas de variables 
    differentes; modifie le resultat du pgcd avec une serie, et autorise les
    pgcd generaux avec series.
130) [B1] gen2.c: normalizepol() changer le if(signe(x)) en if(lgef(x)>2).
131) [B1] bibli1.c: changevar() traite correctement les case 9 et 13,14.
132) [M1] polarit*.c, gencom.h: plusieurs modifs pour remplacer lgef() par
    qqchose de plus correct (cas des polynomes scalaires). En particulier
    macros isscalar(), isnonscalar() et leadingterm().
133) [M1] gen2.c: normalizepol() modifie et met le signe dans tous les cas.
    gen1.c: enlever un setsigne inutile avant normalizepol.
134) [M2] gp.c: (modification de 109) modification de la signification de \p,
    \b et \m, et nouvelle commande \a.
135) [N] arith2.c: ecrit rhorealnod() et redrealnod(), et ajoute des verifs
    de type dans rhoreal et redreal. Change le nom qfred1 en redcomp, et
    ajoute ces fonctions dans pari.menu.
136) [B1] anal.c: identifier() oublie de mettre une verification type et
    longueur dans une affectation m[,c]= (suite de 107).
137) [M1] alglin2.c: gnorm() case 10 a 14, prendre la partie reelle avant
    de donner le resultat.
138) [M1] trans1.c: gsqrt() autorise le type 9.
139) [N] gen3.c: installe simplify().


--------------------------- Version 1.35.07 ------------------------------

(la version 1.35.06 n'a existe que de facon ephemere dans 1 seul site)

140) [M3,B1] gen3.c: precision() remplacer le if(tx==2)... par
  if (tx==2) return max(lg(x),2-(expo(x)>>5));
141) [B3] trans3.c: gpolylog() mettre au debut av=avma et enleve dans les cases
  individuels.
142) [B2] elliptic.c: initell() et initell2() remplacer q=ginv(gadd(w,gsqrt(..
   par
      if(gsigne(greal(w))>0) q=ginv(gadd(w,gsqrt(gaddgs(gmul(w,w),-1),prec)));
      else q=gsub(w,gsqrt(gaddgs(gmul(w,w),-1),prec));
      pitemp=mppi(prec);...
143) [B1] elliptic.c: initell(), initell2() et zell() remplacer 
   if(signe(p2)>0) par if(gsigne(p2)>0).
144) [N] bibli1.c: Ecrit et installe lllgramint() et lllint().
145) [B1] gen3.c: gceil() case 4,5: remplacer signe par gsigne.
146) [B3] gen2.c: gpuigs() dans ismonome(x) avant p1=cgetg(dd,10) mettre
   av=avma; dans if(n<0) remplacer av=avma par tetpil=avma.
147) [B2] polarit2.c: content() remplacer tetpil=avma;p1=ggcd(p1,x[i])
   par 
	      txi=typ(x[i]);
	      if((txi==2)||((txi>=6)&&(txi<=9))) {avma=l;return gun;}
	      else {tetpil=avma;p1=ggcd(p1,x[i]);}
   rajouter les memes deux premieres lignes dans le else
   et declarer txi.
148) [B1] polarit1.c: gred() dans tx==13 ou 14, remplacer if(gcmp0(x1))...
   par
    x1=(gcmp0(x1))?(GEN)x[1]:gdiv(x[1],x1);
    x2=gdiv(x[2],x2);y=poldivres(x1,x2,&p1);
149) [B1] polarit2.c: content() case 11: mettre a la place
    case 11: if((!signe(x))&&((tx==11)||(lx==2))) return gzero;
150) [M2,N] arith2.c: Modifie compose(), compreal(), comprealraw(), sqcomp(),
    sqcompreal(), sqcomprealraw() pour calculer correctement avec des formes
    non primitives (et installation de comprealraw(), sqcomprealraw() et
    powrealraw()).
151) [M1] anal.c: remplacement de match() par une macro et matcherr()
152) [M2] anal.c: Au retour d'une fonction, faire systematiquement UNE copie
    du resultat.
153) [M1] elliptic.c: le code commun a initell() et initell2() est factorise.
154) [M2] messages.c remplace par errmessages.c et helpmessages.c
155) [M1] tous les 0x77f+i remplaces par 0x77f +i pour satisfaire un 
    compilateur paranoiaque.
156) [B2] polarit1.c: gres() remplacer   if(tx<10) return gcopy(y);
    par if(tx<10) return gcopy(x);
157) [B2] arith2.c: kerint1(), av n'etait pas initialise.
158) [B1] gen2.c: lexcmp() lx etait dans certains cas utilise avant
    initialisation
159) [M1] supprime une quinzaine de variables locales inutiles.
160) [B1] gen2.c: ggval() case 3, initialisation de p1=cgeti(lgef(x[1])) et
    p2=cgeti(lgef(x[2])) etait necessaire.
161) [M2] polarit2.c: factor() type 10, modifie le code pour accepter des 
    polynomes a coefficients rationnels et pas seulement entiers ou modulo.
162) [M1] errmessages.c et erreurs.h: Enleve recer2 et modifie le message de
    recer1.
163) [M1] bibli1.c: Change setprecision() et setserieslength() pour retourner
    ce qu'il faut.
164) [N] polarit2.c: ecrit polfnf() (factornf() dans gp).
165) [M1] Mis a jour le manuel, pari.menu et testin.
166) [B1] gen2.c: gcmp_1() case 9: changer gcmp en !gegal
167) [N] polarit2.c: Installe nfiso() (isisom() dans gp) nfincl() (isincl()
    dans gp), et rootsof1().
168) [B1] trans3.c: polylog{p,d,dold}(2m+1,1) donnait 0.


----------------------------- Version 1.36beta3 ---------------------

169) [B1] polarit2.c: newtonpoly() remplacer VERYBIGINT par LARGERINT,
    defini dans gencom.h.
170) [B3] bibli1.c: lindep2() remplacer lll(p4,(prec<<1)-2) par lllint(p4).
171) [B2] bibli1.c: lllgramint() dans la double boucle initiale, ajouter
    coeff(lam,j,i)=zero, commencer a i=1 au lieu de i=2, et enlever 
    B[2]=coeff(x,1,1) qui precede.
172) [B1] gen3.c: ginv() corriger pour que le resultat soit une forme reduite
    dans le cas 15 et 16.
173) [N] arith2.c: ecrit et installe (enfin!) nucomp(), nudupl() et nupow().
    (apres essais, ils pourront remplacer la composition ordinaire).
    Au passage, quelques modifications esthetiques.
174) [M1] alglin2.c: dans kerint() remplacer l'appel a lll par un appel a
    lllint.
175) [M1] polarit2.c: factmod() tester si p<2^31.
176) [B1] bibli1.c: tous les lllgram* quand n<=1 ne pas retourner gcopy(x)
    mais idmat(n).
177) [N] alglin2.c: ecrit et installe kerint2() qui devrait etre meilleur que
    kerint.
178) [N] alglin2.c et bibli1.c: remplace kerint() par une nouvelle version,
    et ecrit et installe lllkerim() et lllgramkerim(). Le programme kerint()
    est habituellement plus rapide que kerint1() et kerint2().
179) [M1] supression de 8 variables locales inutilisees. Remplace isspace(c) par (isspace(c)) dans es.c

------------------------ Version 1.36 ---------------------------------------

180) [B1] gen3.c: gsubst() case 10, remplacer if(ty==6) z=poleval(x,y);
    else { vx=varn(x);l=lgef(x);... par
    vx=varn(x);if((ty==6)&&(v==vx)) z=poleval(x,y);else {l=lgef(x);...
181) [B1] arith1.c: fundunit(), changer x[lg(x)-1] en x[lgef(x)-1].
182) [B1] gen1.c: gadd(), case <10, case 11, corriger quand y=O(x^0):
    dans le troisieme grand else (correspondant a e=0), apres 
    z=cgetg(ly,ty);l=avma; remplacer p1=gadd(x,y[2]); par
    p1=(signe(y))?gadd(x,y[2]):x;
    Plus loin, remplacer else {z[1]=0x1008000;z[2]=(long)p1;...}
    par else {if(!signe(y)) z[1]=0x8000;else {z[1]=0x1008000;z[2]=... }}
183) [M1] gen2.c: gegal() type 15 et 16 traites correctement.
184) [M3] polarit2.c: ggcd() type<9 type>=9 pris en compte le contenu de y,
    et pris en compte les diviseurs simples des types 6 et 8. Modifie
    content() de facon analogue.
185) [B2] gen3.c: numer() et denom(), accepte tous types autres que formes
    quadratiques.
186) [B1] gen3.c: gsubst() case 11, case 10,13,14: remplace e*(lx-2) par
    e*(lx-2+ex).
187) [M1] elliptic.c: smallinitell() sort j=0 quand d=0 a la place d'une erreur.
188) [M2] arith1.c et arith2.c: "vectorise" les operations arithmetiques
   (de nombreuses modifications, aussi dans anal.c etc...)
189) [N] plot.X: ecrit et installe plothraw().
190) [B1] bibli2.c: suminf() remplacer affsr(1,y=cgetr(prec)) par y=gun.
191) [B3] arith2.c: nupow() remplacer le y=gerepile(.. final par
   return gerepile(...
192) [B1] trans3.c: sagm() case 6, remplacer prec=precision(x) par
   if(pp=precision(x)) prec=pp;

--------------------- Version 1.36.1 -----------------------------------

193) [N] elliptic.c: ecrit et installe akell().
194) [B1] helpmessages.c: corrige le message pour initell et initell2.
195) [M3] init.c: allocatemoremem(), double la pile Pari avant de faire un
   message d'erreur. A voir a l'usage.
196) [M2] elliptic.c: ordell() accepte aussi les rationnels.
197) [B1] elliptic.c: oncurve() remplacer -f+5 par -((f-2)<<5)+20.
198) [B2] polarit2.c: scalcontent() case 9 remplacer x[1] par x[2], et
   content() remplacer if(tx<10) par if(tx<9) et rajouter dans le switch
   case 9: return content(x[2]).
199) [M2] gen1.c: gadd() autorise l'addition scalaire/matrice dans certains 
   cas.
200) [N] bibli2.c et plot.X (ainsi que anal.c etc...): ecrit et installe les
   fonctions de rectplot. Sous GP: box(), cursor(), draw(), initrect(), 
   killrect(), line(), lines(), move(), point(), points(), rbox(), rline(), 
   rmove(), rpoint(), string().
201) [M1] gen2.c: modifie gtolong() pour accepter aussi le type reel et
   fractions non entieres (on arrondit).
202) [M1] trans2.c: garg() autorise les vecteurs/matrices.
203) [M1] polarit1.c: polinvmod() remplace invmoder par ginvmoder.
204) [B3] polarit2.c: sturmpart() oubliait d'ignorer les zeros.
205) [M2] gp.c et gpreadline.c: dans main() case '{' ajouter
   if((*tch2=='\\')&&(tch2[1]=='\\')) *tch2=0;
   juste apres le if(!fgets...). Ceci permet d'ecrire des commentaires dans une
   fonction.
206) [M3] partout, y compris dans le manuel, de nombreux petits changements
   pour avoir le moins de warnings possibles, declaration de toutes les 
   fonctions, mise au type void et int de celles qui doivent l'etre, et 
   quelques long prec oublies. Par souci d'etre complet, rajoute addssz(),
   subssz() et mulssz() dans mp.c.
207) [M2] trans3.c: theta() corrige pour rendre une valeur correcte quand z est
   complexe.
208) [N] plot.sun: ecrit plothraw() et draw() sous suntools.

--------------------- Version 1.36.2 -----------------------------------

209) [N] Incorpore buchimag() et buchreal(), et modifie les Makefile pour avoir
   buch.c en plus. Modifie egalement INSTALLATION en consequence.
210) [N] Mis la version HP-PA dans les sources.
211) [N] bibli2.c: Ecrit postploth(),postploth2(),postplothraw(),postdraw().
212) [B2] alglin2.c: dans le else a la fin de matrixqz() ajoute av1=avma;
   apres fl=1;
213) [B2] gen2.c: gcvtop() case 11:  oublie y=cgetg(lx,11) avant y[1]=x[1].
214) [B2] gen2.c: gpui() oublie av1=avma au debut du else final.
215) [B2] trans3.c: jbesselh() case 10,13,14 oubli av=avma initial.
216) [B2] gen1.c: gadd() case<10, case 19, oublie l=avma avant 
   p1=gscalmat(x,ly-1)
217) [B1] anal.c: rpoint remplace rectpoint par rectrpoint.
218) [M1] polarit1.c: poldivres() apres f=1 mettre l=avma, et dans le cas
   if(f) commencer par avma=l.
219) [M3] polarit1.c: poldivis() modifie la syntaxe, le resultat est cree et
   non plus affecte comme dans mpdivis. Modifie gen2.c ggval() en consequence.
220) [M1] gen2.c: ggval() mis av=avma et avma=av en facteur du tout.
221) [B2] elliptic.c: apell() corrige pour les cas de mauvaise reduction.

-------------------------- Version 1.37 --------------------------------

1) [B1] arith2.c: redreal() remplacer -expo(x[4]) par 31-expo(x[4]).
2) [M1] polarit1.c: factmod() ecrit une version un peu modifiee, conserve 
   l'ancienne sous le nom de factmod2() (non accessible sous GP).
3) [N] polarit1.c: ecrit et installe simplefactmod().
4) [M1] gencom.h: outbeaut() et consorts: remplace le printf("\n") par
   pariputc('\n').
5) [B1] manuel: corrige quelques erreurs de numerotation et autres.
6) [M1] elliptic.c: anell() envoie un message d'erreur quand n>49638.
7) [M1] (D. Carlisle) installe la version 2.10+ de pari.el, qui permet de
   completer des noms de commandes.
8) [B2] gen2.c: gaffect() case 14, case 9, remplacer gmod par gmodz.
9) [M1] plusieurs suppressions de parametres supplementaires inutiles.
10) [B2] arith1.c: hil() case 3, case 7: remplacer hil(x[2],y) par
   hil(x[2],y,x[1]).
11) [B3] gen2.c: gcvtop() case 19: remplacer gcvtop(x[i]) par gcvtop(x[i],p,r).
12) [B1] Quelques ajouts de parametres manquants.
13) [M1] bibli2.c: postploth() et postploth2() par souci de compatibilite,
   enleve toutes references a c2.
14) [B3] trans3.c: izeta() remplacer cgetg(prec) par cgetr(prec).
15) [B3] gen3.c: gmulxn() avant derniere ligne ajouter 2 fois le parametre
   &p2 a l'appel de gmulxn.
16) [M1] buch.c: supprime la ligne non atteinte.
17) [M2] bibli2.c: rectrbox() et rectrline() corrige pour que les parametres 
   soient relatifs au curseur, comme dans rpoint.
18) [B3] alglin1.c: concat() corrige une bug dans la concatenation 17,18 ou 
   18,17 quand les longueurs sont <=2.
19) [M3], [N] bibli2.c: ecrit rectscale() (scale() sous gp) et modifie toutes 
   les fonctions rect pour qu'elles acceptent un facteur d'echelle. Change la
   syntaxe de line et box (seulement 3 parametres maintenant).
20) [B2] alglin2.c: caradj() corrige pour que les matrices d'ordre pair donnent
   une matrice adjointe correcte.
21) [M3] gp.c, gpreadline.c et anal.c: modifie completement le systeme d'aide.
   La structure entree a maintenant un nouveau champ: long menu.
22) [B1] alglin2.c: caradj() corrige pour que les matrices de taille <=1 marchent.
23) [M2] bibli1.c: algdep2() et lindep2() modifie pour que la precision soit
   fournie en chiffres decimaux au lieu de bits.
24) [B3] gen2.c: gpuigs() n=0 case 13,case 14 remplacer varn(x) par gvar(x).
25) [M2] plot.X et plot.sun: dans ploth et ploth2 ajoute la variable prec et
   remplacer newvalue(cgetr(3)) par newvalue(cgetr(prec)). L'utilisateur doit 
   maintenant absolument passer en precision 9 si cela suffit sous peine de
   perdre du temps.
26) [M3] plot.X, plot.sun et bibli2.c: modifie les tailles et diverses choses. 
   Inverse la coordonnees y de plothraw pour etre semblable a ploth, et affiche
   les 4 valeurs extremes comme dans ploth. Idem pour les sorties postscript.
27) [M1] plot.X, plot.sun: quelques modifs esthetiques.


--------------------- Version 1.37.1 -----------------------------------

28) [M1] bibli1.c: setprecr() remplacer long m=(prec-3)/K1 par 
   long m=glbfmt[2];
29) [B3] polarit2.c: ggcd(), case 6 case 6 cas p1=0 modifie.
30) [N] base.c: ecrit et installe initalg2().
31) [B2] polarit2.c: sturm() remplacer if(dx==3) return 0 par if(dx<=4)
   return dx-3.
32) [M3] bibli2.c: somme() et produit() ont maintenant un sens quand a>b
   et donc ne renvoient plus d'erreur.
33) [M1] base.c et ailleurs: remplace tchirnhausen par tschirnhaus, et
   dans le programme lui-meme diminue la taille de la transformation
   aleatoire.
34) [M2] elliptic.c: lseriesell() modifie pour que l'on puisse utiliser des
   coefficients n>46438.
35) [B2] gen2.c: gabs() oublie ,prec dans les cas>=17.
36) [M1] modifie les noms des fichiers plot pour qu'ils terminent par .c
37) [B1] arith1.c: gener() pour m=4 doit rendre mod(3,4) et non mod(1,4).
38) [M1] oublie de mettre scale dans le manuel.
39) [B1] arith1.c: sfcont(), mettre l1=65535 si l1>65535.
40) [B1] gen2.c: gpuigs() dans le cas n=0 oublie le case 7.
41) [B1] alglin2.c: caradj() ne mettait pas la bonne variable.
42) [M2] es.c: remplace || pour impression de vvecteurs et matrices par [].
   A voir a l'usage.
43) [M1] gen3.c: gmodulo() et gmodulcp() autorise 1er argument a etre vecteur/
   matrice, ainsi que fraction.
44) [M1] introduit @ pour bell (ne marche pas sous emacs). A voir.
45) [M1] Version 2.12+ de pari.el de W. Carlisle, et unification (aussi du a
   lui) de index.tex et users.tex.
46) [B3] buch.c: Reecriture de buchreal.
47) [B3] base.c: smith() et smith2(), c++ etait mal place.
48) [M1] alglin1.c: inverseimage() accepte maintenant vecteurs et matrices
   comme deuxieme argument.
49) [M1] base.c: initalg() fournit maintenant 2 composantes supplementaires:
   l'inverse de la HNF de la base d'entiers, et la table de multiplication de 
   cette base.
50) [N] base.c: installe idealmul(), primedec(), idealmulprime(), idealval()
   ecrits par Tollis.
51) [B1] alglin2.c: caradj() cas l=1 et l=2: remplacer if(*py) par 
   if((long)py).
52) [M3] Rajoute un nouveau paragraphe au chapitre 3, specifique aux corps
   de nombres. Ceci a implique la modification de anal.c, gp.c, gpreadline.c
   et bien sur les fichiers TeX.
53) [M2] arith2.c: auxdecomp() modifie pour inclure un test carre parfait.
54) [N] base.c: installe ideallllred().
55) [N] polarit1.c: ecrit factorpadic() complet (Tollis). Ne marche pas encore
   completement.
56) [B1] arith2.c: numbdiv() dans le deuxieme for() remplacer l=2 par l=1.
57) [M1] arith2.c: rhorealnod() et redrealnod() y[4] est mis egal a x[4] au
   lieu de 0 en precision 3.
58) [B2] base.c: galois() remplace tous les roots par des rootslong.
59) [B1] bibli1.c minim() introduire une va normax pour renvoyer la norme 
   maximale en dessous de la borne demandee.
60) [N] bibli1.c: installe perf().

--------------------- Version 1.37.2 -----------------------------------

61) [B1] arith2.c: rhoreal() et redreal() remplacer le calcul de l au debut
   par   l=max(lg(x[4]),((31-expo(x[4]))>>5)+2);if(l<=2) l=3;
62) [B1] alglin2.c: kerint() ajouter if(lg(g)==1) return g;
63) [B1] alglin2.c: sqred2() changer signe en gsigne.
64) [M3] base.c: initalg() change la 5-eme composante pour renvoyer les 
   matrices M, MC et T2, et la 6-eme ne renvoie que les r1+r2 premieres 
   racines.
65) [M3] base.c: ideallllred() utilise MC.V.M ou T2 comme forme quadratiques
   plutot que l'identite.
66) [B3] gen3.c: gcvtoi() et grndtoi() : la precision rendue etait completement
   fausse (bien que du signe correct). La correction ralentit ces fonctions.
67) [M1] base.c: remplacer tous les gmodulo par des gmodulcp.
68) [M1] base.c: ideallllred(), remplacer vdir par 4^vdir (donc un simple
   gmul2n).
69) [B2] alglin1.c: detreel() remplacer av1=av par av1=avma.
70) [M2] buch.c: buchimag() et buchreal() modifie pour que l'on puisse tricher
   pour explorer plus rapidement. Le nombre de parametres de l'appel a augmente
   de 1. D'autre part dans buchreal, supprime la sortie de l'erreur et remplace
   par une verification interne.
71) [N] buch.c: ecrit et installe buchgen(), version du 11/10/92.
72) [M2] base.c: ecrit element_muli(), element_sqr() et modifie element_mul()
   et element_pow() pour accelerer. Considerablement simplifie lens() (il
   suffit de resoudre un systeme NxN et pas 2NxN).
73) [M3] base.c: rootsof1() considerablement ameliore et rend une racine 
   primitive de 1.
74) [M2] base.c et buch.c: ecrit idealmulh(), fasthnf() et ameliore idealval()
   et les diverses fonctions intervenant dans buchgen().
75) [B1] bibli1.c: minim() doit avoir u[2] renvoyer borne si flg=0.
76) [N] base.c: ecrit minideal().
77) [N] alglin1.c: ecrit deplin().
78) [B2] trans1.c: mpsc1
	remplacer 4 fois la sequence
	  setlg(p2,l4);setlg(p3,l4);setlg(p4,l4);
	par
	  if(l4<l5) { setlg(p2,l4);setlg(p3,l4);setlg(p4,l4);}
  (ajouter la variable locale l5 initialisee par l5=l2=l+1+m/32)
79) [M2] alglin1.c: rank reecrit
  (9 fois + rapide sur certaines matrices entieres)
80) [M3] buch.c: buchgen() et programmes qu'il utilise modifie plusieurs fois.
  Version du 3/12/92.
81) [B1] base.c: kerlens() modifie pour marcher avec un premier>32767.
82) [B2] trans2.c: mppsi() remplacer rtodbl(z) par rtodbl(absr(z)).
83) [B1] base.c: initalg() et initalg2() modifies pour marcher en degre 1.
84) [B3] base.c: initalg() et initalg2() modifiaient le polynome d'entree
  dans certains cas!
85) [N] base.c: ajoute le calcul de la differente et de la matrice Tr(om_iom_j)
  dans initalg, et la fonction idealinv().
86) [M1] base.c et bibli1.c: initalg(), initalg2() et polred() utiliser 
  lllgramint a la place de lllgram si r1=n.
87) [B3] base.c: kerlens() corrige a plusieurs endroits.
88) [M3] base.c: deplacer de buch.c a base.c hnfimag() et clean (renommes
  hnfmod() er cleanmod()), declares dans gencom.h, et dans idealmul() 
  remplacer hnf par hnfmod.
89) [M2] arith1.c: sfcont() case 4,5, ajouter 1 composante dans certains cas
  pour mieux reperer les approximations rationnelles.
90) [B3] mp.s (pas mp.c), mais en fait du a une utilisation exotique dans
  arith1.c: sfcont(). addsi: deplacer la mise du signe juste apres 7$.
91) [M1] base.c: transformer fasthnf() en un fasthnf modulo, et effectue
  quelques changements dans hnfmod.
92) [B1] elliptic.c: lseriesell() et anell() avaient encore quelques problemes
  pour de grands conducteurs.
93) [N] gen3.c: ajouter settype().
94) [M2] bibli1.c: modifie vecsort() pour faire des tris multiindices.
95) [M1] polarit2.c: discsr() vectorise.
96) [B1] anal.c: identifier type 5 oublie de rajouter prec.
97) [B3] genport.h: definitions de macros de subis(),subrs(),subisz(),subrsz()
    mettre des parentheses apres le signe -.


--------------------- Version 1.37.3 -----------------------------------

PASSAGE EN ANSI C. LA VERSION NON ANSI EST ARRETEE A CE STADE.

98) [B3] buch.c: dans les 3 programmes, free(mat[i]) etait incorrect car les
    pointeurs etaient perdus.
99) [B3] bibli1.c: reorder() la permutation utilisee etait l'inverse de la bonne!
    remplacer polvar[i+1]=lpolx[j];ordvar[j]=i; par
              polvar[j+1]=lpolx[i];ordvar[i]=j;
100) [M3] arith1.c: gcarreparfait() (issquare() dans GP) etendu a presque tous
    les types.
101) [M3] buch.c: buchall() incorpore la multiplication par un premier 
    supplementaire systematiquement.
102) [M1] arith1.c: binaire() etendu aux entiers longs, aux reels et aux
    vecteurs/matrices.
103) [B1] alglin2.c: jacobi() bug sur expo de 0 reel et coeffs entiers :
     remplacer if(((e=expo(x))<e1)&&(gsigne(x))) e1=e;
         par    if((e=expo(x))<e1) e1=e;
	et   e2=expo(gcoeff(a,1,2));p=1;q=2;
        par  e2= -0x800000;
104) [M1] init.c: err() uniformise les newlines.
105) [B3] buch.c: quelques variables non-initialisees.
106) [N] base.c: installe initalg0().
107) [B3] base.c: galois() case 5: parentheses mal placees dans le 
   while ((l<=6)&&..).
108) [N] alglin1.c: ecrit hnfspec(),hnffinal(),hnfadd() pour l'usage de
   buchxxx.
109) [M3] buch.c: modifications importantes des programmes buchxxx.

--------------------- Version 1.37.4 -----------------------------------

110) [B1] base.c: smith2() rendait un resultat incorrect en cas de matrice
   vide.
111) [N] base.c: ecrit idealpow() et idealpowprime().
112) [N] bibli1.c: ecrit setrand().
113) [N] base.c et buch.c: ecrit buchinit() et isprincipal().
114) [N] base.c: ecrit isideal().
115) [M1] gen3.c: gmod(x,y) accepte y de type reel/fraction.
116) [B3] buch.c: nombreuses modifications a isprincipal().
117) [M1] et [N] base.c: idealmul accepte tous ideaux, et ecrit idealmulred().
118) [B1] gen1.c: quelques modifications concernant les matrices vides.
119) [M1] base.c: modifie idealmul pour accepter ideaux fractionnaires et
   premiers.
120) [M1] base.c: modifie idealpow pour accepter ldeaux premiers.
121) [N] base.c: ecrit idealpowred().
122) [B3] buch.c: corrige une bug dans l'utilisation de largeprime dans
   buchreal.
123) [B3] bibli1.c: ecrit mymyrand() pour utilisation dans les machines a base
   de SysV.
124) [B1] buch.c et elliptic.c: quelques petites bugs corrigees.
125) [B2] trans1.c: gsqrt() case 6, change signe en gsigne et corrige le calcul
   dans le cas x[1]<0 pour que l'argument soit dans ]-pi/2,pi/2].
126) [B1] gen3.c: integ() case 11, vx==v: modifie pour accepter d'integrer des
   series de residu nul.
127) [M1] helpmessages.c: subst() modifie le message.
128) [N] base.c: ecrit ROUND 4 (Ford-Letard) et remplace les appels a ROUND 2
   par ROUND 4. Round 2 conserve dans la fonction base2().
129) [N] arith1.c: ecrit bestappr().
130) [N] alglin1.c: ecrit imagereel() (imager() dans GP), et modifie le 
   epsilon utilise dans kerreel.
131) [M3] factmod accepte maintenant p>=2^31.
132) [N] alglin2.c: ecrit conjvec().
133) [M1] bibli1.c: modifie les fonctions liees a rand() pour ne plus 
   dependre du systeme. Introduit en particulier la variable globale
   pari_randseed. La fonction C rand() ne doit donc plus etre utilisee.
134) [M1] es.c: sori(), enleve un espace inutile dans les matrices.
135) [N] gen2.c: ecrit vecmin() et vecmax().
136) [N] polarit1.c: ecrit factorpadic4() implemente par Letard , utilisant 
   ROUND 4. Cette version s'apelle factorpadic() sous GP, et l'ancienne 
   version est conservee sous le nom de factorpadic2().
137) [B3] gen1.c, gen2.c: pour les p-adiques, remplacer les y[2]=x[2] et
   semblables par y[2]=(long)copyifstack((GEN)x[2]); 
138) [M1] mp.c, genpariother.h: applique protoize a mp.c (oubli), et mettre
   stdlib dans un #ifdef __cplusplus.
139) [B3] buch.c et alglin1.c: corrige de nombreuses bugs dues a l'ajout de
   lignes dependantes dans buchxxx.
140) [M1] init.c et gencom.h: supprime les constantes C4 et CN31.
141) [M1] polarit1.c: enleve quelques variables inutilisees.

--------------------- Version 1.37.5 -----------------------------------

142) [M9] TOUT: avec l'aide de J. Kouhia, profondes modifications pour pouvoir
   compiler sur des machines 64 bits. En principe, la seule restriction 
   restante est que sizeof(long)=sizeof(pointeur sur type elementaire)=
   puissance de 2 superieure ou egale a 4. Pas encore teste.
143) [B1] alglin1.c: traite plus correctement les matrices vides a quelques
   endroits.
144) [M3] buch.c: corrige completement buchimag pour le mettre d'accord avec
   buchgen (il reste buchreal a faire).
145) [M3] buch.c: idem pour buchreal, qui donne maintenant aussi les
   generateurs.
146) [B3] alglin1.c: au passage, de nombreuses bugs corrigees dans hnfspec()
   hnffinal() et hnfadd().
147) [N] bibli1.c: ecrit getrand(). Pas fondamental mais utile pour debugger.
148) [B3] buch.c, alglin1.c: fin (definitive?) du debuggage de buchxxx:
   diverses erreurs, en particuler dans subfactorbase{imag,real}.
149) [N] bibli1.c: ecrit getstack() et gettime().
150) [M1] base.c et buch.c: ajouter une verification de longueur dans 
   idealmulprime() et quelques reductions supplementaires dans isprincipal().
151) [M1] base.c: ideallllred() autorise des vecteurs a composantes non
   entieres.
152) [N] elliptic.c: ecrit taniyama().
153) [N] gen2.c: bytesize() (taille2() en mode librairie) disponible dans GP.
154) [B1] buch.c: buchxxx() quelques bugs dues au doublement de cbach et a
   une factorbase vide.
155) [N] alglin1.c: ecrit detint().
156) [M1] elliptic.c: par souci d'homogeneite, inverse la syntaxe de powell et
   compagnie.
157) [M1] buch.c: par souci d'homogeneite, change le signe de la 3-ieme 
   composante de isprincipal.
158) [M1] elliptic.c: nombres de Tamagawa donnes dans globalred() et
   localred().
159) [N], [M1] elliptic.c: change matell en mathell, vectorise hell(), et ecrit
   bilhell().
160) [N] elliptic.c: ecrit orderell() et torsell().
161) [M1] arith2.c: change compose() en compimag() et redcomp() en redimag().
162) [M2] helpmessages.c: reecrit un certain nombre de messages.
163) [B?] mp.c: itos() ajoute un (ulong) devant HIGHBIT par securite.
164) [B3] gen2.c: gpui() remplace le test pour appel a gpuigs au debut par
    lx=lgef(n);
    if((lx==2)||((lx==3)&&((ulong)n[2]<(ulong)HIGHBIT)))
      y=gpuigs(x,itos(n),prec);
165) [M1] polarit1.c: factmod9() ajouter une erreur si va<=vf.
166) [M2] polarit2.c: polfnf() supprimer oldpolfnf() et modifie le nouveau
    pour etre compatible avec factmod9(). En particulier la variable du corps
    de nombres doit maintenant etre de priorite inferieure a celle du polynome.

--------------------- Version 1.37.6 -----------------------------------

167) [N] base.c: ecrit idealfactor(), idealadd(), idealdiv(), idealintersect().
168) [M1] base.c: hnf() autorise les coeffs rationnels, et idealval(), idealfactor()
    autorise les ideaux fractionnaires.
169) [M3] coupe base.c en base1.c et base2.c.
170) [N] base2.c: ecrit hnfhavas() (hermitehavas() dans GP).
171) [M1] anal.c: supprime l'acces de GP a idealmulprime et idealpowprime.
172) [M3] base2.c: autorise tous les types possibles dans les operations
    entre ideaux.
173) [N] base2.c: ecrit principalideal() et principalidele().
174) [N] buch.c: ecrit isunit() et modifie getfu() pour que la matrice des
    plongements log. corresponde exactement aux unites donnees.
175) [M1] buch.c: "ecrit" buchinitfu, modifie la 8-eme composante de buchinit
    et change buchgen en buchgenfu, buchgennou en buchgen.
176) [M1] buch.c: les 3 programmes, modifie l'utilisation de la 2-ieme cte de
    Bach pour que la grande factor base ne soit pas trop petite.

--------------------- Version 1.38 -----------------------------------
