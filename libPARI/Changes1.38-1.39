(Modifications de 1.35 a 1.38 dans le fichier Changes1.35-1.38)
--------------------------------------------------------------------------
Modifications a la version 1.38.

Code: B: bug, M: modification, N: nouveau programme, D: erreur de doc.
1 a 3: de peu important a tres important

1) [M1] elliptic.c: apell(), utiliser apell2() pour p<=457.
2) [N] arith1.c: ecrit quaddisc().
3) [N] init.c: attrape les signaux SIGSEGV et SIGBUS.
4) [B1] plusieurs: traite les matrices vides dans gsqr(), hnf(), hnfhavas(),
   gscal().
5) [B1] buch.c: buchall() image_det pouvait ne pas etre carree.
6) [M1] manuel: oublie rootslong.
7) [B3] base2.c: allbase4() modifications importantes dues a une erreur
   theorique dans l'implementation de round 4.
8) [B2] polarit2.c: srgcd() enleve toute utilisation de com (devrait accelerer
   les PGCD de polynomes de degre >10).
9) [M1] examples/tutnfxxx, modifie pour etre compatible avec nouvel initalg.
10) [M1] buch.c, gencom.h, init.c: quelques modifs due a la version alpha.
11) [M1] trans1.c: mpsc1(), change y=cgetg(l) en y=cgetg(l-1).
12) [M2] gp.c: possibilite de simplification automatique des resultats
   (commande \y).
13) [B1] gen3.c: simplify() case 8 etait incorrect.
14) [M1] partout: introduit la variable DEBUGLEVEL et la commande \g qui permet
   de la fixer.
15) [M1] es.c et versionxxx.c: globalisation du numero de version avec la 
   fonction printversionno().
16) [B1] base2.c: encore une bug dans allbase4().
17) [M2] base2.c: modifie allbase4() pour utiliser plus efficacement Dedekind.
   base etc... devrait etre beaucoup plus rapide dans la plupart des cas.
18) [M1] buch.c, alglin1.c: modifie les impressions quand DEBUGLEVEL>0.
19) [M1] buch.c: buchxxx(), elimination des relations supplementaires nulles.
20) [B3] alglin1.c: hnfadd() oublie de composer vperm avec permpro.
21) [M2] buch.c: isprincipal() pour grands ideaux.
22) [N]  init.c: allocatemem() peut maintenant etre appele de GP, et avec
   une taille variable (ancien nom allocatemoremem() change, mais existe en 
   interne).
23) [M1] partout: les warnings et erreurs sont maintenants tous diriges vers
   le fichier global errfile (initialise a stderr), qu'il est donc trivial de
   rediriger.
24) [M3] buch.c: buchall() ajoute be honest.
25) [B3] alglin2.c: invmulmat() parfois completement faux dans le cas de coeffs
   reels (probablement aussi d'autres programmes d'alglin). Corrige au moins
   pour les types reels et complexes.
26) [B1] buch.c: buchall() en consequence de 25), appele invmulmatreel au lieu
   de invmulmat (2 fois).
27) [B1] init.c, gp.c: l'initialisation de outfile etc... doit etre fait dans
   init() et pas dans main().
28) [B2] buch.c, buchall(): change la generation des relations supplementaires.
29) [B2] buch.c, getfu(), oublie de modifie xarch.
30) [N] buch.c: ecrit signunit().
31) [B1] trans1.c: palog(), utilise mpshiftz() sur qqchose qui peut etre 
   universel. Corrige. N'avait d'effet que dans le calcul de log 2-adiques.
32) [B2], [M1] arith2.c: ellfacteur(), remplace if(glob = ellmult(k)) par
   if((glob = ellmult(k))&&(cmpii(glob,n))). Egalement remplace 
   nombre=10*lgef(n1) par nombre=5*(lgef(n1)-2).
33) [B1] bibli1.c, lllgramall() incorrect quand lx<=2.
34) [M1] gen2.c, gaffect() mettre un message d'erreur en cas d'ecrasement d'un
   object universel.
35) [B2] polarit1.c: splitgen(), gestion de pile erronee.
36) [B3] buch.c, buchall(): relations supplementaires mal traitees. Introduit
   subvperm.
37) [M2] base2.c, allbase4() et differente() remplace l'appel de hnf par 
   hnfmod.
38) [B2] base2.c, allbase4() et annexes, remplace plusieurs fois des cgetg(,17)
   par cgetg(,18) (colonnes de matrices).
39) [B2] gen2.c, gneg() case 1, retourne le zero universel si x=0.
40) [B2] base2.c, idealval() erreur dans le cas ou il y a un denominateur.
41) [M2] base2.c, idealval() reecrit dans le cas d'un nombre algebrique pour
   etre plus rapide (programme interne elementval()).
42) [M2] base2.c, differente() reecrit, en utilisant v=e-1 dans
   le cas modere, f'(alpha) dans le cas d'une base de puissances, et programme
   interne idealmulspec() pour multiplier par un ideal aZ_K+alpha Z_K de norme
   n connue.
43) [M1] elliptic.c, pointell(): rajoute une gestion de pile interne.
44) [M1] base2.c, allbase4() ameliore pour les grands p.
45) [M3] base1.c, base2.c: nombreuses modifications pour accelerer le calcul de
   de initalg0.
46) [M2] buch.c, base1.c, etc... remplace partout ou possible hnf(x) par
   hnfmod(x,detint(x)) ou semblable.
47) [M1] buch.c, isprincipal() accepte les types 9 et 10.
48) [M1] base2.c, ideallllred() accepte les ideaux premiers.
49) [B1] base2.c, idealfactor() etait faux pour les ideaux non entiers.
50) [M3] base2.c, buch.c: nombreuses modifications aux programmes 
   factorisegen(), ideallllred(),.... Les programmes buchgenxx et buchinitxx 
   sont maintenant BEAUCOUP plus rapides.
51) [M3] buch.c separe en deux fichiers buch1.c et buch2.c.
52) [M1] buch1.c, ecrit freehash() pour liberer correctement la hashtable.
53) [M2] plusieurs: nettoyer pour rendre a nouveau la compilation C++ propre
   (oublie de la faire dans la release 1.38).
54) [M3] mp.s et variantes, gen68k.h: pour la version 68k uniquement, mettre
   les fonctions comme typ(), lg(), etc... en macros au lieu d'assembleur.
   Gain 8% sur testin.
55) [M2] mp.c, gen*.c: grace a des suggestions de Purify, remplace les
   setsigne(), etc... par des evalsigne()... quand c'est possible. Gain 1.5%
   sur testin.
56) [N] base1.c: (Diaz y diaz) ecrit compositum(), mais pour l'instant 
   seulement si tous les compositums sont conjugues.
57) [N] polarit1.c: ecrit factberl() (factorisation avec Berlekamp). 
58) [M3] (B. Haible) enleve de nombreuses variables inutilisees, explique
   a gcc que err() ne retourne jamais, remplacement des %lf par %f, reecriture
   de gpreadline.c, plusieurs modifications des versions 386.
59) [B1] gen3.c, gmodulcp() remplacer 2 fois ty par tx, comme dans gmodulo.
60) [B1] gen3.c, recip() rajouter y[2]=un avant l'appel de recip a la fin.
61) [M3] base2.c, primedec() beaucoup accelere quand p divise l'indice grace
   a Francisco, et lens() inutile quand p ne divise pas l'indice (et dans 
   d'autres cas).
62) [B1] alglin1.c, detint() et keri(), remplacer les calculs sur place par des
   allocations dynamiques.
63) [B1] bibli1.c, mymyrand() mis au type long.
64) [B1] init.c, err() ajouter outfile=stdout avant de sortir.
65) [B1] alglin1.c, rank() p1=gun oublie.
66) [N] bibli2.c, ecrit quelques operations sur les ensembles: isset(), 
   gtoset() (set() dans GP), setsearch(), setunion(), setintersect(), 
   setminus().
67) [M1] buch2.c: CBUCHG n'est plus constante mais determinee dans le 
   programme.
68) [M1] Makemakefile ne met plus l'option -Aa our gcc sur HP
69) [M2] SIGBUS n'est pas standard. Une definition ad hoc pour HP est donnee.
70) [B1] bibli1.c, permute(): remplacer tetpil=av par tetpil=avma.
71) [M1] alglin1.c, indexrank(): ajoute gestion de pile interne.
72) [B1] base1.c, initalg() et initalgall0(): gsubst(...,0,...) remplace par
   gsubst(...,v,...) (donnait des resultats incorrects quand la variable
   n'etait pas x).
73) [M3] bibli1.c, lllgram() utilise kmax ce qui devrait rendre LLL 
   un peu plus stable.
74) [B3] polarit2.c, subres(): signe du resultant faux quand degre(x)<degre(y)
   et tous deux impairs.
75) [N] polarit2.c, ecrit subresext() (pour utilisation dans polinvmod entre
   autres), et incidemment bezoutres().
76) [B3] elliptic.c, localreduction() cas p > 3 non minimal incorrect.
   Remplacer p4k =  mulii(p2k, pk); par p4k = mulii(p2k, p2k);
77) [M3] polarit2.c, polinvmod() modifie pour utiliser subresext au lieu de
   bezout.
78) [M3] buch2.c, base2.c: nombreuses petites modifications pour ameliorer
   buchall(), et mis DEBUGLEVEL aussi dans buchimag et buchreal.
79) [B1] buch1.c, buchimag(), buchreal(): be honest n'etait pas fait 
   correctement.
80) [N] es.c, gp*.c: ecrit brutiall(), bruteall(), ecrireall(), et putsignb(),
   et appele bruteall pour que \w n'imprime plus de blancs.
81) [N] buch1.c, buch2.c, anal.c: les programmes buchxxx() peuvent maintenant
   prendre un nombre quelconque de parametres.
82) [M1] es.c, ecrireall(): modifie pour que l'on puisse ecrire des
   grands exposants negatifs/positifs.
83) [N] alglin1.c: (Batut) ecrit hnfnew() (hermitebatut() dans GP).
84) [N] base1.c: (avec Tollis) ecrit initzeta() et zetak().
85) [N] alglin1.c: (Batut) ecrit hnfperm() (hermiteperm() dans GP).
86) [M1] base2.c: les resultats de round4 sont centres, comme ceux de round2.
87) [B1] elliptic.c, zell(): modifie le test d'arret.
88) [B10] mp.c, mpin.c: BUG DANS LE NOYAU PARI (pas en assembleur)!!!
  dvmdii() et divrr() modifies.
89) [B3] arith1.c, sfcont() bug corrigee.
90) [N] bibli1.c: ecrit sumalt2() (F. Villegas) et echange avec sumalt().
91) [M3] polarit1.c, polarit2.c: completement reecrit bezoutpol() et 
  gbezout(). 100 fois plus rapide dans certains cas!
92) [M2] polarit1.c: roots() et rootslong(), mis un message d'erreur quand
  les racines sont fausses.
93) [B1] partout: ajouter des adecaler partout ou necessaire.
94) [B2] trans1.c, gsincos() type 11: oublie return quand ex2>lx.
95) [M2] bibli1.c, sumpos(): reecrit pour utiliser le nouveau sumalt.
   Garde l'ancien sous le nom de sumposold.
96) [B1] init.c: K2 modifie pour 64-bits.
97) [N] bibli1.c: ecrit dirmul(), dirdiv(), dirzetak() (manipulation de
   series de Dirichlet).
98) [B3] bibli1.c, lllgram(): enorme bug corrigee suite a la modif kmax
   (modif 73 ci-dessus).
99) [M1] sparcv8micro.s et sparcv8super.s, divll(): ajouter optionellement
   deux nop pour satisfaire a l'architecture de certains processeurs tels
   l'hypersparc de Ross.
100) [M4] buch2.c: incorpore la version utilisant les nombres de petite
   norme, beaucoup plus rapide.
101) [M1] gp.c: la commande \r complete si besoin est par .gp.
102) [M1] gen2.c, gegal(): ne donne plus de message d'erreur dans le
   cas de vecteurs/matrices de tailles incompatibles (mais en donne
   toujours si les types sont differents et incompatibles).
103) [B1] mp.c (et mpin.c), addrr(): si y est nul remplacer if(e<=0)
   par if(e<0)  , Idem si y non nul et x nul.
104) [B3] mp.c (et mpin.c), divis(): le signe du reste etait incorrect.
105) [M3] buch2.c, buchall(): Encore de nombreuses modifications.
106) [N] buch2.c, buchall(): ecrit buchgenforcefu() et buchinitforcefu().
107) [M3] base1.c: initzeta() et zetak() grandement ameliores, et ecrit
   lambdak().
108) [B3] mpdefs.h: certaines macros etaient interpretees a tort comme
   non signees par certains compilateurs. Il y a maintenant un cast 
   (long).
109) [B1] gencom.h: ccontent() n'etait pas declare.
110) [M1] base2.c, two_elt(): gere la pile.
111) [B3] mp.c (et mpin.c), divrr(): l'algorithme n'etait pas correct!
   Cela donne un message d'erreur (donc pas trop grave) dans les versions
   autres que 680x0, mais un resultat faux dans les versions 680x0.
112) [M3] versionport.c (et version68k.c, mais la ce n'est pas important),
   simplifie notablement addll, addllx, subll et subllx, d'ou une
   amelioration de temps de 15%.
113) [M3] base2.c, two_elt(): notablement ameliore l'algorithme.
114) [N] polarit1.c: ecrit roots2() (racines par Laguerre).

Les changements suivants (jusqu'au 133) sont dus a M. Huizing et
P. Montgomery ou a des suggestions de leur part.

115) [M3] versionport.c et mpin.h: reecrits plusieurs modules (P.
   Montgomery), ce qui ameliore les performances de 10% environ.
116) [M1] gen3.c, gmodulo() et gmodulcp(): prend la valeur absolue du
   modulo.
117) [B1] bibli2.c, vecteur() et matrice(): mis des messages d'erreurs 
   quand le nombre de composantes est trop grand.
118) [B1] arith1.c, mpsqrtmod(): la variable modifiee a la fin devait
   etre v et non y. Le resultat est maintenant dans [0,p/2].
119) [M1] polarit2.c, glcm(): change dans le cas entier pour etre toujours
   positif ou nul.
120) [M1] mp.c et mpin.c, dbltor(): modifie pour rendre prec=3 en cas de
   machines 64 bits.
121) [B1] mp.c et mpin.c, divrs(): ajouter un if(sh) a la fin.
122) [N] arith2.c, addprimestotable() (addprimes() sous GP).
123) [M1] arith2.c, auxdecomp(): utilise les premiers ajoute par
   addprimes() apres sa table de premiers.
124) [M1] arith1.c, chinois(): accepte maintenant des types quelconques,
   en particulier des polynomes, vecteurs et matrices.
125) [M3] base1.c, base2.c idealinv(), initalg() et initalg0(): 
   l'utilisation de la differente n'est PAS necessaire pour inverser un
   ideal. D'ou modification du programme et du format de sortie de 
   initalg.
126) [N] gen3.c, gdivround(): division arrondie. Ajoute l'operateur
   binaire \/ sous GP.
127) [N] gen3.c, gerepilemany(): gerepile pour objets multiples.
128) [N] es.c, gitoascii(): conversion d'uun entier de PARI en chaine de
   caracteres.
129) [N] base2.c, idealdivexact(): division d'ideaux quand le quotient 
   est entier.
130) [N] base2.c, idealnorm(): norme d'un ideal.
131) [N] base2.c, idealpows() (est-ce utile?).
132) [N] bibli1.c, lllintpartial(): reduction partielle et rapide d'un
   reseau.
133) [D3] partout: de tres nombreuses corrections au manuel.
134) [N] gen3.c, integ(): ecrit l'integration des fractions rationnelles
   (forme simple).
135) [N] base2.c, ideal_two_elt() (idealtwoelt() sous GP).
136) [B1] arith2.c, nucomp() et nudupl(): remplace cmpii(v3,l) par
   cmpii(absi(v3),l).
137) [N] base2.c: ecrit idealhermite(), idealhermite2(), idealaddone(), 
   idealaddmultone(), idealappr(), idealapprfact(), ideal_two_elt2()
   (idealtwoelt2() sous GP).
138) [M1] base2.c, idealintersect(): accepte des ideaux fractionnaires.
139) [B1] base2.c, idealadd(): resultat corrige quand un ideal est donne
   par des Z_K-generateurs.
140) [N] polarit2.c: gisirreducible() (isirreducible sous GP).
141) [N] bibli2.c: ecrit forvec().
142) [B1] base2.c, idealadd() et idealpow(): acceptent maintenant des
   ideaux fractionnaires.
143) [M1] gen3.c, denom(): ameliore dans le cas de type vecteur/matrice.
144) [M1] elliptic.c, oncurve(): modifie le test dans le cas reel.
145) [M1] partout: enleve des warnings de compilo.
146) [B2] gen3.c, gand() et gor(): change la definition pour correspondre
   au comportement du C (pas d'evaluation inutile). Malheureusement ca
   ne suffit pas.
147) [B1] arith2.c, pur(): mis un test de fin de table de premiers.
148) [B2] polarit1.c, rootslong(): oublie av1=avma au debut dans le
   changement 114.
149) [B2], [M3] base2.c, idealfactor(), idealapprall(): quelques bugs 
   corrigees, et possibilite d'avoir des exposants negatifs.
150) [N] base2.c: ecrit idealcoprime(), basistoalg(), algtobasis(), 
   threetotwo().
151) [B3] polarit2.c, subresext(): bug quand l'un des polynomes etait
   constant.
152) [N] base2.c: ecrit nfdiveuc(), nfdivres(), nfmod(), et rendu
   accessible par GP element_mul() (nfmul()), element_div() (nfdiv())
   et element_val() (nfval()). Les fonctions elementval et elementval2
   changent de nom et s'appellent element_val et element_val2.
153) [M2] base2.c: modifie beaucoup de programmes pour qu'ils acceptent
   des elements comme des ideaux principaux.
154) [M3] base1.c et base2.c coupes en trois morceaux base1.c, base2.c et
   base 3.c.
155) [N] base3.c: ecrit twototwo() et weakhermite().
156) [B2] polarit1.c, polinvmod(): le test d'erreur ne tenait pas compte
   des variables secondaires.
157) [B3] polarit2.c, subresext(): bug dans la gestion de pile (apres 
   modif. 151).
158) [B3] gen1.c, gen3.c, polarit2.c: case 9 mod case 9 et 10, oublie les
   cas ou les variables ne sont pas les memes.
159) [B3] alglin2.c, caradj0(): doit tester les numeros de variables.
160) [B3] gen3.c, gsubst() case 9: doit tester les numeros de variables.
161) [B1] base1.c, initalg(): cas particulier degre 1 traite.
162) [B1] buch2.c, buchall(): ne rendait pas la bonne variable en 
   degre 1.
163) [B3] buch2.c, isprincipal(): ne marchait pas en degre 1.
164) [N] base2.c, base3.c: ecrit nfhermite(), rnfpseudobasis(),
   rnfdiscf(), rnfsimplifybasis(), rnfsteinitz(), rnfbasis(), rnfisfree(),
   et nombreux sous-programmes auxilliaires : nfreducemodpr(), 
   rnfelement_mulmod(), rnfelement_sqrmod(), rnfelement_powmod(), 
   rnfordmax(), rnfjoinmodules(), nfidealdet1(), nfker(), nfgauss(),
   nfsuppl(),nfdetint().
165) [B2] elliptic.c, coordch(): y[14] et apres etaient incorrects
   dans le cas p-adique.
166) [M3] et [N]: introduit le patch de Ilya Zakharevitch du 23/09/94,
   et en particulier les fonctions compactarrays(), permuteInv()
   (permutation2num sous GP), ainsi qu'une amelioration de permute().
   On dispose de completion (avec TAB) en dehors d'emacs.
167) [M2] base1.c, initalgall0(): dans la modification P.M., remplace
   hnf par hnfmod.
168) [B2] base3.c, idealadd() et idealintersect(): erreur pour transformer
   y par idealhermite.
169) [B1] base3.c: plusieurs endroits, modifie pour accepter ideaux nuls
   (il en reste proablement d'autres).
170) [B3] polarit1.c, gres(): pile mal geree.
171) [M1] basex.c: plusieurs petits changements pour accelerer les 
   operations sur les elements, en particulier ecriture et utilisation de
   isnfscalar().
172) [N] base3.c: ecrit nfhermitemod() et enleve weakhermite().
173) [N] base3.c: ecrit idealmullll() et idealdivlll() et remplace dans
   les appels de nfcleanmod les ideal{mul/div} par ideal{mul/div}lll.
   Egalement utilise lllintpartial au lieu de lllint.
174) [M3] plusieurs: initalg renomme en initalgred, initalg2 en 
   initalgred2 et initalg0 en initalg.
175) [B1], [M2] bibli1.c, lllintpartial(): division par zero quand un 
   produit scalaire s'annulait. Modifie pour supprimer les colonnes de
   zeros initiales.
176) [N] base2.c: Ecrit rnfhermitebasis().
177) [M1] base2.c: ecrit checknf() et checkbnf(), et autorise les bnf
   la ou nf est attendu.
178) [B1] polarit2.c, isisom() et isincl(): modifie pour que le resultat
   soit correct pour des polynomes non unitaires.
179) [N] bibli1.c: ecrit polredabs().
180) [M2] polarit1.c, split9() et stopoly9(): modifies pour accepter des
   corps finis avec >2^31 elements.
181) [M1] polarit2.c, sturm(): oublie v= devant gdiv(v,content(v)) (sans 
   importance).
182) [M1] basex.c: renomme les fonctions base en basis.
183) [M3], [N] partout: introduit le nouveau patch de I.Z. En particulier,
   fprintferr(), flusherr() et nouvelle fonction gen2str().
184) [B1] buch2.c, buchall(): modifie pour que les (tres) petits corps
   marchent aussi.
185) [M1] base3.c, idealaddone(): modifie pour etre plus rapide dans
   beaucoup de cas.
186) [M3] plusieurs: change le generateur aleatoire pour etre modulo 2^31
   quel que soit le nb de bits. Introduit la variable BITS_IN_RANDOM.
187) [N] base3.c: ecrit nfsmith().
188) [M1] introduit les variables DEFAULTPREC, MEDDEFAULTPREC et 
   BIGDEFAULTPREC et modifie partout pour avoir un debut de coherence
   32/64 bits.
189) [B1] base3.c, idealmul(): ne marchait pas quand un ideal etait nul.
190) [M1] factorpadic: option de debugage ...
191) [B1] plusieurs variables en trop et/ou non initialisees.
   The next 3 changes are due to Bruce Kaskel
192) [B1] gen2.c, gaffect() case 7, case 3: remplace x[4] par gtrunc(x)
193) [N] gen3.c: ecrit gpolvar() (polvar() sous GP).
194) [M3] polarit2.c, combine_factors(), squff(): modifie de plusieurs
   manieres pour accelerer et eviter les debordements de pile.
195) [M3] basex.c, allbase4(), differente(): change le nombre de 
   parametres pour un calcul plus efficace de la differente.
196) [M3] basex.c: ameliore idealhermite(), ideal_two_elt(). Modifie
   hnfmod pour accepter un detint nul.
197) [M1] quelques modifs pour CodeWarrior.
198) [B2] anal.c, identifier(): bug de portabilite, modifie les cas 51-55.
199) [M1] arith1.c, gener(): legerement reecrit.
200) [N] arith1.c: ecrit znstar().
201) [B2] es.c, ecrireall(): corrige impression format 'e', cas <0, et
   impression en format exponentiel a la place de * en cas de perte de
   precision.
202) [N] buch2.c: ecrit buchnarrow() et isprincipalgen() et ajoute deux
parametres a buchall.
203) [M2] gp*.c: rajoute des fonctionalites readline et le fichier gp_rl.c
204) [B2] mp.c: erreur dans dbltor() quand x<0.
205) [M1] mis a jour le manuel en ce qui concerne les manipulations dans
  les corps de nombres.
206) [M1] basex.c(): en principe toutes les operations sur les corps de
  nombres qui necessitaient un petit nf acceptent aussi un grand bnf.
207) [B1] gen3.c, karamul(): bug corrigee.
208) [B3] gencom.h: les macros mateltsize et matcolsize sont corrigees
209) [M2] init.c et es.c: \q n'est plus necessaire a la fin d'un fichier
210) [B2] anal.c: nouvelle valence 87 necessaire pour forvec.
211) [B3] polarit1.c et polarit2.c: polinvmod(),srgcd(),typecorps(),
  bezoutpol(),subresext() modifies en testant le type (exact ou non) des 
  polynomes.
212) [N] bibli1.c: ecrit getheap().
213) [B1], [M4] partout: gros nettoyage general. En particulier, les fonctions
  primeform, gabs, gpui, gpuigs sont declares de la meme maniere en C/C++ et
  doivent prendre respectivement 3,2,3,2 parametres.
214) [N], [M3] bibli1.c et ailleurs: ecrit ggrandocp(), qui est appele
  systematiquement a la place de ggrando(), sauf quand on veut vraiment un
  objet permanent comme dans le O() de GP. Ecrit gdiv() case 7/case 1,2,4,5
  explicitement.
215) [M1] bibli1.c, gprec(): ajoute le type 10.
216) [M2] gen3.c, gsubst() et gmulsg() type 10: modification quand le polynome
  est non exactement nul (il faudrait faire ca partout mais verifier que ca ne
  casse rien).
217) [N] buch2.c: ecrit buchfu().
218) [N] polarit2.c: ecrit sylvestermatrix(x,y).
219) [M2] polarit1.c, gres(): modifie le debut pour accepter 1/mod(y,x) par ex.
220) [M3] polarit1.c, polinvmod(): reecrit completement. Les p-adiques sont
  beaucoup mieux traites.
221) [B1] buch1.c, buchimag() et buchreal(): erreur dans le malloc(vinvperm).
222) [M1] partout: plusieurs modifications mineures.
223) [N] gen3.c: ecrit padicprec.
224) [B1] gen2.c, gexpo(): type 8 bugge.
225) [M1] elliptic.c, zell(): modifie pour accepte types complexes. Toutefois
  la determination n'est pas encore claire.
226) [N] base1.c: ecrit un nouveau galoisconj (p-adique), renomme l'ancien
  galoisconj2 en galoisconj1, et l'ancien galoisconj en galoisconj2, qui n'est
  plus accessible de GP (a supprimer bientot).
227) [B3] partout: il est indispensable que les newblocs qui sont conserves a
  a sortie d'un programme soient des GEN, sinon la fonction taille fait une
  segfault. Seule exception (testee dans taille) bernzone, ou bernzone[0]
  est initialisee a sa longueur totale.
  Pas encore corrige: le p=(entree **)newbloc dans le type 101 d'identifier,
  qui pourrait expliquer la bug Skoruppa.
228) [M2] init.c: modifie \k et \q pour etre le plus correct possible
  (fonctions killall() et freeall()).
229) [M3] gen1.c, gmul(): la multiplication des polynomes par des zeros
  inexacts est corrigee.
230) [N] base1.c: ecrit galoisconjforce().
231) [N] base1.c: ecrit galoisapply().
232) [B1] buch2.c, isprincipalall(): verification que le generateur est 
  correct.
233) [M3], [B1] polarit2.c, factor(): ecrit la procedure polynomialtype() qui
  fait un effort serieux pour determiner le type de factorisation a utiliser.
  De plus, on peut maintenant factoriser des polynomes a coefficients dans
  Q(i) ou quadratiques.
234) [M3], [B1] polarit1.c, dans tous les factmod(): multiplier
  systematiquement par mod(1,p) avant.
235) [N] gpxx.c: introduit la commande \[ qui permet de changer la valeur
  de compact_arrays, et mis par defaut a disabled.
236) [N] base1.c: ecrit isisomfast() et isinclfast().
237) [M3] polarit1.c: renomme factmod() en factcantor() et factberl() en
  factmod(), c'est a dire que Berlekamp devient l'algorithme par defaut.
238) [M4] partout, mais surtout dans init.c: changement complet de la structure
  de bloc, ainsi que d'autres modifs du meme type.
239) [B2] gen1.c, gadd() case 7+case 7 gestion de pile incorrecte (il faudra
  enlever tous les (GEN)1).
240) [M2] base2.c: modifie element_powmodpr() et macros du meme type deplacees
  dans gencom.h.
241) [N] mis element_pow() dans GP sous le nom de nfpow().
242) [M1] Corrections finales aux sources et au manuel pour la release 1.39

----------------------------- Version 1.39 le 16/01/95 ----------------------



